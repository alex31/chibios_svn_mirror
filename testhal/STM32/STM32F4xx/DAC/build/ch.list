
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	08004851 	.word	0x08004851
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002bb 	.word	0x080002bb
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	080002bb 	.word	0x080002bb
 800005c:	080002bb 	.word	0x080002bb
 8000060:	080002bb 	.word	0x080002bb
 8000064:	080002bb 	.word	0x080002bb
 8000068:	080002bb 	.word	0x080002bb
 800006c:	08001701 	.word	0x08001701
 8000070:	08001761 	.word	0x08001761
 8000074:	080017c1 	.word	0x080017c1
 8000078:	08001821 	.word	0x08001821
 800007c:	08001881 	.word	0x08001881
 8000080:	080018e1 	.word	0x080018e1
 8000084:	08001941 	.word	0x08001941
 8000088:	080002bb 	.word	0x080002bb
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	080002bb 	.word	0x080002bb
 80000a0:	080002bb 	.word	0x080002bb
 80000a4:	080002bb 	.word	0x080002bb
 80000a8:	080002bb 	.word	0x080002bb
 80000ac:	080002bb 	.word	0x080002bb
 80000b0:	08000da1 	.word	0x08000da1
 80000b4:	080002bb 	.word	0x080002bb
 80000b8:	080002bb 	.word	0x080002bb
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	080002bb 	.word	0x080002bb
 80000d8:	080002bb 	.word	0x080002bb
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	080002bb 	.word	0x080002bb
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	080019a1 	.word	0x080019a1
 8000100:	080002bb 	.word	0x080002bb
 8000104:	080002bb 	.word	0x080002bb
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	08000e11 	.word	0x08000e11
 800011c:	080002bb 	.word	0x080002bb
 8000120:	08001a01 	.word	0x08001a01
 8000124:	08001a61 	.word	0x08001a61
 8000128:	08001ac1 	.word	0x08001ac1
 800012c:	08001b21 	.word	0x08001b21
 8000130:	08001b81 	.word	0x08001b81
 8000134:	080002bb 	.word	0x080002bb
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	08001be1 	.word	0x08001be1
 8000154:	08001c41 	.word	0x08001c41
 8000158:	08001ca1 	.word	0x08001ca1
 800015c:	080002bb 	.word	0x080002bb
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080002bb 	.word	0x080002bb
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	080002bb 	.word	0x080002bb
 80001c4:	080002bb 	.word	0x080002bb
 80001c8:	080002bb 	.word	0x080002bb
 80001cc:	080002bb 	.word	0x080002bb
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	; (800027c <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4825      	ldr	r0, [pc, #148]	; (8000280 <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ee:	4825      	ldr	r0, [pc, #148]	; (8000284 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001f0:	4925      	ldr	r1, [pc, #148]	; (8000288 <endfiniloop+0x12>)
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001fe:	f000 f87f 	bl	8000300 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f002 f9ed 	bl	80025e0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	4920      	ldr	r1, [pc, #128]	; (800028c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1b      	ldr	r2, [pc, #108]	; (800027c <endfiniloop+0x6>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491d      	ldr	r1, [pc, #116]	; (8000290 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800021a:	4a19      	ldr	r2, [pc, #100]	; (8000280 <endfiniloop+0xa>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000226:	491b      	ldr	r1, [pc, #108]	; (8000294 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000228:	4a1b      	ldr	r2, [pc, #108]	; (8000298 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800022a:	4b1c      	ldr	r3, [pc, #112]	; (800029c <endfiniloop+0x26>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800023c:	4918      	ldr	r1, [pc, #96]	; (80002a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800023e:	4a19      	ldr	r2, [pc, #100]	; (80002a4 <endfiniloop+0x2e>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f000 f871 	bl	8000330 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f000 f85f 	bl	8000310 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000252:	4c15      	ldr	r4, [pc, #84]	; (80002a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000254:	4d15      	ldr	r5, [pc, #84]	; (80002ac <endfiniloop+0x36>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f004 fbdd 	bl	8004a20 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000266:	4c12      	ldr	r4, [pc, #72]	; (80002b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000268:	4d12      	ldr	r5, [pc, #72]	; (80002b4 <endfiniloop+0x3e>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f000 b853 	b.w	8000320 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800027c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000280:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000284:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000288:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	08005400 	.word	0x08005400
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000800 	.word	0x20000800
                ldr     r1, =__bss_base__
 80002a0:	20000800 	.word	0x20000800
                ldr     r2, =__bss_end__
 80002a4:	20001340 	.word	0x20001340
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002d0:	f002 faae 	bl	8002830 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002da:	4628      	mov	r0, r5
                blx     r4
 80002dc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002de:	2000      	movs	r0, #0
                bl      chThdExit
 80002e0:	f003 ff5e 	bl	80041a0 <chThdExit>

080002e4 <.zombies>:
.zombies:       b       .zombies
 80002e4:	e7fe      	b.n	80002e4 <.zombies>

080002e6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80002e6:	f002 fa7b 	bl	80027e0 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80002ea:	f003 fc09 	bl	8003b00 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002ee:	f002 fa9f 	bl	8002830 <__dbg_check_unlock>

080002f2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002f2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002f4:	e7fe      	b.n	80002f4 <__port_exit_from_isr+0x2>
	...

08000300 <__cpu_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __cpu_init(void) {
 8000300:	b480      	push	{r7}
 8000302:	af00      	add	r7, sp, #0

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000304:	bf00      	nop
 8000306:	46bd      	mov	sp, r7
 8000308:	bc80      	pop	{r7}
 800030a:	4770      	bx	lr
 800030c:	0000      	movs	r0, r0
	...

08000310 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000310:	b480      	push	{r7}
 8000312:	af00      	add	r7, sp, #0
 8000314:	bf00      	nop
 8000316:	46bd      	mov	sp, r7
 8000318:	bc80      	pop	{r7}
 800031a:	4770      	bx	lr
 800031c:	0000      	movs	r0, r0
	...

08000320 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8000320:	b480      	push	{r7}
 8000322:	af00      	add	r7, sp, #0
/*lint -restore*/

  while (true) {
 8000324:	e7fe      	b.n	8000324 <__default_exit+0x4>
 8000326:	bf00      	nop
	...

08000330 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000330:	b480      	push	{r7}
 8000332:	b085      	sub	sp, #20
 8000334:	af00      	add	r7, sp, #0
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000336:	4b18      	ldr	r3, [pc, #96]	; (8000398 <__init_ram_areas+0x68>)
 8000338:	60fb      	str	r3, [r7, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 800033a:	68fb      	ldr	r3, [r7, #12]
 800033c:	681b      	ldr	r3, [r3, #0]
 800033e:	60bb      	str	r3, [r7, #8]
    uint32_t *p = rap->init_area;
 8000340:	68fb      	ldr	r3, [r7, #12]
 8000342:	685b      	ldr	r3, [r3, #4]
 8000344:	607b      	str	r3, [r7, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000346:	e009      	b.n	800035c <__init_ram_areas+0x2c>
      *p = *tp;
 8000348:	68bb      	ldr	r3, [r7, #8]
 800034a:	681a      	ldr	r2, [r3, #0]
 800034c:	687b      	ldr	r3, [r7, #4]
 800034e:	601a      	str	r2, [r3, #0]
      p++;
 8000350:	687b      	ldr	r3, [r7, #4]
 8000352:	3304      	adds	r3, #4
 8000354:	607b      	str	r3, [r7, #4]
      tp++;
 8000356:	68bb      	ldr	r3, [r7, #8]
 8000358:	3304      	adds	r3, #4
 800035a:	60bb      	str	r3, [r7, #8]
    while (p < rap->clear_area) {
 800035c:	68fb      	ldr	r3, [r7, #12]
 800035e:	689b      	ldr	r3, [r3, #8]
 8000360:	687a      	ldr	r2, [r7, #4]
 8000362:	429a      	cmp	r2, r3
 8000364:	d3f0      	bcc.n	8000348 <__init_ram_areas+0x18>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000366:	e005      	b.n	8000374 <__init_ram_areas+0x44>
      *p = 0;
 8000368:	687b      	ldr	r3, [r7, #4]
 800036a:	2200      	movs	r2, #0
 800036c:	601a      	str	r2, [r3, #0]
      p++;
 800036e:	687b      	ldr	r3, [r7, #4]
 8000370:	3304      	adds	r3, #4
 8000372:	607b      	str	r3, [r7, #4]
    while (p < rap->no_init_area) {
 8000374:	68fb      	ldr	r3, [r7, #12]
 8000376:	68db      	ldr	r3, [r3, #12]
 8000378:	687a      	ldr	r2, [r7, #4]
 800037a:	429a      	cmp	r2, r3
 800037c:	d3f4      	bcc.n	8000368 <__init_ram_areas+0x38>
    }
    rap++;
 800037e:	68fb      	ldr	r3, [r7, #12]
 8000380:	3310      	adds	r3, #16
 8000382:	60fb      	str	r3, [r7, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000384:	68fb      	ldr	r3, [r7, #12]
 8000386:	4a05      	ldr	r2, [pc, #20]	; (800039c <__init_ram_areas+0x6c>)
 8000388:	4293      	cmp	r3, r2
 800038a:	d3d6      	bcc.n	800033a <__init_ram_areas+0xa>
#endif
}
 800038c:	bf00      	nop
 800038e:	bf00      	nop
 8000390:	3714      	adds	r7, #20
 8000392:	46bd      	mov	sp, r7
 8000394:	bc80      	pop	{r7}
 8000396:	4770      	bx	lr
 8000398:	08004b1c 	.word	0x08004b1c
 800039c:	08004b9c 	.word	0x08004b9c

080003a0 <osalInit>:
/**
 * @brief   OSAL module initialization.
 *
 * @api
 */
static inline void osalInit(void) {
 80003a0:	b480      	push	{r7}
 80003a2:	af00      	add	r7, sp, #0

}
 80003a4:	bf00      	nop
 80003a6:	46bd      	mov	sp, r7
 80003a8:	bc80      	pop	{r7}
 80003aa:	4770      	bx	lr
 80003ac:	0000      	movs	r0, r0
	...

080003b0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80003b0:	b580      	push	{r7, lr}
 80003b2:	af00      	add	r7, sp, #0

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80003b4:	f7ff fff4 	bl	80003a0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80003b8:	f000 fdc2 	bl	8000f40 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 80003bc:	f001 fdf0 	bl	8001fa0 <_pal_lld_init>
#endif
#if (HAL_USE_CRY == TRUE) || defined(__DOXYGEN__)
  cryInit();
#endif
#if (HAL_USE_DAC == TRUE) || defined(__DOXYGEN__)
  dacInit();
 80003c0:	f000 f926 	bl	8000610 <dacInit>
#endif
#if (HAL_USE_EFL == TRUE) || defined(__DOXYGEN__)
  eflInit();
#endif
#if (HAL_USE_GPT == TRUE) || defined(__DOXYGEN__)
  gptInit();
 80003c4:	f000 fabc 	bl	8000940 <gptInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80003c8:	f002 f912 	bl	80025f0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80003cc:	f000 f860 	bl	8000490 <stInit>
#endif
}
 80003d0:	bf00      	nop
 80003d2:	bd80      	pop	{r7, pc}
	...

080003e0 <st_lld_get_counter>:
 *
 * @return              The counter value.
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {
 80003e0:	b480      	push	{r7}
 80003e2:	af00      	add	r7, sp, #0

  return (systime_t)STM32_ST_TIM->CNT;
 80003e4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80003e8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80003ea:	4618      	mov	r0, r3
 80003ec:	46bd      	mov	sp, r7
 80003ee:	bc80      	pop	{r7}
 80003f0:	4770      	bx	lr
 80003f2:	bf00      	nop
	...

08000400 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 8000400:	b480      	push	{r7}
 8000402:	b083      	sub	sp, #12
 8000404:	af00      	add	r7, sp, #0
 8000406:	6078      	str	r0, [r7, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000408:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800040c:	687b      	ldr	r3, [r7, #4]
 800040e:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8000410:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000414:	2200      	movs	r2, #0
 8000416:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000418:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800041c:	2202      	movs	r2, #2
 800041e:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 8000420:	bf00      	nop
 8000422:	370c      	adds	r7, #12
 8000424:	46bd      	mov	sp, r7
 8000426:	bc80      	pop	{r7}
 8000428:	4770      	bx	lr
 800042a:	bf00      	nop
 800042c:	0000      	movs	r0, r0
	...

08000430 <st_lld_stop_alarm>:
/**
 * @brief   Stops the alarm interrupt.
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {
 8000430:	b480      	push	{r7}
 8000432:	af00      	add	r7, sp, #0

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000434:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000438:	2200      	movs	r2, #0
 800043a:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 800043c:	bf00      	nop
 800043e:	46bd      	mov	sp, r7
 8000440:	bc80      	pop	{r7}
 8000442:	4770      	bx	lr
	...

08000450 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 8000450:	b480      	push	{r7}
 8000452:	b083      	sub	sp, #12
 8000454:	af00      	add	r7, sp, #0
 8000456:	6078      	str	r0, [r7, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000458:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 800045c:	687b      	ldr	r3, [r7, #4]
 800045e:	6353      	str	r3, [r2, #52]	; 0x34
}
 8000460:	bf00      	nop
 8000462:	370c      	adds	r7, #12
 8000464:	46bd      	mov	sp, r7
 8000466:	bc80      	pop	{r7}
 8000468:	4770      	bx	lr
 800046a:	bf00      	nop
 800046c:	0000      	movs	r0, r0
	...

08000470 <st_lld_is_alarm_active>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {
 8000470:	b480      	push	{r7}
 8000472:	af00      	add	r7, sp, #0

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000474:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000478:	68db      	ldr	r3, [r3, #12]
 800047a:	f003 0302 	and.w	r3, r3, #2
 800047e:	2b00      	cmp	r3, #0
 8000480:	bf14      	ite	ne
 8000482:	2301      	movne	r3, #1
 8000484:	2300      	moveq	r3, #0
 8000486:	b2db      	uxtb	r3, r3
}
 8000488:	4618      	mov	r0, r3
 800048a:	46bd      	mov	sp, r7
 800048c:	bc80      	pop	{r7}
 800048e:	4770      	bx	lr

08000490 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000490:	b580      	push	{r7, lr}
 8000492:	af00      	add	r7, sp, #0

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000494:	f001 fe94 	bl	80021c0 <st_lld_init>
}
 8000498:	bf00      	nop
 800049a:	bd80      	pop	{r7, pc}
 800049c:	0000      	movs	r0, r0
	...

080004a0 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 80004a0:	b580      	push	{r7, lr}
 80004a2:	af00      	add	r7, sp, #0

  return st_lld_get_counter();
 80004a4:	f7ff ff9c 	bl	80003e0 <st_lld_get_counter>
 80004a8:	4603      	mov	r3, r0
}
 80004aa:	4618      	mov	r0, r3
 80004ac:	bd80      	pop	{r7, pc}
 80004ae:	bf00      	nop

080004b0 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 80004b0:	b580      	push	{r7, lr}
 80004b2:	b082      	sub	sp, #8
 80004b4:	af00      	add	r7, sp, #0
 80004b6:	6078      	str	r0, [r7, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 80004b8:	f000 f832 	bl	8000520 <stIsAlarmActive>
 80004bc:	4603      	mov	r3, r0
 80004be:	2b00      	cmp	r3, #0
 80004c0:	d002      	beq.n	80004c8 <stStartAlarm+0x18>
 80004c2:	4805      	ldr	r0, [pc, #20]	; (80004d8 <stStartAlarm+0x28>)
 80004c4:	f002 f934 	bl	8002730 <chSysHalt>

  st_lld_start_alarm(abstime);
 80004c8:	6878      	ldr	r0, [r7, #4]
 80004ca:	f7ff ff99 	bl	8000400 <st_lld_start_alarm>
}
 80004ce:	bf00      	nop
 80004d0:	3708      	adds	r7, #8
 80004d2:	46bd      	mov	sp, r7
 80004d4:	bd80      	pop	{r7, pc}
 80004d6:	bf00      	nop
 80004d8:	08004b9c 	.word	0x08004b9c
 80004dc:	00000000 	.word	0x00000000

080004e0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80004e0:	b580      	push	{r7, lr}
 80004e2:	af00      	add	r7, sp, #0

  st_lld_stop_alarm();
 80004e4:	f7ff ffa4 	bl	8000430 <st_lld_stop_alarm>
}
 80004e8:	bf00      	nop
 80004ea:	bd80      	pop	{r7, pc}
 80004ec:	0000      	movs	r0, r0
	...

080004f0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80004f0:	b580      	push	{r7, lr}
 80004f2:	b082      	sub	sp, #8
 80004f4:	af00      	add	r7, sp, #0
 80004f6:	6078      	str	r0, [r7, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80004f8:	f000 f812 	bl	8000520 <stIsAlarmActive>
 80004fc:	4603      	mov	r3, r0
 80004fe:	f083 0301 	eor.w	r3, r3, #1
 8000502:	b2db      	uxtb	r3, r3
 8000504:	2b00      	cmp	r3, #0
 8000506:	d002      	beq.n	800050e <stSetAlarm+0x1e>
 8000508:	4804      	ldr	r0, [pc, #16]	; (800051c <stSetAlarm+0x2c>)
 800050a:	f002 f911 	bl	8002730 <chSysHalt>

  st_lld_set_alarm(abstime);
 800050e:	6878      	ldr	r0, [r7, #4]
 8000510:	f7ff ff9e 	bl	8000450 <st_lld_set_alarm>
}
 8000514:	bf00      	nop
 8000516:	3708      	adds	r7, #8
 8000518:	46bd      	mov	sp, r7
 800051a:	bd80      	pop	{r7, pc}
 800051c:	08004bac 	.word	0x08004bac

08000520 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 8000520:	b580      	push	{r7, lr}
 8000522:	af00      	add	r7, sp, #0

  return st_lld_is_alarm_active();
 8000524:	f7ff ffa4 	bl	8000470 <st_lld_is_alarm_active>
 8000528:	4603      	mov	r3, r0
}
 800052a:	4618      	mov	r0, r3
 800052c:	bd80      	pop	{r7, pc}
 800052e:	bf00      	nop

08000530 <chSysLock>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000530:	b580      	push	{r7, lr}
 8000532:	b082      	sub	sp, #8
 8000534:	af00      	add	r7, sp, #0
 8000536:	2330      	movs	r3, #48	; 0x30
 8000538:	607b      	str	r3, [r7, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800053a:	687b      	ldr	r3, [r7, #4]
 800053c:	f383 8811 	msr	BASEPRI, r3
}
 8000540:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000542:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000544:	f002 f94c 	bl	80027e0 <__dbg_check_lock>
}
 8000548:	bf00      	nop
 800054a:	3708      	adds	r7, #8
 800054c:	46bd      	mov	sp, r7
 800054e:	bd80      	pop	{r7, pc}

08000550 <chSysUnlock>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000550:	b580      	push	{r7, lr}
 8000552:	b082      	sub	sp, #8
 8000554:	af00      	add	r7, sp, #0

  __dbg_check_unlock();
 8000556:	f002 f96b 	bl	8002830 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 800055a:	4b12      	ldr	r3, [pc, #72]	; (80005a4 <chSysUnlock+0x54>)
 800055c:	681b      	ldr	r3, [r3, #0]
 800055e:	4a11      	ldr	r2, [pc, #68]	; (80005a4 <chSysUnlock+0x54>)
 8000560:	4293      	cmp	r3, r2
 8000562:	bf14      	ite	ne
 8000564:	2301      	movne	r3, #1
 8000566:	2300      	moveq	r3, #0
 8000568:	b2db      	uxtb	r3, r3
 800056a:	2b00      	cmp	r3, #0
 800056c:	d00f      	beq.n	800058e <chSysUnlock+0x3e>
 800056e:	4b0d      	ldr	r3, [pc, #52]	; (80005a4 <chSysUnlock+0x54>)
 8000570:	68db      	ldr	r3, [r3, #12]
 8000572:	689a      	ldr	r2, [r3, #8]
 8000574:	4b0b      	ldr	r3, [pc, #44]	; (80005a4 <chSysUnlock+0x54>)
 8000576:	681b      	ldr	r3, [r3, #0]
 8000578:	689b      	ldr	r3, [r3, #8]
 800057a:	429a      	cmp	r2, r3
 800057c:	bf34      	ite	cc
 800057e:	2301      	movcc	r3, #1
 8000580:	2300      	movcs	r3, #0
 8000582:	b2db      	uxtb	r3, r3
 8000584:	2b00      	cmp	r3, #0
 8000586:	d002      	beq.n	800058e <chSysUnlock+0x3e>
 8000588:	4807      	ldr	r0, [pc, #28]	; (80005a8 <chSysUnlock+0x58>)
 800058a:	f002 f8d1 	bl	8002730 <chSysHalt>
 800058e:	2300      	movs	r3, #0
 8000590:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000592:	687b      	ldr	r3, [r7, #4]
 8000594:	f383 8811 	msr	BASEPRI, r3
}
 8000598:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800059a:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 800059c:	bf00      	nop
 800059e:	3708      	adds	r7, #8
 80005a0:	46bd      	mov	sp, r7
 80005a2:	bd80      	pop	{r7, pc}
 80005a4:	20000900 	.word	0x20000900
 80005a8:	08004bc4 	.word	0x08004bc4
 80005ac:	00000000 	.word	0x00000000

080005b0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80005b0:	b580      	push	{r7, lr}
 80005b2:	af00      	add	r7, sp, #0

  chSysLock();
 80005b4:	f7ff ffbc 	bl	8000530 <chSysLock>
}
 80005b8:	bf00      	nop
 80005ba:	bd80      	pop	{r7, pc}
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80005c0:	b580      	push	{r7, lr}
 80005c2:	af00      	add	r7, sp, #0

  chSysUnlock();
 80005c4:	f7ff ffc4 	bl	8000550 <chSysUnlock>
}
 80005c8:	bf00      	nop
 80005ca:	bd80      	pop	{r7, pc}
 80005cc:	0000      	movs	r0, r0
	...

080005d0 <osalThreadResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeS(thread_reference_t *trp, msg_t msg) {
 80005d0:	b580      	push	{r7, lr}
 80005d2:	b082      	sub	sp, #8
 80005d4:	af00      	add	r7, sp, #0
 80005d6:	6078      	str	r0, [r7, #4]
 80005d8:	6039      	str	r1, [r7, #0]

  chThdResumeS(trp, msg);
 80005da:	6839      	ldr	r1, [r7, #0]
 80005dc:	6878      	ldr	r0, [r7, #4]
 80005de:	f003 fe6f 	bl	80042c0 <chThdResumeS>
}
 80005e2:	bf00      	nop
 80005e4:	3708      	adds	r7, #8
 80005e6:	46bd      	mov	sp, r7
 80005e8:	bd80      	pop	{r7, pc}
 80005ea:	bf00      	nop
 80005ec:	0000      	movs	r0, r0
	...

080005f0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80005f0:	b580      	push	{r7, lr}
 80005f2:	b082      	sub	sp, #8
 80005f4:	af00      	add	r7, sp, #0
 80005f6:	6078      	str	r0, [r7, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80005f8:	6878      	ldr	r0, [r7, #4]
 80005fa:	f003 ff21 	bl	8004440 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80005fe:	bf00      	nop
 8000600:	3708      	adds	r7, #8
 8000602:	46bd      	mov	sp, r7
 8000604:	bd80      	pop	{r7, pc}
 8000606:	bf00      	nop
	...

08000610 <dacInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void dacInit(void) {
 8000610:	b580      	push	{r7, lr}
 8000612:	af00      	add	r7, sp, #0

  dac_lld_init();
 8000614:	f000 fe5c 	bl	80012d0 <dac_lld_init>
}
 8000618:	bf00      	nop
 800061a:	bd80      	pop	{r7, pc}
 800061c:	0000      	movs	r0, r0
	...

08000620 <dacObjectInit>:
 *
 * @param[out] dacp     pointer to the @p DACDriver object
 *
 * @init
 */
void dacObjectInit(DACDriver *dacp) {
 8000620:	b580      	push	{r7, lr}
 8000622:	b082      	sub	sp, #8
 8000624:	af00      	add	r7, sp, #0
 8000626:	6078      	str	r0, [r7, #4]

  dacp->state = DAC_STOP;
 8000628:	687b      	ldr	r3, [r7, #4]
 800062a:	2201      	movs	r2, #1
 800062c:	701a      	strb	r2, [r3, #0]
  dacp->config = NULL;
 800062e:	687b      	ldr	r3, [r7, #4]
 8000630:	2200      	movs	r2, #0
 8000632:	611a      	str	r2, [r3, #16]
#if DAC_USE_WAIT
  dacp->thread = NULL;
 8000634:	687b      	ldr	r3, [r7, #4]
 8000636:	2200      	movs	r2, #0
 8000638:	615a      	str	r2, [r3, #20]
#endif
#if DAC_USE_MUTUAL_EXCLUSION
  osalMutexObjectInit(&dacp->mutex);
 800063a:	687b      	ldr	r3, [r7, #4]
 800063c:	3318      	adds	r3, #24
 800063e:	4618      	mov	r0, r3
 8000640:	f7ff ffd6 	bl	80005f0 <osalMutexObjectInit>
#endif
#if defined(DAC_DRIVER_EXT_INIT_HOOK)
  DAC_DRIVER_EXT_INIT_HOOK(dacp);
#endif
}
 8000644:	bf00      	nop
 8000646:	3708      	adds	r7, #8
 8000648:	46bd      	mov	sp, r7
 800064a:	bd80      	pop	{r7, pc}
 800064c:	0000      	movs	r0, r0
	...

08000650 <dacStart>:
 *                      supports a default configuration
 * @return              The operation status.
 *
 * @api
 */
msg_t dacStart(DACDriver *dacp, const DACConfig *config) {
 8000650:	b580      	push	{r7, lr}
 8000652:	b084      	sub	sp, #16
 8000654:	af00      	add	r7, sp, #0
 8000656:	6078      	str	r0, [r7, #4]
 8000658:	6039      	str	r1, [r7, #0]
  msg_t msg;

  osalDbgCheck(dacp != NULL);
 800065a:	687b      	ldr	r3, [r7, #4]
 800065c:	2b00      	cmp	r3, #0
 800065e:	bf0c      	ite	eq
 8000660:	2301      	moveq	r3, #1
 8000662:	2300      	movne	r3, #0
 8000664:	b2db      	uxtb	r3, r3
 8000666:	2b00      	cmp	r3, #0
 8000668:	d002      	beq.n	8000670 <dacStart+0x20>
 800066a:	4819      	ldr	r0, [pc, #100]	; (80006d0 <dacStart+0x80>)
 800066c:	f002 f860 	bl	8002730 <chSysHalt>

  osalSysLock();
 8000670:	f7ff ff9e 	bl	80005b0 <osalSysLock>

  osalDbgAssert((dacp->state == DAC_STOP) || (dacp->state == DAC_READY),
 8000674:	687b      	ldr	r3, [r7, #4]
 8000676:	781b      	ldrb	r3, [r3, #0]
 8000678:	2b01      	cmp	r3, #1
 800067a:	bf14      	ite	ne
 800067c:	2301      	movne	r3, #1
 800067e:	2300      	moveq	r3, #0
 8000680:	b2db      	uxtb	r3, r3
 8000682:	2b00      	cmp	r3, #0
 8000684:	d00b      	beq.n	800069e <dacStart+0x4e>
 8000686:	687b      	ldr	r3, [r7, #4]
 8000688:	781b      	ldrb	r3, [r3, #0]
 800068a:	2b02      	cmp	r3, #2
 800068c:	bf14      	ite	ne
 800068e:	2301      	movne	r3, #1
 8000690:	2300      	moveq	r3, #0
 8000692:	b2db      	uxtb	r3, r3
 8000694:	2b00      	cmp	r3, #0
 8000696:	d002      	beq.n	800069e <dacStart+0x4e>
 8000698:	480d      	ldr	r0, [pc, #52]	; (80006d0 <dacStart+0x80>)
 800069a:	f002 f849 	bl	8002730 <chSysHalt>
                "invalid state");

  dacp->config = config;
 800069e:	687b      	ldr	r3, [r7, #4]
 80006a0:	683a      	ldr	r2, [r7, #0]
 80006a2:	611a      	str	r2, [r3, #16]

#if defined(DAC_LLD_ENHANCED_API)
  msg = dac_lld_start(dacp);
#else
  dac_lld_start(dacp);
 80006a4:	6878      	ldr	r0, [r7, #4]
 80006a6:	f000 fe33 	bl	8001310 <dac_lld_start>
  msg = HAL_RET_SUCCESS;
 80006aa:	2300      	movs	r3, #0
 80006ac:	60fb      	str	r3, [r7, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 80006ae:	68fb      	ldr	r3, [r7, #12]
 80006b0:	2b00      	cmp	r3, #0
 80006b2:	d103      	bne.n	80006bc <dacStart+0x6c>
    dacp->state = DAC_READY;
 80006b4:	687b      	ldr	r3, [r7, #4]
 80006b6:	2202      	movs	r2, #2
 80006b8:	701a      	strb	r2, [r3, #0]
 80006ba:	e002      	b.n	80006c2 <dacStart+0x72>
  }
  else {
    dacp->state = DAC_STOP;
 80006bc:	687b      	ldr	r3, [r7, #4]
 80006be:	2201      	movs	r2, #1
 80006c0:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80006c2:	f7ff ff7d 	bl	80005c0 <osalSysUnlock>

  return msg;
 80006c6:	68fb      	ldr	r3, [r7, #12]
}
 80006c8:	4618      	mov	r0, r3
 80006ca:	3710      	adds	r7, #16
 80006cc:	46bd      	mov	sp, r7
 80006ce:	bd80      	pop	{r7, pc}
 80006d0:	08004bb8 	.word	0x08004bb8
	...

080006e0 <dacStartConversion>:
 * @api
 */
void dacStartConversion(DACDriver *dacp,
                        const DACConversionGroup *grpp,
                        dacsample_t *samples,
                        size_t depth) {
 80006e0:	b580      	push	{r7, lr}
 80006e2:	b084      	sub	sp, #16
 80006e4:	af00      	add	r7, sp, #0
 80006e6:	60f8      	str	r0, [r7, #12]
 80006e8:	60b9      	str	r1, [r7, #8]
 80006ea:	607a      	str	r2, [r7, #4]
 80006ec:	603b      	str	r3, [r7, #0]

  osalSysLock();
 80006ee:	f7ff ff5f 	bl	80005b0 <osalSysLock>
  dacStartConversionI(dacp, grpp, samples, depth);
 80006f2:	683b      	ldr	r3, [r7, #0]
 80006f4:	687a      	ldr	r2, [r7, #4]
 80006f6:	68b9      	ldr	r1, [r7, #8]
 80006f8:	68f8      	ldr	r0, [r7, #12]
 80006fa:	f000 f809 	bl	8000710 <dacStartConversionI>
  osalSysUnlock();
 80006fe:	f7ff ff5f 	bl	80005c0 <osalSysUnlock>
}
 8000702:	bf00      	nop
 8000704:	3710      	adds	r7, #16
 8000706:	46bd      	mov	sp, r7
 8000708:	bd80      	pop	{r7, pc}
 800070a:	bf00      	nop
 800070c:	0000      	movs	r0, r0
	...

08000710 <dacStartConversionI>:
 * @iclass
 */
void dacStartConversionI(DACDriver *dacp,
                         const DACConversionGroup *grpp,
                         dacsample_t *samples,
                         size_t depth) {
 8000710:	b580      	push	{r7, lr}
 8000712:	b084      	sub	sp, #16
 8000714:	af00      	add	r7, sp, #0
 8000716:	60f8      	str	r0, [r7, #12]
 8000718:	60b9      	str	r1, [r7, #8]
 800071a:	607a      	str	r2, [r7, #4]
 800071c:	603b      	str	r3, [r7, #0]

  osalDbgCheckClassI();
 800071e:	f002 f977 	bl	8002a10 <chDbgCheckClassI>
  osalDbgCheck((dacp != NULL) && (grpp != NULL) && (samples != NULL) &&
 8000722:	68fb      	ldr	r3, [r7, #12]
 8000724:	2b00      	cmp	r3, #0
 8000726:	bf0c      	ite	eq
 8000728:	2301      	moveq	r3, #1
 800072a:	2300      	movne	r3, #0
 800072c:	b2db      	uxtb	r3, r3
 800072e:	2b00      	cmp	r3, #0
 8000730:	d107      	bne.n	8000742 <dacStartConversionI+0x32>
 8000732:	68bb      	ldr	r3, [r7, #8]
 8000734:	2b00      	cmp	r3, #0
 8000736:	bf0c      	ite	eq
 8000738:	2301      	moveq	r3, #1
 800073a:	2300      	movne	r3, #0
 800073c:	b2db      	uxtb	r3, r3
 800073e:	2b00      	cmp	r3, #0
 8000740:	d001      	beq.n	8000746 <dacStartConversionI+0x36>
 8000742:	2301      	movs	r3, #1
 8000744:	e000      	b.n	8000748 <dacStartConversionI+0x38>
 8000746:	2300      	movs	r3, #0
 8000748:	2b00      	cmp	r3, #0
 800074a:	d107      	bne.n	800075c <dacStartConversionI+0x4c>
 800074c:	687b      	ldr	r3, [r7, #4]
 800074e:	2b00      	cmp	r3, #0
 8000750:	bf0c      	ite	eq
 8000752:	2301      	moveq	r3, #1
 8000754:	2300      	movne	r3, #0
 8000756:	b2db      	uxtb	r3, r3
 8000758:	2b00      	cmp	r3, #0
 800075a:	d001      	beq.n	8000760 <dacStartConversionI+0x50>
 800075c:	2301      	movs	r3, #1
 800075e:	e000      	b.n	8000762 <dacStartConversionI+0x52>
 8000760:	2300      	movs	r3, #0
 8000762:	2b00      	cmp	r3, #0
 8000764:	d116      	bne.n	8000794 <dacStartConversionI+0x84>
 8000766:	683b      	ldr	r3, [r7, #0]
 8000768:	2b01      	cmp	r3, #1
 800076a:	bf14      	ite	ne
 800076c:	2301      	movne	r3, #1
 800076e:	2300      	moveq	r3, #0
 8000770:	b2db      	uxtb	r3, r3
 8000772:	2b00      	cmp	r3, #0
 8000774:	d00b      	beq.n	800078e <dacStartConversionI+0x7e>
 8000776:	683b      	ldr	r3, [r7, #0]
 8000778:	f003 0301 	and.w	r3, r3, #1
 800077c:	2b00      	cmp	r3, #0
 800077e:	bf14      	ite	ne
 8000780:	2301      	movne	r3, #1
 8000782:	2300      	moveq	r3, #0
 8000784:	b2db      	uxtb	r3, r3
 8000786:	2b00      	cmp	r3, #0
 8000788:	d001      	beq.n	800078e <dacStartConversionI+0x7e>
 800078a:	2301      	movs	r3, #1
 800078c:	e000      	b.n	8000790 <dacStartConversionI+0x80>
 800078e:	2300      	movs	r3, #0
 8000790:	2b00      	cmp	r3, #0
 8000792:	d002      	beq.n	800079a <dacStartConversionI+0x8a>
 8000794:	481c      	ldr	r0, [pc, #112]	; (8000808 <dacStartConversionI+0xf8>)
 8000796:	f001 ffcb 	bl	8002730 <chSysHalt>
               ((depth == 1U) || ((depth & 1U) == 0U)));
  osalDbgAssert((dacp->state == DAC_READY) ||
 800079a:	68fb      	ldr	r3, [r7, #12]
 800079c:	781b      	ldrb	r3, [r3, #0]
 800079e:	2b02      	cmp	r3, #2
 80007a0:	bf14      	ite	ne
 80007a2:	2301      	movne	r3, #1
 80007a4:	2300      	moveq	r3, #0
 80007a6:	b2db      	uxtb	r3, r3
 80007a8:	2b00      	cmp	r3, #0
 80007aa:	d00a      	beq.n	80007c2 <dacStartConversionI+0xb2>
 80007ac:	68fb      	ldr	r3, [r7, #12]
 80007ae:	781b      	ldrb	r3, [r3, #0]
 80007b0:	2b04      	cmp	r3, #4
 80007b2:	bf14      	ite	ne
 80007b4:	2301      	movne	r3, #1
 80007b6:	2300      	moveq	r3, #0
 80007b8:	b2db      	uxtb	r3, r3
 80007ba:	2b00      	cmp	r3, #0
 80007bc:	d001      	beq.n	80007c2 <dacStartConversionI+0xb2>
 80007be:	2301      	movs	r3, #1
 80007c0:	e000      	b.n	80007c4 <dacStartConversionI+0xb4>
 80007c2:	2300      	movs	r3, #0
 80007c4:	2b00      	cmp	r3, #0
 80007c6:	d00b      	beq.n	80007e0 <dacStartConversionI+0xd0>
 80007c8:	68fb      	ldr	r3, [r7, #12]
 80007ca:	781b      	ldrb	r3, [r3, #0]
 80007cc:	2b05      	cmp	r3, #5
 80007ce:	bf14      	ite	ne
 80007d0:	2301      	movne	r3, #1
 80007d2:	2300      	moveq	r3, #0
 80007d4:	b2db      	uxtb	r3, r3
 80007d6:	2b00      	cmp	r3, #0
 80007d8:	d002      	beq.n	80007e0 <dacStartConversionI+0xd0>
 80007da:	480b      	ldr	r0, [pc, #44]	; (8000808 <dacStartConversionI+0xf8>)
 80007dc:	f001 ffa8 	bl	8002730 <chSysHalt>
                (dacp->state == DAC_COMPLETE) ||
                (dacp->state == DAC_ERROR),
                "not ready");

  dacp->samples  = samples;
 80007e0:	68fb      	ldr	r3, [r7, #12]
 80007e2:	687a      	ldr	r2, [r7, #4]
 80007e4:	609a      	str	r2, [r3, #8]
  dacp->depth    = depth;
 80007e6:	68fb      	ldr	r3, [r7, #12]
 80007e8:	683a      	ldr	r2, [r7, #0]
 80007ea:	60da      	str	r2, [r3, #12]
  dacp->grpp     = grpp;
 80007ec:	68fb      	ldr	r3, [r7, #12]
 80007ee:	68ba      	ldr	r2, [r7, #8]
 80007f0:	605a      	str	r2, [r3, #4]
  dacp->state    = DAC_ACTIVE;
 80007f2:	68fb      	ldr	r3, [r7, #12]
 80007f4:	2203      	movs	r2, #3
 80007f6:	701a      	strb	r2, [r3, #0]
  dac_lld_start_conversion(dacp);
 80007f8:	68f8      	ldr	r0, [r7, #12]
 80007fa:	f000 fe49 	bl	8001490 <dac_lld_start_conversion>
}
 80007fe:	bf00      	nop
 8000800:	3710      	adds	r7, #16
 8000802:	46bd      	mov	sp, r7
 8000804:	bd80      	pop	{r7, pc}
 8000806:	bf00      	nop
 8000808:	08004bd0 	.word	0x08004bd0
 800080c:	00000000 	.word	0x00000000

08000810 <dacStopConversion>:
 *
 * @param[in] dacp      pointer to the @p DACDriver object
 *
 * @api
 */
void dacStopConversion(DACDriver *dacp) {
 8000810:	b580      	push	{r7, lr}
 8000812:	b082      	sub	sp, #8
 8000814:	af00      	add	r7, sp, #0
 8000816:	6078      	str	r0, [r7, #4]

  osalDbgCheck(dacp != NULL);
 8000818:	687b      	ldr	r3, [r7, #4]
 800081a:	2b00      	cmp	r3, #0
 800081c:	bf0c      	ite	eq
 800081e:	2301      	moveq	r3, #1
 8000820:	2300      	movne	r3, #0
 8000822:	b2db      	uxtb	r3, r3
 8000824:	2b00      	cmp	r3, #0
 8000826:	d002      	beq.n	800082e <dacStopConversion+0x1e>
 8000828:	4819      	ldr	r0, [pc, #100]	; (8000890 <dacStopConversion+0x80>)
 800082a:	f001 ff81 	bl	8002730 <chSysHalt>

  osalSysLock();
 800082e:	f7ff febf 	bl	80005b0 <osalSysLock>

  osalDbgAssert((dacp->state == DAC_READY) ||
 8000832:	687b      	ldr	r3, [r7, #4]
 8000834:	781b      	ldrb	r3, [r3, #0]
 8000836:	2b02      	cmp	r3, #2
 8000838:	bf14      	ite	ne
 800083a:	2301      	movne	r3, #1
 800083c:	2300      	moveq	r3, #0
 800083e:	b2db      	uxtb	r3, r3
 8000840:	2b00      	cmp	r3, #0
 8000842:	d00b      	beq.n	800085c <dacStopConversion+0x4c>
 8000844:	687b      	ldr	r3, [r7, #4]
 8000846:	781b      	ldrb	r3, [r3, #0]
 8000848:	2b03      	cmp	r3, #3
 800084a:	bf14      	ite	ne
 800084c:	2301      	movne	r3, #1
 800084e:	2300      	moveq	r3, #0
 8000850:	b2db      	uxtb	r3, r3
 8000852:	2b00      	cmp	r3, #0
 8000854:	d002      	beq.n	800085c <dacStopConversion+0x4c>
 8000856:	480e      	ldr	r0, [pc, #56]	; (8000890 <dacStopConversion+0x80>)
 8000858:	f001 ff6a 	bl	8002730 <chSysHalt>
                (dacp->state == DAC_ACTIVE),
                "invalid state");

  if (dacp->state != DAC_READY) {
 800085c:	687b      	ldr	r3, [r7, #4]
 800085e:	781b      	ldrb	r3, [r3, #0]
 8000860:	2b02      	cmp	r3, #2
 8000862:	d00f      	beq.n	8000884 <dacStopConversion+0x74>
    dac_lld_stop_conversion(dacp);
 8000864:	6878      	ldr	r0, [r7, #4]
 8000866:	f000 fefb 	bl	8001660 <dac_lld_stop_conversion>
    dacp->grpp  = NULL;
 800086a:	687b      	ldr	r3, [r7, #4]
 800086c:	2200      	movs	r2, #0
 800086e:	605a      	str	r2, [r3, #4]
    dacp->state = DAC_READY;
 8000870:	687b      	ldr	r3, [r7, #4]
 8000872:	2202      	movs	r2, #2
 8000874:	701a      	strb	r2, [r3, #0]
    _dac_reset_s(dacp);
 8000876:	687b      	ldr	r3, [r7, #4]
 8000878:	3314      	adds	r3, #20
 800087a:	f06f 0101 	mvn.w	r1, #1
 800087e:	4618      	mov	r0, r3
 8000880:	f7ff fea6 	bl	80005d0 <osalThreadResumeS>
  }

  osalSysUnlock();
 8000884:	f7ff fe9c 	bl	80005c0 <osalSysUnlock>
}
 8000888:	bf00      	nop
 800088a:	3708      	adds	r7, #8
 800088c:	46bd      	mov	sp, r7
 800088e:	bd80      	pop	{r7, pc}
 8000890:	08004be4 	.word	0x08004be4
	...

080008a0 <chSysLock>:
static inline void chSysLock(void) {
 80008a0:	b580      	push	{r7, lr}
 80008a2:	b082      	sub	sp, #8
 80008a4:	af00      	add	r7, sp, #0
 80008a6:	2330      	movs	r3, #48	; 0x30
 80008a8:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008aa:	687b      	ldr	r3, [r7, #4]
 80008ac:	f383 8811 	msr	BASEPRI, r3
}
 80008b0:	bf00      	nop
}
 80008b2:	bf00      	nop
  __dbg_check_lock();
 80008b4:	f001 ff94 	bl	80027e0 <__dbg_check_lock>
}
 80008b8:	bf00      	nop
 80008ba:	3708      	adds	r7, #8
 80008bc:	46bd      	mov	sp, r7
 80008be:	bd80      	pop	{r7, pc}

080008c0 <chSysUnlock>:
static inline void chSysUnlock(void) {
 80008c0:	b580      	push	{r7, lr}
 80008c2:	b082      	sub	sp, #8
 80008c4:	af00      	add	r7, sp, #0
  __dbg_check_unlock();
 80008c6:	f001 ffb3 	bl	8002830 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80008ca:	4b12      	ldr	r3, [pc, #72]	; (8000914 <chSysUnlock+0x54>)
 80008cc:	681b      	ldr	r3, [r3, #0]
 80008ce:	4a11      	ldr	r2, [pc, #68]	; (8000914 <chSysUnlock+0x54>)
 80008d0:	4293      	cmp	r3, r2
 80008d2:	bf14      	ite	ne
 80008d4:	2301      	movne	r3, #1
 80008d6:	2300      	moveq	r3, #0
 80008d8:	b2db      	uxtb	r3, r3
 80008da:	2b00      	cmp	r3, #0
 80008dc:	d00f      	beq.n	80008fe <chSysUnlock+0x3e>
 80008de:	4b0d      	ldr	r3, [pc, #52]	; (8000914 <chSysUnlock+0x54>)
 80008e0:	68db      	ldr	r3, [r3, #12]
 80008e2:	689a      	ldr	r2, [r3, #8]
 80008e4:	4b0b      	ldr	r3, [pc, #44]	; (8000914 <chSysUnlock+0x54>)
 80008e6:	681b      	ldr	r3, [r3, #0]
 80008e8:	689b      	ldr	r3, [r3, #8]
 80008ea:	429a      	cmp	r2, r3
 80008ec:	bf34      	ite	cc
 80008ee:	2301      	movcc	r3, #1
 80008f0:	2300      	movcs	r3, #0
 80008f2:	b2db      	uxtb	r3, r3
 80008f4:	2b00      	cmp	r3, #0
 80008f6:	d002      	beq.n	80008fe <chSysUnlock+0x3e>
 80008f8:	4807      	ldr	r0, [pc, #28]	; (8000918 <chSysUnlock+0x58>)
 80008fa:	f001 ff19 	bl	8002730 <chSysHalt>
 80008fe:	2300      	movs	r3, #0
 8000900:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000902:	687b      	ldr	r3, [r7, #4]
 8000904:	f383 8811 	msr	BASEPRI, r3
}
 8000908:	bf00      	nop
}
 800090a:	bf00      	nop
}
 800090c:	bf00      	nop
 800090e:	3708      	adds	r7, #8
 8000910:	46bd      	mov	sp, r7
 8000912:	bd80      	pop	{r7, pc}
 8000914:	20000900 	.word	0x20000900
 8000918:	08004c04 	.word	0x08004c04
 800091c:	00000000 	.word	0x00000000

08000920 <osalSysLock>:
static inline void osalSysLock(void) {
 8000920:	b580      	push	{r7, lr}
 8000922:	af00      	add	r7, sp, #0
  chSysLock();
 8000924:	f7ff ffbc 	bl	80008a0 <chSysLock>
}
 8000928:	bf00      	nop
 800092a:	bd80      	pop	{r7, pc}
 800092c:	0000      	movs	r0, r0
	...

08000930 <osalSysUnlock>:
static inline void osalSysUnlock(void) {
 8000930:	b580      	push	{r7, lr}
 8000932:	af00      	add	r7, sp, #0
  chSysUnlock();
 8000934:	f7ff ffc4 	bl	80008c0 <chSysUnlock>
}
 8000938:	bf00      	nop
 800093a:	bd80      	pop	{r7, pc}
 800093c:	0000      	movs	r0, r0
	...

08000940 <gptInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void gptInit(void) {
 8000940:	b580      	push	{r7, lr}
 8000942:	af00      	add	r7, sp, #0

  gpt_lld_init();
 8000944:	f001 fca4 	bl	8002290 <gpt_lld_init>
}
 8000948:	bf00      	nop
 800094a:	bd80      	pop	{r7, pc}
 800094c:	0000      	movs	r0, r0
	...

08000950 <gptObjectInit>:
 *
 * @param[out] gptp     pointer to the @p GPTDriver object
 *
 * @init
 */
void gptObjectInit(GPTDriver *gptp) {
 8000950:	b480      	push	{r7}
 8000952:	b083      	sub	sp, #12
 8000954:	af00      	add	r7, sp, #0
 8000956:	6078      	str	r0, [r7, #4]

  gptp->state  = GPT_STOP;
 8000958:	687b      	ldr	r3, [r7, #4]
 800095a:	2201      	movs	r2, #1
 800095c:	701a      	strb	r2, [r3, #0]
  gptp->config = NULL;
 800095e:	687b      	ldr	r3, [r7, #4]
 8000960:	2200      	movs	r2, #0
 8000962:	605a      	str	r2, [r3, #4]
}
 8000964:	bf00      	nop
 8000966:	370c      	adds	r7, #12
 8000968:	46bd      	mov	sp, r7
 800096a:	bc80      	pop	{r7}
 800096c:	4770      	bx	lr
 800096e:	bf00      	nop

08000970 <gptStart>:
 * @param[in] config    pointer to the @p GPTConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t gptStart(GPTDriver *gptp, const GPTConfig *config) {
 8000970:	b580      	push	{r7, lr}
 8000972:	b084      	sub	sp, #16
 8000974:	af00      	add	r7, sp, #0
 8000976:	6078      	str	r0, [r7, #4]
 8000978:	6039      	str	r1, [r7, #0]
  msg_t msg;

  osalDbgCheck((gptp != NULL) && (config != NULL));
 800097a:	687b      	ldr	r3, [r7, #4]
 800097c:	2b00      	cmp	r3, #0
 800097e:	bf0c      	ite	eq
 8000980:	2301      	moveq	r3, #1
 8000982:	2300      	movne	r3, #0
 8000984:	b2db      	uxtb	r3, r3
 8000986:	2b00      	cmp	r3, #0
 8000988:	d107      	bne.n	800099a <gptStart+0x2a>
 800098a:	683b      	ldr	r3, [r7, #0]
 800098c:	2b00      	cmp	r3, #0
 800098e:	bf0c      	ite	eq
 8000990:	2301      	moveq	r3, #1
 8000992:	2300      	movne	r3, #0
 8000994:	b2db      	uxtb	r3, r3
 8000996:	2b00      	cmp	r3, #0
 8000998:	d002      	beq.n	80009a0 <gptStart+0x30>
 800099a:	4819      	ldr	r0, [pc, #100]	; (8000a00 <gptStart+0x90>)
 800099c:	f001 fec8 	bl	8002730 <chSysHalt>

  osalSysLock();
 80009a0:	f7ff ffbe 	bl	8000920 <osalSysLock>

  osalDbgAssert((gptp->state == GPT_STOP) || (gptp->state == GPT_READY),
 80009a4:	687b      	ldr	r3, [r7, #4]
 80009a6:	781b      	ldrb	r3, [r3, #0]
 80009a8:	2b01      	cmp	r3, #1
 80009aa:	bf14      	ite	ne
 80009ac:	2301      	movne	r3, #1
 80009ae:	2300      	moveq	r3, #0
 80009b0:	b2db      	uxtb	r3, r3
 80009b2:	2b00      	cmp	r3, #0
 80009b4:	d00b      	beq.n	80009ce <gptStart+0x5e>
 80009b6:	687b      	ldr	r3, [r7, #4]
 80009b8:	781b      	ldrb	r3, [r3, #0]
 80009ba:	2b02      	cmp	r3, #2
 80009bc:	bf14      	ite	ne
 80009be:	2301      	movne	r3, #1
 80009c0:	2300      	moveq	r3, #0
 80009c2:	b2db      	uxtb	r3, r3
 80009c4:	2b00      	cmp	r3, #0
 80009c6:	d002      	beq.n	80009ce <gptStart+0x5e>
 80009c8:	480d      	ldr	r0, [pc, #52]	; (8000a00 <gptStart+0x90>)
 80009ca:	f001 feb1 	bl	8002730 <chSysHalt>
              "invalid state");

  gptp->config = config;
 80009ce:	687b      	ldr	r3, [r7, #4]
 80009d0:	683a      	ldr	r2, [r7, #0]
 80009d2:	605a      	str	r2, [r3, #4]

#if defined(GPT_LLD_ENHANCED_API)
  msg = gpt_lld_start(gptp);
#else
  gpt_lld_start(gptp);
 80009d4:	6878      	ldr	r0, [r7, #4]
 80009d6:	f001 fc6b 	bl	80022b0 <gpt_lld_start>
  msg = HAL_RET_SUCCESS;
 80009da:	2300      	movs	r3, #0
 80009dc:	60fb      	str	r3, [r7, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 80009de:	68fb      	ldr	r3, [r7, #12]
 80009e0:	2b00      	cmp	r3, #0
 80009e2:	d103      	bne.n	80009ec <gptStart+0x7c>
    gptp->state = GPT_READY;
 80009e4:	687b      	ldr	r3, [r7, #4]
 80009e6:	2202      	movs	r2, #2
 80009e8:	701a      	strb	r2, [r3, #0]
 80009ea:	e002      	b.n	80009f2 <gptStart+0x82>
  }
  else {
    gptp->state = GPT_STOP;
 80009ec:	687b      	ldr	r3, [r7, #4]
 80009ee:	2201      	movs	r2, #1
 80009f0:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80009f2:	f7ff ff9d 	bl	8000930 <osalSysUnlock>

  return msg;
 80009f6:	68fb      	ldr	r3, [r7, #12]
}
 80009f8:	4618      	mov	r0, r3
 80009fa:	3710      	adds	r7, #16
 80009fc:	46bd      	mov	sp, r7
 80009fe:	bd80      	pop	{r7, pc}
 8000a00:	08004bf8 	.word	0x08004bf8
	...

08000a10 <gptStartContinuous>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @api
 */
void gptStartContinuous(GPTDriver *gptp, gptcnt_t interval) {
 8000a10:	b580      	push	{r7, lr}
 8000a12:	b082      	sub	sp, #8
 8000a14:	af00      	add	r7, sp, #0
 8000a16:	6078      	str	r0, [r7, #4]
 8000a18:	6039      	str	r1, [r7, #0]

  osalSysLock();
 8000a1a:	f7ff ff81 	bl	8000920 <osalSysLock>
  gptStartContinuousI(gptp, interval);
 8000a1e:	6839      	ldr	r1, [r7, #0]
 8000a20:	6878      	ldr	r0, [r7, #4]
 8000a22:	f000 f80d 	bl	8000a40 <gptStartContinuousI>
  osalSysUnlock();
 8000a26:	f7ff ff83 	bl	8000930 <osalSysUnlock>
}
 8000a2a:	bf00      	nop
 8000a2c:	3708      	adds	r7, #8
 8000a2e:	46bd      	mov	sp, r7
 8000a30:	bd80      	pop	{r7, pc}
 8000a32:	bf00      	nop
	...

08000a40 <gptStartContinuousI>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @iclass
 */
void gptStartContinuousI(GPTDriver *gptp, gptcnt_t interval) {
 8000a40:	b580      	push	{r7, lr}
 8000a42:	b082      	sub	sp, #8
 8000a44:	af00      	add	r7, sp, #0
 8000a46:	6078      	str	r0, [r7, #4]
 8000a48:	6039      	str	r1, [r7, #0]

  osalDbgCheckClassI();
 8000a4a:	f001 ffe1 	bl	8002a10 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000a4e:	687b      	ldr	r3, [r7, #4]
 8000a50:	2b00      	cmp	r3, #0
 8000a52:	bf0c      	ite	eq
 8000a54:	2301      	moveq	r3, #1
 8000a56:	2300      	movne	r3, #0
 8000a58:	b2db      	uxtb	r3, r3
 8000a5a:	2b00      	cmp	r3, #0
 8000a5c:	d002      	beq.n	8000a64 <gptStartContinuousI+0x24>
 8000a5e:	480d      	ldr	r0, [pc, #52]	; (8000a94 <gptStartContinuousI+0x54>)
 8000a60:	f001 fe66 	bl	8002730 <chSysHalt>
  osalDbgAssert(gptp->state == GPT_READY,
 8000a64:	687b      	ldr	r3, [r7, #4]
 8000a66:	781b      	ldrb	r3, [r3, #0]
 8000a68:	2b02      	cmp	r3, #2
 8000a6a:	bf14      	ite	ne
 8000a6c:	2301      	movne	r3, #1
 8000a6e:	2300      	moveq	r3, #0
 8000a70:	b2db      	uxtb	r3, r3
 8000a72:	2b00      	cmp	r3, #0
 8000a74:	d002      	beq.n	8000a7c <gptStartContinuousI+0x3c>
 8000a76:	4807      	ldr	r0, [pc, #28]	; (8000a94 <gptStartContinuousI+0x54>)
 8000a78:	f001 fe5a 	bl	8002730 <chSysHalt>
                "invalid state");

  gptp->state = GPT_CONTINUOUS;
 8000a7c:	687b      	ldr	r3, [r7, #4]
 8000a7e:	2203      	movs	r2, #3
 8000a80:	701a      	strb	r2, [r3, #0]
  gpt_lld_start_timer(gptp, interval);
 8000a82:	6839      	ldr	r1, [r7, #0]
 8000a84:	6878      	ldr	r0, [r7, #4]
 8000a86:	f001 fc83 	bl	8002390 <gpt_lld_start_timer>
}
 8000a8a:	bf00      	nop
 8000a8c:	3708      	adds	r7, #8
 8000a8e:	46bd      	mov	sp, r7
 8000a90:	bd80      	pop	{r7, pc}
 8000a92:	bf00      	nop
 8000a94:	08004c10 	.word	0x08004c10
	...

08000aa0 <gptStopTimer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimer(GPTDriver *gptp) {
 8000aa0:	b580      	push	{r7, lr}
 8000aa2:	b082      	sub	sp, #8
 8000aa4:	af00      	add	r7, sp, #0
 8000aa6:	6078      	str	r0, [r7, #4]

  osalSysLock();
 8000aa8:	f7ff ff3a 	bl	8000920 <osalSysLock>
  gptStopTimerI(gptp);
 8000aac:	6878      	ldr	r0, [r7, #4]
 8000aae:	f000 f807 	bl	8000ac0 <gptStopTimerI>
  osalSysUnlock();
 8000ab2:	f7ff ff3d 	bl	8000930 <osalSysUnlock>
}
 8000ab6:	bf00      	nop
 8000ab8:	3708      	adds	r7, #8
 8000aba:	46bd      	mov	sp, r7
 8000abc:	bd80      	pop	{r7, pc}
 8000abe:	bf00      	nop

08000ac0 <gptStopTimerI>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @api
 */
void gptStopTimerI(GPTDriver *gptp) {
 8000ac0:	b580      	push	{r7, lr}
 8000ac2:	b082      	sub	sp, #8
 8000ac4:	af00      	add	r7, sp, #0
 8000ac6:	6078      	str	r0, [r7, #4]

  osalDbgCheckClassI();
 8000ac8:	f001 ffa2 	bl	8002a10 <chDbgCheckClassI>
  osalDbgCheck(gptp != NULL);
 8000acc:	687b      	ldr	r3, [r7, #4]
 8000ace:	2b00      	cmp	r3, #0
 8000ad0:	bf0c      	ite	eq
 8000ad2:	2301      	moveq	r3, #1
 8000ad4:	2300      	movne	r3, #0
 8000ad6:	b2db      	uxtb	r3, r3
 8000ad8:	2b00      	cmp	r3, #0
 8000ada:	d002      	beq.n	8000ae2 <gptStopTimerI+0x22>
 8000adc:	4817      	ldr	r0, [pc, #92]	; (8000b3c <gptStopTimerI+0x7c>)
 8000ade:	f001 fe27 	bl	8002730 <chSysHalt>
  osalDbgAssert((gptp->state == GPT_READY) || (gptp->state == GPT_CONTINUOUS) ||
 8000ae2:	687b      	ldr	r3, [r7, #4]
 8000ae4:	781b      	ldrb	r3, [r3, #0]
 8000ae6:	2b02      	cmp	r3, #2
 8000ae8:	bf14      	ite	ne
 8000aea:	2301      	movne	r3, #1
 8000aec:	2300      	moveq	r3, #0
 8000aee:	b2db      	uxtb	r3, r3
 8000af0:	2b00      	cmp	r3, #0
 8000af2:	d00a      	beq.n	8000b0a <gptStopTimerI+0x4a>
 8000af4:	687b      	ldr	r3, [r7, #4]
 8000af6:	781b      	ldrb	r3, [r3, #0]
 8000af8:	2b03      	cmp	r3, #3
 8000afa:	bf14      	ite	ne
 8000afc:	2301      	movne	r3, #1
 8000afe:	2300      	moveq	r3, #0
 8000b00:	b2db      	uxtb	r3, r3
 8000b02:	2b00      	cmp	r3, #0
 8000b04:	d001      	beq.n	8000b0a <gptStopTimerI+0x4a>
 8000b06:	2301      	movs	r3, #1
 8000b08:	e000      	b.n	8000b0c <gptStopTimerI+0x4c>
 8000b0a:	2300      	movs	r3, #0
 8000b0c:	2b00      	cmp	r3, #0
 8000b0e:	d00b      	beq.n	8000b28 <gptStopTimerI+0x68>
 8000b10:	687b      	ldr	r3, [r7, #4]
 8000b12:	781b      	ldrb	r3, [r3, #0]
 8000b14:	2b04      	cmp	r3, #4
 8000b16:	bf14      	ite	ne
 8000b18:	2301      	movne	r3, #1
 8000b1a:	2300      	moveq	r3, #0
 8000b1c:	b2db      	uxtb	r3, r3
 8000b1e:	2b00      	cmp	r3, #0
 8000b20:	d002      	beq.n	8000b28 <gptStopTimerI+0x68>
 8000b22:	4806      	ldr	r0, [pc, #24]	; (8000b3c <gptStopTimerI+0x7c>)
 8000b24:	f001 fe04 	bl	8002730 <chSysHalt>
                (gptp->state == GPT_ONESHOT),
                "invalid state");

  gptp->state = GPT_READY;
 8000b28:	687b      	ldr	r3, [r7, #4]
 8000b2a:	2202      	movs	r2, #2
 8000b2c:	701a      	strb	r2, [r3, #0]
  gpt_lld_stop_timer(gptp);
 8000b2e:	6878      	ldr	r0, [r7, #4]
 8000b30:	f001 fc5e 	bl	80023f0 <gpt_lld_stop_timer>
}
 8000b34:	bf00      	nop
 8000b36:	3708      	adds	r7, #8
 8000b38:	46bd      	mov	sp, r7
 8000b3a:	bd80      	pop	{r7, pc}
 8000b3c:	08004c24 	.word	0x08004c24

08000b40 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000b40:	b480      	push	{r7}
 8000b42:	b083      	sub	sp, #12
 8000b44:	af00      	add	r7, sp, #0
 8000b46:	6078      	str	r0, [r7, #4]
 8000b48:	6039      	str	r1, [r7, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000b4a:	683b      	ldr	r3, [r7, #0]
 8000b4c:	b2db      	uxtb	r3, r3
 8000b4e:	4a12      	ldr	r2, [pc, #72]	; (8000b98 <nvicEnableVector+0x58>)
 8000b50:	011b      	lsls	r3, r3, #4
 8000b52:	b2d9      	uxtb	r1, r3
 8000b54:	687b      	ldr	r3, [r7, #4]
 8000b56:	4413      	add	r3, r2
 8000b58:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8000b5c:	460a      	mov	r2, r1
 8000b5e:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000b60:	687b      	ldr	r3, [r7, #4]
 8000b62:	f003 021f 	and.w	r2, r3, #31
 8000b66:	490c      	ldr	r1, [pc, #48]	; (8000b98 <nvicEnableVector+0x58>)
 8000b68:	687b      	ldr	r3, [r7, #4]
 8000b6a:	095b      	lsrs	r3, r3, #5
 8000b6c:	2001      	movs	r0, #1
 8000b6e:	fa00 f202 	lsl.w	r2, r0, r2
 8000b72:	3360      	adds	r3, #96	; 0x60
 8000b74:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000b78:	687b      	ldr	r3, [r7, #4]
 8000b7a:	f003 021f 	and.w	r2, r3, #31
 8000b7e:	4906      	ldr	r1, [pc, #24]	; (8000b98 <nvicEnableVector+0x58>)
 8000b80:	687b      	ldr	r3, [r7, #4]
 8000b82:	095b      	lsrs	r3, r3, #5
 8000b84:	2001      	movs	r0, #1
 8000b86:	fa00 f202 	lsl.w	r2, r0, r2
 8000b8a:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000b8e:	bf00      	nop
 8000b90:	370c      	adds	r7, #12
 8000b92:	46bd      	mov	sp, r7
 8000b94:	bc80      	pop	{r7}
 8000b96:	4770      	bx	lr
 8000b98:	e000e100 	.word	0xe000e100
 8000b9c:	00000000 	.word	0x00000000

08000ba0 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8000ba0:	b480      	push	{r7}
 8000ba2:	b083      	sub	sp, #12
 8000ba4:	af00      	add	r7, sp, #0
 8000ba6:	6078      	str	r0, [r7, #4]

  NVIC->__ICER[n >> 5U] = 1U << (n & 0x1FU);
 8000ba8:	687b      	ldr	r3, [r7, #4]
 8000baa:	f003 021f 	and.w	r2, r3, #31
 8000bae:	4910      	ldr	r1, [pc, #64]	; (8000bf0 <nvicDisableVector+0x50>)
 8000bb0:	687b      	ldr	r3, [r7, #4]
 8000bb2:	095b      	lsrs	r3, r3, #5
 8000bb4:	2001      	movs	r0, #1
 8000bb6:	fa00 f202 	lsl.w	r2, r0, r2
 8000bba:	3320      	adds	r3, #32
 8000bbc:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bc0:	687b      	ldr	r3, [r7, #4]
 8000bc2:	f003 021f 	and.w	r2, r3, #31
 8000bc6:	490a      	ldr	r1, [pc, #40]	; (8000bf0 <nvicDisableVector+0x50>)
 8000bc8:	687b      	ldr	r3, [r7, #4]
 8000bca:	095b      	lsrs	r3, r3, #5
 8000bcc:	2001      	movs	r0, #1
 8000bce:	fa00 f202 	lsl.w	r2, r0, r2
 8000bd2:	3360      	adds	r3, #96	; 0x60
 8000bd4:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = 0U;
 8000bd8:	4a05      	ldr	r2, [pc, #20]	; (8000bf0 <nvicDisableVector+0x50>)
 8000bda:	687b      	ldr	r3, [r7, #4]
 8000bdc:	4413      	add	r3, r2
 8000bde:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8000be2:	2200      	movs	r2, #0
 8000be4:	701a      	strb	r2, [r3, #0]
#endif
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* Marked as not secure again.*/
  NVIC->__ITNS[n >> 5U] |= 1U << (n & 0x1FU);
#endif
}
 8000be6:	bf00      	nop
 8000be8:	370c      	adds	r7, #12
 8000bea:	46bd      	mov	sp, r7
 8000bec:	bc80      	pop	{r7}
 8000bee:	4770      	bx	lr
 8000bf0:	e000e100 	.word	0xe000e100
	...

08000c00 <exti0_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti0_irq_init(void) {
 8000c00:	b480      	push	{r7}
 8000c02:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000c04:	bf00      	nop
 8000c06:	46bd      	mov	sp, r7
 8000c08:	bc80      	pop	{r7}
 8000c0a:	4770      	bx	lr
 8000c0c:	0000      	movs	r0, r0
	...

08000c10 <exti1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti1_irq_init(void) {
 8000c10:	b480      	push	{r7}
 8000c12:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000c14:	bf00      	nop
 8000c16:	46bd      	mov	sp, r7
 8000c18:	bc80      	pop	{r7}
 8000c1a:	4770      	bx	lr
 8000c1c:	0000      	movs	r0, r0
	...

08000c20 <exti2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti2_irq_init(void) {
 8000c20:	b480      	push	{r7}
 8000c22:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000c24:	bf00      	nop
 8000c26:	46bd      	mov	sp, r7
 8000c28:	bc80      	pop	{r7}
 8000c2a:	4770      	bx	lr
 8000c2c:	0000      	movs	r0, r0
	...

08000c30 <exti3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti3_irq_init(void) {
 8000c30:	b480      	push	{r7}
 8000c32:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000c34:	bf00      	nop
 8000c36:	46bd      	mov	sp, r7
 8000c38:	bc80      	pop	{r7}
 8000c3a:	4770      	bx	lr
 8000c3c:	0000      	movs	r0, r0
	...

08000c40 <exti4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti4_irq_init(void) {
 8000c40:	b480      	push	{r7}
 8000c42:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000c44:	bf00      	nop
 8000c46:	46bd      	mov	sp, r7
 8000c48:	bc80      	pop	{r7}
 8000c4a:	4770      	bx	lr
 8000c4c:	0000      	movs	r0, r0
	...

08000c50 <exti5_9_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti5_9_irq_init(void) {
 8000c50:	b480      	push	{r7}
 8000c52:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000c54:	bf00      	nop
 8000c56:	46bd      	mov	sp, r7
 8000c58:	bc80      	pop	{r7}
 8000c5a:	4770      	bx	lr
 8000c5c:	0000      	movs	r0, r0
	...

08000c60 <exti10_15_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti10_15_irq_init(void) {
 8000c60:	b480      	push	{r7}
 8000c62:	af00      	add	r7, sp, #0
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000c64:	bf00      	nop
 8000c66:	46bd      	mov	sp, r7
 8000c68:	bc80      	pop	{r7}
 8000c6a:	4770      	bx	lr
 8000c6c:	0000      	movs	r0, r0
	...

08000c70 <exti16_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti16_irq_init(void) {
 8000c70:	b480      	push	{r7}
 8000c72:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI16_IS_USED)
  nvicEnableVector(STM32_EXTI16_NUMBER, STM32_IRQ_EXTI16_PRIORITY);
#endif
}
 8000c74:	bf00      	nop
 8000c76:	46bd      	mov	sp, r7
 8000c78:	bc80      	pop	{r7}
 8000c7a:	4770      	bx	lr
 8000c7c:	0000      	movs	r0, r0
	...

08000c80 <exti17_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti17_irq_init(void) {
 8000c80:	b480      	push	{r7}
 8000c82:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8000c84:	bf00      	nop
 8000c86:	46bd      	mov	sp, r7
 8000c88:	bc80      	pop	{r7}
 8000c8a:	4770      	bx	lr
 8000c8c:	0000      	movs	r0, r0
	...

08000c90 <exti18_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti18_irq_init(void) {
 8000c90:	b480      	push	{r7}
 8000c92:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000c94:	bf00      	nop
 8000c96:	46bd      	mov	sp, r7
 8000c98:	bc80      	pop	{r7}
 8000c9a:	4770      	bx	lr
 8000c9c:	0000      	movs	r0, r0
	...

08000ca0 <exti19_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti19_irq_init(void) {
 8000ca0:	b480      	push	{r7}
 8000ca2:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000ca4:	bf00      	nop
 8000ca6:	46bd      	mov	sp, r7
 8000ca8:	bc80      	pop	{r7}
 8000caa:	4770      	bx	lr
 8000cac:	0000      	movs	r0, r0
	...

08000cb0 <exti20_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti20_irq_init(void) {
 8000cb0:	b480      	push	{r7}
 8000cb2:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI20_IS_USED)
  nvicEnableVector(STM32_EXTI20_NUMBER, STM32_IRQ_EXTI20_PRIORITY);
#endif
}
 8000cb4:	bf00      	nop
 8000cb6:	46bd      	mov	sp, r7
 8000cb8:	bc80      	pop	{r7}
 8000cba:	4770      	bx	lr
 8000cbc:	0000      	movs	r0, r0
	...

08000cc0 <exti21_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti21_irq_init(void) {
 8000cc0:	b480      	push	{r7}
 8000cc2:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI21_NUMBER, STM32_IRQ_EXTI21_PRIORITY);
#endif
}
 8000cc4:	bf00      	nop
 8000cc6:	46bd      	mov	sp, r7
 8000cc8:	bc80      	pop	{r7}
 8000cca:	4770      	bx	lr
 8000ccc:	0000      	movs	r0, r0
	...

08000cd0 <exti22_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void exti22_irq_init(void) {
 8000cd0:	b480      	push	{r7}
 8000cd2:	af00      	add	r7, sp, #0
#if defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI22_NUMBER, STM32_IRQ_EXTI22_PRIORITY);
#endif
}
 8000cd4:	bf00      	nop
 8000cd6:	46bd      	mov	sp, r7
 8000cd8:	bc80      	pop	{r7}
 8000cda:	4770      	bx	lr
 8000cdc:	0000      	movs	r0, r0
	...

08000ce0 <usart1_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart1_irq_init(void) {
 8000ce0:	b480      	push	{r7}
 8000ce2:	af00      	add	r7, sp, #0
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000ce4:	bf00      	nop
 8000ce6:	46bd      	mov	sp, r7
 8000ce8:	bc80      	pop	{r7}
 8000cea:	4770      	bx	lr
 8000cec:	0000      	movs	r0, r0
	...

08000cf0 <usart2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart2_irq_init(void) {
 8000cf0:	b480      	push	{r7}
 8000cf2:	af00      	add	r7, sp, #0
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000cf4:	bf00      	nop
 8000cf6:	46bd      	mov	sp, r7
 8000cf8:	bc80      	pop	{r7}
 8000cfa:	4770      	bx	lr
 8000cfc:	0000      	movs	r0, r0
	...

08000d00 <usart3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart3_irq_init(void) {
 8000d00:	b480      	push	{r7}
 8000d02:	af00      	add	r7, sp, #0
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000d04:	bf00      	nop
 8000d06:	46bd      	mov	sp, r7
 8000d08:	bc80      	pop	{r7}
 8000d0a:	4770      	bx	lr
 8000d0c:	0000      	movs	r0, r0
	...

08000d10 <uart4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart4_irq_init(void) {
 8000d10:	b480      	push	{r7}
 8000d12:	af00      	add	r7, sp, #0
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000d14:	bf00      	nop
 8000d16:	46bd      	mov	sp, r7
 8000d18:	bc80      	pop	{r7}
 8000d1a:	4770      	bx	lr
 8000d1c:	0000      	movs	r0, r0
	...

08000d20 <uart5_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart5_irq_init(void) {
 8000d20:	b480      	push	{r7}
 8000d22:	af00      	add	r7, sp, #0
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000d24:	bf00      	nop
 8000d26:	46bd      	mov	sp, r7
 8000d28:	bc80      	pop	{r7}
 8000d2a:	4770      	bx	lr
 8000d2c:	0000      	movs	r0, r0
	...

08000d30 <usart6_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void usart6_irq_init(void) {
 8000d30:	b480      	push	{r7}
 8000d32:	af00      	add	r7, sp, #0
#if defined(STM32_USART6_IS_USED)
  nvicEnableVector(STM32_USART6_NUMBER, STM32_IRQ_USART6_PRIORITY);
#endif
}
 8000d34:	bf00      	nop
 8000d36:	46bd      	mov	sp, r7
 8000d38:	bc80      	pop	{r7}
 8000d3a:	4770      	bx	lr
 8000d3c:	0000      	movs	r0, r0
	...

08000d40 <uart7_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart7_irq_init(void) {
 8000d40:	b480      	push	{r7}
 8000d42:	af00      	add	r7, sp, #0
#if defined(STM32_UART7_IS_USED)
  nvicEnableVector(STM32_UART7_NUMBER, STM32_IRQ_UART7_PRIORITY);
#endif
}
 8000d44:	bf00      	nop
 8000d46:	46bd      	mov	sp, r7
 8000d48:	bc80      	pop	{r7}
 8000d4a:	4770      	bx	lr
 8000d4c:	0000      	movs	r0, r0
	...

08000d50 <uart8_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart8_irq_init(void) {
 8000d50:	b480      	push	{r7}
 8000d52:	af00      	add	r7, sp, #0
#if defined(STM32_UART8_IS_USED)
  nvicEnableVector(STM32_UART8_NUMBER, STM32_IRQ_UART8_PRIORITY);
#endif
}
 8000d54:	bf00      	nop
 8000d56:	46bd      	mov	sp, r7
 8000d58:	bc80      	pop	{r7}
 8000d5a:	4770      	bx	lr
 8000d5c:	0000      	movs	r0, r0
	...

08000d60 <uart9_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart9_irq_init(void) {
 8000d60:	b480      	push	{r7}
 8000d62:	af00      	add	r7, sp, #0
#if defined(STM32_UART9_IS_USED)
  nvicEnableVector(STM32_UART9_NUMBER, STM32_IRQ_UART9_PRIORITY);
#endif
}
 8000d64:	bf00      	nop
 8000d66:	46bd      	mov	sp, r7
 8000d68:	bc80      	pop	{r7}
 8000d6a:	4770      	bx	lr
 8000d6c:	0000      	movs	r0, r0
	...

08000d70 <uart10_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void uart10_irq_init(void) {
 8000d70:	b480      	push	{r7}
 8000d72:	af00      	add	r7, sp, #0
#if defined(STM32_UART10_IS_USED)
  nvicEnableVector(STM32_UART10_NUMBER, STM32_IRQ_UART10_PRIORITY);
#endif
}
 8000d74:	bf00      	nop
 8000d76:	46bd      	mov	sp, r7
 8000d78:	bc80      	pop	{r7}
 8000d7a:	4770      	bx	lr
 8000d7c:	0000      	movs	r0, r0
	...

08000d80 <tim1_tim9_tim10_tim11_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim1_tim9_tim10_tim11_irq_init(void) {
 8000d80:	b480      	push	{r7}
 8000d82:	af00      	add	r7, sp, #0
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000d84:	bf00      	nop
 8000d86:	46bd      	mov	sp, r7
 8000d88:	bc80      	pop	{r7}
 8000d8a:	4770      	bx	lr
 8000d8c:	0000      	movs	r0, r0
	...

08000d90 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000d90:	b580      	push	{r7, lr}
 8000d92:	af00      	add	r7, sp, #0
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000d94:	2107      	movs	r1, #7
 8000d96:	201c      	movs	r0, #28
 8000d98:	f7ff fed2 	bl	8000b40 <nvicEnableVector>
#endif
}
 8000d9c:	bf00      	nop
 8000d9e:	bd80      	pop	{r7, pc}

08000da0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000da0:	b580      	push	{r7, lr}
 8000da2:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8000da4:	4807      	ldr	r0, [pc, #28]	; (8000dc4 <VectorB0+0x24>)
 8000da6:	f001 ff6b 	bl	8002c80 <__trace_isr_enter>
 8000daa:	f001 fdb9 	bl	8002920 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000dae:	f001 fa47 	bl	8002240 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000db2:	f001 fded 	bl	8002990 <__dbg_check_leave_isr>
 8000db6:	4803      	ldr	r0, [pc, #12]	; (8000dc4 <VectorB0+0x24>)
 8000db8:	f001 ffa2 	bl	8002d00 <__trace_isr_leave>
 8000dbc:	f003 fd98 	bl	80048f0 <__port_irq_epilogue>
}
 8000dc0:	bf00      	nop
 8000dc2:	bd80      	pop	{r7, pc}
 8000dc4:	08004c34 	.word	0x08004c34
	...

08000dd0 <tim3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim3_irq_init(void) {
 8000dd0:	b480      	push	{r7}
 8000dd2:	af00      	add	r7, sp, #0
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
#endif
}
 8000dd4:	bf00      	nop
 8000dd6:	46bd      	mov	sp, r7
 8000dd8:	bc80      	pop	{r7}
 8000dda:	4770      	bx	lr
 8000ddc:	0000      	movs	r0, r0
	...

08000de0 <tim4_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim4_irq_init(void) {
 8000de0:	b480      	push	{r7}
 8000de2:	af00      	add	r7, sp, #0
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
#endif
}
 8000de4:	bf00      	nop
 8000de6:	46bd      	mov	sp, r7
 8000de8:	bc80      	pop	{r7}
 8000dea:	4770      	bx	lr
 8000dec:	0000      	movs	r0, r0
	...

08000df0 <tim5_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim5_irq_init(void) {
 8000df0:	b480      	push	{r7}
 8000df2:	af00      	add	r7, sp, #0
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8000df4:	bf00      	nop
 8000df6:	46bd      	mov	sp, r7
 8000df8:	bc80      	pop	{r7}
 8000dfa:	4770      	bx	lr
 8000dfc:	0000      	movs	r0, r0
	...

08000e00 <tim6_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim6_irq_init(void) {
 8000e00:	b580      	push	{r7, lr}
 8000e02:	af00      	add	r7, sp, #0
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
 8000e04:	2107      	movs	r1, #7
 8000e06:	2036      	movs	r0, #54	; 0x36
 8000e08:	f7ff fe9a 	bl	8000b40 <nvicEnableVector>
#endif
}
 8000e0c:	bf00      	nop
 8000e0e:	bd80      	pop	{r7, pc}

08000e10 <Vector118>:
/**
 * @brief   TIM6 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM6_HANDLER) {
 8000e10:	b580      	push	{r7, lr}
 8000e12:	af00      	add	r7, sp, #0

  OSAL_IRQ_PROLOGUE();
 8000e14:	4808      	ldr	r0, [pc, #32]	; (8000e38 <Vector118+0x28>)
 8000e16:	f001 ff33 	bl	8002c80 <__trace_isr_enter>
 8000e1a:	f001 fd81 	bl	8002920 <__dbg_check_enter_isr>

#if HAL_USE_GPT
#if STM32_GPT_USE_TIM6
  gpt_lld_serve_interrupt(&GPTD6);
 8000e1e:	4807      	ldr	r0, [pc, #28]	; (8000e3c <Vector118+0x2c>)
 8000e20:	f001 fb06 	bl	8002430 <gpt_lld_serve_interrupt>
#if STM32_ST_USE_TIM6
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000e24:	f001 fdb4 	bl	8002990 <__dbg_check_leave_isr>
 8000e28:	4803      	ldr	r0, [pc, #12]	; (8000e38 <Vector118+0x28>)
 8000e2a:	f001 ff69 	bl	8002d00 <__trace_isr_leave>
 8000e2e:	f003 fd5f 	bl	80048f0 <__port_irq_epilogue>
}
 8000e32:	bf00      	nop
 8000e34:	bd80      	pop	{r7, pc}
 8000e36:	bf00      	nop
 8000e38:	08004c40 	.word	0x08004c40
 8000e3c:	200008e4 	.word	0x200008e4

08000e40 <tim7_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim7_irq_init(void) {
 8000e40:	b480      	push	{r7}
 8000e42:	af00      	add	r7, sp, #0
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8000e44:	bf00      	nop
 8000e46:	46bd      	mov	sp, r7
 8000e48:	bc80      	pop	{r7}
 8000e4a:	4770      	bx	lr
 8000e4c:	0000      	movs	r0, r0
	...

08000e50 <tim8_tim12_tim13_tim14_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim8_tim12_tim13_tim14_irq_init(void) {
 8000e50:	b480      	push	{r7}
 8000e52:	af00      	add	r7, sp, #0
#endif
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
                   STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8000e54:	bf00      	nop
 8000e56:	46bd      	mov	sp, r7
 8000e58:	bc80      	pop	{r7}
 8000e5a:	4770      	bx	lr
 8000e5c:	0000      	movs	r0, r0
	...

08000e60 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8000e60:	b580      	push	{r7, lr}
 8000e62:	af00      	add	r7, sp, #0

  exti0_irq_init();
 8000e64:	f7ff fecc 	bl	8000c00 <exti0_irq_init>
  exti1_irq_init();
 8000e68:	f7ff fed2 	bl	8000c10 <exti1_irq_init>
  exti2_irq_init();
 8000e6c:	f7ff fed8 	bl	8000c20 <exti2_irq_init>
  exti3_irq_init();
 8000e70:	f7ff fede 	bl	8000c30 <exti3_irq_init>
  exti4_irq_init();
 8000e74:	f7ff fee4 	bl	8000c40 <exti4_irq_init>
  exti5_9_irq_init();
 8000e78:	f7ff feea 	bl	8000c50 <exti5_9_irq_init>
  exti10_15_irq_init();
 8000e7c:	f7ff fef0 	bl	8000c60 <exti10_15_irq_init>
  exti16_irq_init();
 8000e80:	f7ff fef6 	bl	8000c70 <exti16_irq_init>
  exti17_irq_init();
 8000e84:	f7ff fefc 	bl	8000c80 <exti17_irq_init>
  exti18_irq_init();
 8000e88:	f7ff ff02 	bl	8000c90 <exti18_irq_init>
  exti19_irq_init();
 8000e8c:	f7ff ff08 	bl	8000ca0 <exti19_irq_init>
  exti20_irq_init();
 8000e90:	f7ff ff0e 	bl	8000cb0 <exti20_irq_init>
  exti21_irq_init();
 8000e94:	f7ff ff14 	bl	8000cc0 <exti21_irq_init>
  exti22_irq_init();
 8000e98:	f7ff ff1a 	bl	8000cd0 <exti22_irq_init>

  tim1_tim9_tim10_tim11_irq_init();
 8000e9c:	f7ff ff70 	bl	8000d80 <tim1_tim9_tim10_tim11_irq_init>
  tim2_irq_init();
 8000ea0:	f7ff ff76 	bl	8000d90 <tim2_irq_init>
  tim3_irq_init();
 8000ea4:	f7ff ff94 	bl	8000dd0 <tim3_irq_init>
  tim4_irq_init();
 8000ea8:	f7ff ff9a 	bl	8000de0 <tim4_irq_init>
  tim5_irq_init();
 8000eac:	f7ff ffa0 	bl	8000df0 <tim5_irq_init>
  tim6_irq_init();
 8000eb0:	f7ff ffa6 	bl	8000e00 <tim6_irq_init>
  tim7_irq_init();
 8000eb4:	f7ff ffc4 	bl	8000e40 <tim7_irq_init>
  tim8_tim12_tim13_tim14_irq_init();
 8000eb8:	f7ff ffca 	bl	8000e50 <tim8_tim12_tim13_tim14_irq_init>

  usart1_irq_init();
 8000ebc:	f7ff ff10 	bl	8000ce0 <usart1_irq_init>
  usart2_irq_init();
 8000ec0:	f7ff ff16 	bl	8000cf0 <usart2_irq_init>
  usart3_irq_init();
 8000ec4:	f7ff ff1c 	bl	8000d00 <usart3_irq_init>
  uart4_irq_init();
 8000ec8:	f7ff ff22 	bl	8000d10 <uart4_irq_init>
  uart5_irq_init();
 8000ecc:	f7ff ff28 	bl	8000d20 <uart5_irq_init>
  usart6_irq_init();
 8000ed0:	f7ff ff2e 	bl	8000d30 <usart6_irq_init>
  uart7_irq_init();
 8000ed4:	f7ff ff34 	bl	8000d40 <uart7_irq_init>
  uart8_irq_init();
 8000ed8:	f7ff ff3a 	bl	8000d50 <uart8_irq_init>
  uart9_irq_init();
 8000edc:	f7ff ff40 	bl	8000d60 <uart9_irq_init>
  uart10_irq_init();
 8000ee0:	f7ff ff46 	bl	8000d70 <uart10_irq_init>
}
 8000ee4:	bf00      	nop
 8000ee6:	bd80      	pop	{r7, pc}
	...

08000ef0 <hal_lld_backup_domain_init>:
/**
 * @brief   Initializes the backup domain.
 * @note    WARNING! Changing clock source impossible without resetting
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {
 8000ef0:	b480      	push	{r7}
 8000ef2:	af00      	add	r7, sp, #0

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000ef4:	4b0e      	ldr	r3, [pc, #56]	; (8000f30 <hal_lld_backup_domain_init+0x40>)
 8000ef6:	681b      	ldr	r3, [r3, #0]
 8000ef8:	4a0d      	ldr	r2, [pc, #52]	; (8000f30 <hal_lld_backup_domain_init+0x40>)
 8000efa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8000efe:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8000f00:	4b0c      	ldr	r3, [pc, #48]	; (8000f34 <hal_lld_backup_domain_init+0x44>)
 8000f02:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8000f04:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8000f08:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8000f0c:	d006      	beq.n	8000f1c <hal_lld_backup_domain_init+0x2c>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000f0e:	4b09      	ldr	r3, [pc, #36]	; (8000f34 <hal_lld_backup_domain_init+0x44>)
 8000f10:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8000f14:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8000f16:	4b07      	ldr	r3, [pc, #28]	; (8000f34 <hal_lld_backup_domain_init+0x44>)
 8000f18:	2200      	movs	r2, #0
 8000f1a:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8000f1c:	4b04      	ldr	r3, [pc, #16]	; (8000f30 <hal_lld_backup_domain_init+0x40>)
 8000f1e:	685b      	ldr	r3, [r3, #4]
 8000f20:	4a03      	ldr	r2, [pc, #12]	; (8000f30 <hal_lld_backup_domain_init+0x40>)
 8000f22:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8000f26:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8000f28:	bf00      	nop
 8000f2a:	46bd      	mov	sp, r7
 8000f2c:	bc80      	pop	{r7}
 8000f2e:	4770      	bx	lr
 8000f30:	40007000 	.word	0x40007000
 8000f34:	40023800 	.word	0x40023800
	...

08000f40 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8000f40:	b580      	push	{r7, lr}
 8000f42:	af00      	add	r7, sp, #0

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8000f44:	4b26      	ldr	r3, [pc, #152]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f46:	691b      	ldr	r3, [r3, #16]
 8000f48:	4a25      	ldr	r2, [pc, #148]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f4a:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 8000f4e:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 8000f52:	6113      	str	r3, [r2, #16]
 8000f54:	4b22      	ldr	r3, [pc, #136]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f56:	691b      	ldr	r3, [r3, #16]
 8000f58:	4a21      	ldr	r2, [pc, #132]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f5a:	f3c3 0308 	ubfx	r3, r3, #0, #9
 8000f5e:	6113      	str	r3, [r2, #16]
 8000f60:	4b1f      	ldr	r3, [pc, #124]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f62:	691b      	ldr	r3, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8000f64:	4b1e      	ldr	r3, [pc, #120]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f66:	695b      	ldr	r3, [r3, #20]
 8000f68:	4b1d      	ldr	r3, [pc, #116]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f6a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000f6e:	615a      	str	r2, [r3, #20]
 8000f70:	4b1b      	ldr	r3, [pc, #108]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f72:	695b      	ldr	r3, [r3, #20]
 8000f74:	4b1a      	ldr	r3, [pc, #104]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f76:	2200      	movs	r2, #0
 8000f78:	615a      	str	r2, [r3, #20]
 8000f7a:	4b19      	ldr	r3, [pc, #100]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f7c:	695b      	ldr	r3, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 8000f7e:	4b18      	ldr	r3, [pc, #96]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f80:	6a1b      	ldr	r3, [r3, #32]
 8000f82:	4a17      	ldr	r2, [pc, #92]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f84:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 8000f88:	6213      	str	r3, [r2, #32]
 8000f8a:	4b15      	ldr	r3, [pc, #84]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f8c:	6a1b      	ldr	r3, [r3, #32]
 8000f8e:	4a14      	ldr	r2, [pc, #80]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f90:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000f94:	6213      	str	r3, [r2, #32]
 8000f96:	4b12      	ldr	r3, [pc, #72]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f98:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
 8000f9a:	4b11      	ldr	r3, [pc, #68]	; (8000fe0 <hal_lld_init+0xa0>)
 8000f9c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000f9e:	4b10      	ldr	r3, [pc, #64]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fa0:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000fa4:	625a      	str	r2, [r3, #36]	; 0x24
 8000fa6:	4b0e      	ldr	r3, [pc, #56]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fa8:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000faa:	4b0d      	ldr	r3, [pc, #52]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fac:	2200      	movs	r2, #0
 8000fae:	625a      	str	r2, [r3, #36]	; 0x24
 8000fb0:	4b0b      	ldr	r3, [pc, #44]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fb2:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 8000fb4:	4b0a      	ldr	r3, [pc, #40]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fb6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8000fb8:	4a09      	ldr	r2, [pc, #36]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fba:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000fbe:	6413      	str	r3, [r2, #64]	; 0x40
 8000fc0:	4b07      	ldr	r3, [pc, #28]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fc2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8000fc4:	4a06      	ldr	r2, [pc, #24]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fc6:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8000fca:	6613      	str	r3, [r2, #96]	; 0x60
 8000fcc:	4b04      	ldr	r3, [pc, #16]	; (8000fe0 <hal_lld_init+0xa0>)
 8000fce:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 8000fd0:	f7ff ff8e 	bl	8000ef0 <hal_lld_backup_domain_init>

  /* DMA subsystems initialization.*/
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 8000fd4:	f000 fe94 	bl	8001d00 <dmaInit>
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 8000fd8:	f7ff ff42 	bl	8000e60 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 8000fdc:	bf00      	nop
 8000fde:	bd80      	pop	{r7, pc}
 8000fe0:	40023800 	.word	0x40023800
	...

08000ff0 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8000ff0:	b480      	push	{r7}
 8000ff2:	af00      	add	r7, sp, #0
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8000ff4:	4b54      	ldr	r3, [pc, #336]	; (8001148 <stm32_clock_init+0x158>)
 8000ff6:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8000ffa:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8000ffc:	4b53      	ldr	r3, [pc, #332]	; (800114c <stm32_clock_init+0x15c>)
 8000ffe:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 8001002:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001004:	4b50      	ldr	r3, [pc, #320]	; (8001148 <stm32_clock_init+0x158>)
 8001006:	681b      	ldr	r3, [r3, #0]
 8001008:	4a4f      	ldr	r2, [pc, #316]	; (8001148 <stm32_clock_init+0x158>)
 800100a:	f043 0301 	orr.w	r3, r3, #1
 800100e:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001010:	bf00      	nop
 8001012:	4b4d      	ldr	r3, [pc, #308]	; (8001148 <stm32_clock_init+0x158>)
 8001014:	681b      	ldr	r3, [r3, #0]
 8001016:	f003 0302 	and.w	r3, r3, #2
 800101a:	2b00      	cmp	r3, #0
 800101c:	d0f9      	beq.n	8001012 <stm32_clock_init+0x22>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800101e:	4b4a      	ldr	r3, [pc, #296]	; (8001148 <stm32_clock_init+0x158>)
 8001020:	689b      	ldr	r3, [r3, #8]
 8001022:	4a49      	ldr	r2, [pc, #292]	; (8001148 <stm32_clock_init+0x158>)
 8001024:	f023 0303 	bic.w	r3, r3, #3
 8001028:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800102a:	bf00      	nop
 800102c:	4b46      	ldr	r3, [pc, #280]	; (8001148 <stm32_clock_init+0x158>)
 800102e:	689b      	ldr	r3, [r3, #8]
 8001030:	f003 030c 	and.w	r3, r3, #12
 8001034:	2b00      	cmp	r3, #0
 8001036:	d1f9      	bne.n	800102c <stm32_clock_init+0x3c>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001038:	4b43      	ldr	r3, [pc, #268]	; (8001148 <stm32_clock_init+0x158>)
 800103a:	681b      	ldr	r3, [r3, #0]
 800103c:	4a42      	ldr	r2, [pc, #264]	; (8001148 <stm32_clock_init+0x158>)
 800103e:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 8001042:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001044:	4b40      	ldr	r3, [pc, #256]	; (8001148 <stm32_clock_init+0x158>)
 8001046:	2200      	movs	r2, #0
 8001048:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 800104a:	4b3f      	ldr	r3, [pc, #252]	; (8001148 <stm32_clock_init+0x158>)
 800104c:	681b      	ldr	r3, [r3, #0]
 800104e:	4a3e      	ldr	r2, [pc, #248]	; (8001148 <stm32_clock_init+0x158>)
 8001050:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001054:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001056:	bf00      	nop
 8001058:	4b3b      	ldr	r3, [pc, #236]	; (8001148 <stm32_clock_init+0x158>)
 800105a:	681b      	ldr	r3, [r3, #0]
 800105c:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8001060:	2b00      	cmp	r3, #0
 8001062:	d0f9      	beq.n	8001058 <stm32_clock_init+0x68>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001064:	4b38      	ldr	r3, [pc, #224]	; (8001148 <stm32_clock_init+0x158>)
 8001066:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001068:	4a37      	ldr	r2, [pc, #220]	; (8001148 <stm32_clock_init+0x158>)
 800106a:	f043 0301 	orr.w	r3, r3, #1
 800106e:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001070:	bf00      	nop
 8001072:	4b35      	ldr	r3, [pc, #212]	; (8001148 <stm32_clock_init+0x158>)
 8001074:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001076:	f003 0302 	and.w	r3, r3, #2
 800107a:	2b00      	cmp	r3, #0
 800107c:	d0f9      	beq.n	8001072 <stm32_clock_init+0x82>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800107e:	4b32      	ldr	r3, [pc, #200]	; (8001148 <stm32_clock_init+0x158>)
 8001080:	4a33      	ldr	r2, [pc, #204]	; (8001150 <stm32_clock_init+0x160>)
 8001082:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001084:	4b30      	ldr	r3, [pc, #192]	; (8001148 <stm32_clock_init+0x158>)
 8001086:	681b      	ldr	r3, [r3, #0]
 8001088:	4a2f      	ldr	r2, [pc, #188]	; (8001148 <stm32_clock_init+0x158>)
 800108a:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800108e:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 8001090:	bf00      	nop
 8001092:	4b2e      	ldr	r3, [pc, #184]	; (800114c <stm32_clock_init+0x15c>)
 8001094:	685b      	ldr	r3, [r3, #4]
 8001096:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 800109a:	2b00      	cmp	r3, #0
 800109c:	d0f9      	beq.n	8001092 <stm32_clock_init+0xa2>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800109e:	bf00      	nop
 80010a0:	4b29      	ldr	r3, [pc, #164]	; (8001148 <stm32_clock_init+0x158>)
 80010a2:	681b      	ldr	r3, [r3, #0]
 80010a4:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80010a8:	2b00      	cmp	r3, #0
 80010aa:	d0f9      	beq.n	80010a0 <stm32_clock_init+0xb0>
    ;
#endif /* STM32_ACTIVATE_PLL */

#if STM32_ACTIVATE_PLLI2S
  /* PLLI2S activation.*/
  RCC->PLLI2SCFGR = STM32_PLLI2SR | STM32_PLLI2SN | STM32_PLLI2SP |
 80010ac:	4b26      	ldr	r3, [pc, #152]	; (8001148 <stm32_clock_init+0x158>)
 80010ae:	4a29      	ldr	r2, [pc, #164]	; (8001154 <stm32_clock_init+0x164>)
 80010b0:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
                    STM32_PLLI2SSRC | STM32_PLLI2SQ | STM32_PLLI2SM;
  RCC->CR |= RCC_CR_PLLI2SON;
 80010b4:	4b24      	ldr	r3, [pc, #144]	; (8001148 <stm32_clock_init+0x158>)
 80010b6:	681b      	ldr	r3, [r3, #0]
 80010b8:	4a23      	ldr	r2, [pc, #140]	; (8001148 <stm32_clock_init+0x158>)
 80010ba:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 80010be:	6013      	str	r3, [r2, #0]

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLI2SRDY))
 80010c0:	bf00      	nop
 80010c2:	4b21      	ldr	r3, [pc, #132]	; (8001148 <stm32_clock_init+0x158>)
 80010c4:	681b      	ldr	r3, [r3, #0]
 80010c6:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 80010ca:	2b00      	cmp	r3, #0
 80010cc:	d0f9      	beq.n	80010c2 <stm32_clock_init+0xd2>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80010ce:	4b1e      	ldr	r3, [pc, #120]	; (8001148 <stm32_clock_init+0x158>)
 80010d0:	4a21      	ldr	r2, [pc, #132]	; (8001158 <stm32_clock_init+0x168>)
 80010d2:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80010d4:	4b21      	ldr	r3, [pc, #132]	; (800115c <stm32_clock_init+0x16c>)
 80010d6:	681b      	ldr	r3, [r3, #0]
 80010d8:	4a21      	ldr	r2, [pc, #132]	; (8001160 <stm32_clock_init+0x170>)
 80010da:	4293      	cmp	r3, r2
 80010dc:	d109      	bne.n	80010f2 <stm32_clock_init+0x102>
 80010de:	4b21      	ldr	r3, [pc, #132]	; (8001164 <stm32_clock_init+0x174>)
 80010e0:	681b      	ldr	r3, [r3, #0]
 80010e2:	4a21      	ldr	r2, [pc, #132]	; (8001168 <stm32_clock_init+0x178>)
 80010e4:	4293      	cmp	r3, r2
 80010e6:	d104      	bne.n	80010f2 <stm32_clock_init+0x102>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80010e8:	4b20      	ldr	r3, [pc, #128]	; (800116c <stm32_clock_init+0x17c>)
 80010ea:	f240 1205 	movw	r2, #261	; 0x105
 80010ee:	601a      	str	r2, [r3, #0]
 80010f0:	e003      	b.n	80010fa <stm32_clock_init+0x10a>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80010f2:	4b1e      	ldr	r3, [pc, #120]	; (800116c <stm32_clock_init+0x17c>)
 80010f4:	f240 7205 	movw	r2, #1797	; 0x705
 80010f8:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 80010fa:	bf00      	nop
 80010fc:	4b1b      	ldr	r3, [pc, #108]	; (800116c <stm32_clock_init+0x17c>)
 80010fe:	681b      	ldr	r3, [r3, #0]
 8001100:	f003 030f 	and.w	r3, r3, #15
 8001104:	2b05      	cmp	r3, #5
 8001106:	d1f9      	bne.n	80010fc <stm32_clock_init+0x10c>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 8001108:	4b0f      	ldr	r3, [pc, #60]	; (8001148 <stm32_clock_init+0x158>)
 800110a:	689b      	ldr	r3, [r3, #8]
 800110c:	4a0e      	ldr	r2, [pc, #56]	; (8001148 <stm32_clock_init+0x158>)
 800110e:	f043 0302 	orr.w	r3, r3, #2
 8001112:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001114:	bf00      	nop
 8001116:	4b0c      	ldr	r3, [pc, #48]	; (8001148 <stm32_clock_init+0x158>)
 8001118:	689b      	ldr	r3, [r3, #8]
 800111a:	f003 030c 	and.w	r3, r3, #12
 800111e:	2b08      	cmp	r3, #8
 8001120:	d1f9      	bne.n	8001116 <stm32_clock_init+0x126>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 8001122:	4b09      	ldr	r3, [pc, #36]	; (8001148 <stm32_clock_init+0x158>)
 8001124:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001126:	4a08      	ldr	r2, [pc, #32]	; (8001148 <stm32_clock_init+0x158>)
 8001128:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 800112c:	6453      	str	r3, [r2, #68]	; 0x44
 800112e:	4b06      	ldr	r3, [pc, #24]	; (8001148 <stm32_clock_init+0x158>)
 8001130:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001132:	4a05      	ldr	r2, [pc, #20]	; (8001148 <stm32_clock_init+0x158>)
 8001134:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001138:	6653      	str	r3, [r2, #100]	; 0x64
 800113a:	4b03      	ldr	r3, [pc, #12]	; (8001148 <stm32_clock_init+0x158>)
 800113c:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 800113e:	bf00      	nop
 8001140:	46bd      	mov	sp, r7
 8001142:	bc80      	pop	{r7}
 8001144:	4770      	bx	lr
 8001146:	bf00      	nop
 8001148:	40023800 	.word	0x40023800
 800114c:	40007000 	.word	0x40007000
 8001150:	07405410 	.word	0x07405410
 8001154:	54413004 	.word	0x54413004
 8001158:	38089400 	.word	0x38089400
 800115c:	e0042000 	.word	0xe0042000
 8001160:	20006411 	.word	0x20006411
 8001164:	e000ed00 	.word	0xe000ed00
 8001168:	410fc241 	.word	0x410fc241
 800116c:	40023c00 	.word	0x40023c00

08001170 <chSysLockFromISR>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8001170:	b580      	push	{r7, lr}
 8001172:	b082      	sub	sp, #8
 8001174:	af00      	add	r7, sp, #0
 8001176:	2330      	movs	r3, #48	; 0x30
 8001178:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800117a:	687b      	ldr	r3, [r7, #4]
 800117c:	f383 8811 	msr	BASEPRI, r3
}
 8001180:	bf00      	nop
}
 8001182:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 8001184:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 8001186:	f001 fb7b 	bl	8002880 <__dbg_check_lock_from_isr>
}
 800118a:	bf00      	nop
 800118c:	3708      	adds	r7, #8
 800118e:	46bd      	mov	sp, r7
 8001190:	bd80      	pop	{r7, pc}
 8001192:	bf00      	nop
	...

080011a0 <chSysUnlockFromISR>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80011a0:	b580      	push	{r7, lr}
 80011a2:	b082      	sub	sp, #8
 80011a4:	af00      	add	r7, sp, #0

  __dbg_check_unlock_from_isr();
 80011a6:	f001 fb93 	bl	80028d0 <__dbg_check_unlock_from_isr>
 80011aa:	2300      	movs	r3, #0
 80011ac:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80011ae:	687b      	ldr	r3, [r7, #4]
 80011b0:	f383 8811 	msr	BASEPRI, r3
}
 80011b4:	bf00      	nop
}
 80011b6:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 80011b8:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 80011ba:	bf00      	nop
 80011bc:	3708      	adds	r7, #8
 80011be:	46bd      	mov	sp, r7
 80011c0:	bd80      	pop	{r7, pc}
 80011c2:	bf00      	nop
	...

080011d0 <osalSysLockFromISR>:
static inline void osalSysLockFromISR(void) {
 80011d0:	b580      	push	{r7, lr}
 80011d2:	af00      	add	r7, sp, #0
  chSysLockFromISR();
 80011d4:	f7ff ffcc 	bl	8001170 <chSysLockFromISR>
}
 80011d8:	bf00      	nop
 80011da:	bd80      	pop	{r7, pc}
 80011dc:	0000      	movs	r0, r0
	...

080011e0 <osalSysUnlockFromISR>:
static inline void osalSysUnlockFromISR(void) {
 80011e0:	b580      	push	{r7, lr}
 80011e2:	af00      	add	r7, sp, #0
  chSysUnlockFromISR();
 80011e4:	f7ff ffdc 	bl	80011a0 <chSysUnlockFromISR>
}
 80011e8:	bf00      	nop
 80011ea:	bd80      	pop	{r7, pc}
 80011ec:	0000      	movs	r0, r0
	...

080011f0 <osalThreadResumeI>:
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80011f0:	b580      	push	{r7, lr}
 80011f2:	b082      	sub	sp, #8
 80011f4:	af00      	add	r7, sp, #0
 80011f6:	6078      	str	r0, [r7, #4]
 80011f8:	6039      	str	r1, [r7, #0]
  chThdResumeI(trp, msg);
 80011fa:	6839      	ldr	r1, [r7, #0]
 80011fc:	6878      	ldr	r0, [r7, #4]
 80011fe:	f003 f837 	bl	8004270 <chThdResumeI>
}
 8001202:	bf00      	nop
 8001204:	3708      	adds	r7, #8
 8001206:	46bd      	mov	sp, r7
 8001208:	bd80      	pop	{r7, pc}
 800120a:	bf00      	nop
 800120c:	0000      	movs	r0, r0
	...

08001210 <dac_lld_serve_tx_interrupt>:
 * @brief   Shared end/half-of-tx service routine.
 *
 * @param[in] dacp      pointer to the @p DACDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void dac_lld_serve_tx_interrupt(DACDriver *dacp, uint32_t flags) {
 8001210:	b580      	push	{r7, lr}
 8001212:	b082      	sub	sp, #8
 8001214:	af00      	add	r7, sp, #0
 8001216:	6078      	str	r0, [r7, #4]
 8001218:	6039      	str	r1, [r7, #0]

  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800121a:	683b      	ldr	r3, [r7, #0]
 800121c:	f003 030c 	and.w	r3, r3, #12
 8001220:	2b00      	cmp	r3, #0
 8001222:	d029      	beq.n	8001278 <dac_lld_serve_tx_interrupt+0x68>
    /* DMA errors handling.*/
    dac_lld_stop_conversion(dacp);
 8001224:	6878      	ldr	r0, [r7, #4]
 8001226:	f000 fa1b 	bl	8001660 <dac_lld_stop_conversion>
    _dac_isr_error_code(dacp, DAC_ERR_DMAFAILURE);
 800122a:	6878      	ldr	r0, [r7, #4]
 800122c:	f000 fa18 	bl	8001660 <dac_lld_stop_conversion>
 8001230:	687b      	ldr	r3, [r7, #4]
 8001232:	685b      	ldr	r3, [r3, #4]
 8001234:	689b      	ldr	r3, [r3, #8]
 8001236:	2b00      	cmp	r3, #0
 8001238:	d00f      	beq.n	800125a <dac_lld_serve_tx_interrupt+0x4a>
 800123a:	687b      	ldr	r3, [r7, #4]
 800123c:	2205      	movs	r2, #5
 800123e:	701a      	strb	r2, [r3, #0]
 8001240:	687b      	ldr	r3, [r7, #4]
 8001242:	685b      	ldr	r3, [r3, #4]
 8001244:	689b      	ldr	r3, [r3, #8]
 8001246:	2100      	movs	r1, #0
 8001248:	6878      	ldr	r0, [r7, #4]
 800124a:	4798      	blx	r3
 800124c:	687b      	ldr	r3, [r7, #4]
 800124e:	781b      	ldrb	r3, [r3, #0]
 8001250:	2b05      	cmp	r3, #5
 8001252:	d102      	bne.n	800125a <dac_lld_serve_tx_interrupt+0x4a>
 8001254:	687b      	ldr	r3, [r7, #4]
 8001256:	2202      	movs	r2, #2
 8001258:	701a      	strb	r2, [r3, #0]
 800125a:	687b      	ldr	r3, [r7, #4]
 800125c:	2200      	movs	r2, #0
 800125e:	605a      	str	r2, [r3, #4]
 8001260:	f7ff ffb6 	bl	80011d0 <osalSysLockFromISR>
 8001264:	687b      	ldr	r3, [r7, #4]
 8001266:	3314      	adds	r3, #20
 8001268:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800126c:	4618      	mov	r0, r3
 800126e:	f7ff ffbf 	bl	80011f0 <osalThreadResumeI>
 8001272:	f7ff ffb5 	bl	80011e0 <osalSysUnlockFromISR>
    if ((flags & STM32_DMA_ISR_TCIF) != 0) {
      /* Transfer complete processing.*/
      _dac_isr_full_code(dacp);
    }
  }
}
 8001276:	e027      	b.n	80012c8 <dac_lld_serve_tx_interrupt+0xb8>
    if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 8001278:	683b      	ldr	r3, [r7, #0]
 800127a:	f003 0310 	and.w	r3, r3, #16
 800127e:	2b00      	cmp	r3, #0
 8001280:	d009      	beq.n	8001296 <dac_lld_serve_tx_interrupt+0x86>
      _dac_isr_half_code(dacp);
 8001282:	687b      	ldr	r3, [r7, #4]
 8001284:	685b      	ldr	r3, [r3, #4]
 8001286:	685b      	ldr	r3, [r3, #4]
 8001288:	2b00      	cmp	r3, #0
 800128a:	d004      	beq.n	8001296 <dac_lld_serve_tx_interrupt+0x86>
 800128c:	687b      	ldr	r3, [r7, #4]
 800128e:	685b      	ldr	r3, [r3, #4]
 8001290:	685b      	ldr	r3, [r3, #4]
 8001292:	6878      	ldr	r0, [r7, #4]
 8001294:	4798      	blx	r3
    if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 8001296:	683b      	ldr	r3, [r7, #0]
 8001298:	f003 0320 	and.w	r3, r3, #32
 800129c:	2b00      	cmp	r3, #0
 800129e:	d013      	beq.n	80012c8 <dac_lld_serve_tx_interrupt+0xb8>
      _dac_isr_full_code(dacp);
 80012a0:	687b      	ldr	r3, [r7, #4]
 80012a2:	685b      	ldr	r3, [r3, #4]
 80012a4:	685b      	ldr	r3, [r3, #4]
 80012a6:	2b00      	cmp	r3, #0
 80012a8:	d00e      	beq.n	80012c8 <dac_lld_serve_tx_interrupt+0xb8>
 80012aa:	687b      	ldr	r3, [r7, #4]
 80012ac:	2204      	movs	r2, #4
 80012ae:	701a      	strb	r2, [r3, #0]
 80012b0:	687b      	ldr	r3, [r7, #4]
 80012b2:	685b      	ldr	r3, [r3, #4]
 80012b4:	685b      	ldr	r3, [r3, #4]
 80012b6:	6878      	ldr	r0, [r7, #4]
 80012b8:	4798      	blx	r3
 80012ba:	687b      	ldr	r3, [r7, #4]
 80012bc:	781b      	ldrb	r3, [r3, #0]
 80012be:	2b04      	cmp	r3, #4
 80012c0:	d102      	bne.n	80012c8 <dac_lld_serve_tx_interrupt+0xb8>
 80012c2:	687b      	ldr	r3, [r7, #4]
 80012c4:	2203      	movs	r2, #3
 80012c6:	701a      	strb	r2, [r3, #0]
}
 80012c8:	bf00      	nop
 80012ca:	3708      	adds	r7, #8
 80012cc:	46bd      	mov	sp, r7
 80012ce:	bd80      	pop	{r7, pc}

080012d0 <dac_lld_init>:
/**
 * @brief   Low level DAC driver initialization.
 *
 * @notapi
 */
void dac_lld_init(void) {
 80012d0:	b580      	push	{r7, lr}
 80012d2:	af00      	add	r7, sp, #0

#if STM32_DAC_USE_DAC1_CH1
  dacObjectInit(&DACD1);
 80012d4:	4809      	ldr	r0, [pc, #36]	; (80012fc <dac_lld_init+0x2c>)
 80012d6:	f7ff f9a3 	bl	8000620 <dacObjectInit>
  DACD1.params  = &dac1_ch1_params;
 80012da:	4b08      	ldr	r3, [pc, #32]	; (80012fc <dac_lld_init+0x2c>)
 80012dc:	4a08      	ldr	r2, [pc, #32]	; (8001300 <dac_lld_init+0x30>)
 80012de:	629a      	str	r2, [r3, #40]	; 0x28
  DACD1.dma = NULL;
 80012e0:	4b06      	ldr	r3, [pc, #24]	; (80012fc <dac_lld_init+0x2c>)
 80012e2:	2200      	movs	r2, #0
 80012e4:	62da      	str	r2, [r3, #44]	; 0x2c
#endif

#if STM32_DAC_USE_DAC1_CH2
  dacObjectInit(&DACD2);
 80012e6:	4807      	ldr	r0, [pc, #28]	; (8001304 <dac_lld_init+0x34>)
 80012e8:	f7ff f99a 	bl	8000620 <dacObjectInit>
  DACD2.params  = &dac1_ch2_params;
 80012ec:	4b05      	ldr	r3, [pc, #20]	; (8001304 <dac_lld_init+0x34>)
 80012ee:	4a06      	ldr	r2, [pc, #24]	; (8001308 <dac_lld_init+0x38>)
 80012f0:	629a      	str	r2, [r3, #40]	; 0x28
  DACD2.dma = NULL;
 80012f2:	4b04      	ldr	r3, [pc, #16]	; (8001304 <dac_lld_init+0x34>)
 80012f4:	2200      	movs	r2, #0
 80012f6:	62da      	str	r2, [r3, #44]	; 0x2c
#if STM32_DAC_USE_DAC4_CH2
  dacObjectInit(&DACD8);
  DACD8.params  = &dac4_ch2_params;
  DACD8.dma = NULL;
#endif
}
 80012f8:	bf00      	nop
 80012fa:	bd80      	pop	{r7, pc}
 80012fc:	20000800 	.word	0x20000800
 8001300:	08004c4c 	.word	0x08004c4c
 8001304:	20000830 	.word	0x20000830
 8001308:	08004c68 	.word	0x08004c68
 800130c:	00000000 	.word	0x00000000

08001310 <dac_lld_start>:
 *
 * @param[in] dacp      pointer to the @p DACDriver object
 *
 * @notapi
 */
void dac_lld_start(DACDriver *dacp) {
 8001310:	b580      	push	{r7, lr}
 8001312:	b084      	sub	sp, #16
 8001314:	af00      	add	r7, sp, #0
 8001316:	6078      	str	r0, [r7, #4]

  /* If the driver is in DAC_STOP state then a full initialization is
     required.*/
  if (dacp->state == DAC_STOP) {
 8001318:	687b      	ldr	r3, [r7, #4]
 800131a:	781b      	ldrb	r3, [r3, #0]
 800131c:	2b01      	cmp	r3, #1
 800131e:	d14c      	bne.n	80013ba <dac_lld_start+0xaa>
    dacchannel_t channel = 0;
 8001320:	2300      	movs	r3, #0
 8001322:	60fb      	str	r3, [r7, #12]

    /* Enabling the clock source.*/
#if STM32_DAC_USE_DAC1_CH1
    if (&DACD1 == dacp) {
 8001324:	687b      	ldr	r3, [r7, #4]
 8001326:	4a27      	ldr	r2, [pc, #156]	; (80013c4 <dac_lld_start+0xb4>)
 8001328:	4293      	cmp	r3, r2
 800132a:	d10d      	bne.n	8001348 <dac_lld_start+0x38>
      rccEnableDAC1(true);
 800132c:	4b26      	ldr	r3, [pc, #152]	; (80013c8 <dac_lld_start+0xb8>)
 800132e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001330:	4a25      	ldr	r2, [pc, #148]	; (80013c8 <dac_lld_start+0xb8>)
 8001332:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001336:	6413      	str	r3, [r2, #64]	; 0x40
 8001338:	4b23      	ldr	r3, [pc, #140]	; (80013c8 <dac_lld_start+0xb8>)
 800133a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 800133c:	4a22      	ldr	r2, [pc, #136]	; (80013c8 <dac_lld_start+0xb8>)
 800133e:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001342:	6613      	str	r3, [r2, #96]	; 0x60
 8001344:	4b20      	ldr	r3, [pc, #128]	; (80013c8 <dac_lld_start+0xb8>)
 8001346:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    }
#endif

#if STM32_DAC_USE_DAC1_CH2
    if (&DACD2 == dacp) {
 8001348:	687b      	ldr	r3, [r7, #4]
 800134a:	4a20      	ldr	r2, [pc, #128]	; (80013cc <dac_lld_start+0xbc>)
 800134c:	4293      	cmp	r3, r2
 800134e:	d10f      	bne.n	8001370 <dac_lld_start+0x60>
      rccEnableDAC1(true);
 8001350:	4b1d      	ldr	r3, [pc, #116]	; (80013c8 <dac_lld_start+0xb8>)
 8001352:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001354:	4a1c      	ldr	r2, [pc, #112]	; (80013c8 <dac_lld_start+0xb8>)
 8001356:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 800135a:	6413      	str	r3, [r2, #64]	; 0x40
 800135c:	4b1a      	ldr	r3, [pc, #104]	; (80013c8 <dac_lld_start+0xb8>)
 800135e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001360:	4a19      	ldr	r2, [pc, #100]	; (80013c8 <dac_lld_start+0xb8>)
 8001362:	f043 5300 	orr.w	r3, r3, #536870912	; 0x20000000
 8001366:	6613      	str	r3, [r2, #96]	; 0x60
 8001368:	4b17      	ldr	r3, [pc, #92]	; (80013c8 <dac_lld_start+0xb8>)
 800136a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      channel = 1;
 800136c:	2301      	movs	r3, #1
 800136e:	60fb      	str	r3, [r7, #12]
       zero.*/
#if STM32_DAC_DUAL_MODE == FALSE
    {
      uint32_t cr;

      cr = dacp->params->dac->CR;
 8001370:	687b      	ldr	r3, [r7, #4]
 8001372:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001374:	681b      	ldr	r3, [r3, #0]
 8001376:	681b      	ldr	r3, [r3, #0]
 8001378:	60bb      	str	r3, [r7, #8]
      cr &= dacp->params->regmask;
 800137a:	687b      	ldr	r3, [r7, #4]
 800137c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800137e:	68db      	ldr	r3, [r3, #12]
 8001380:	68ba      	ldr	r2, [r7, #8]
 8001382:	4013      	ands	r3, r2
 8001384:	60bb      	str	r3, [r7, #8]
      cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 8001386:	687b      	ldr	r3, [r7, #4]
 8001388:	691b      	ldr	r3, [r3, #16]
 800138a:	685b      	ldr	r3, [r3, #4]
 800138c:	f043 0201 	orr.w	r2, r3, #1
 8001390:	687b      	ldr	r3, [r7, #4]
 8001392:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001394:	689b      	ldr	r3, [r3, #8]
 8001396:	fa02 f303 	lsl.w	r3, r2, r3
 800139a:	68ba      	ldr	r2, [r7, #8]
 800139c:	4313      	orrs	r3, r2
 800139e:	60bb      	str	r3, [r7, #8]
      dacp->params->dac->CR = cr;
 80013a0:	687b      	ldr	r3, [r7, #4]
 80013a2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80013a4:	681b      	ldr	r3, [r3, #0]
 80013a6:	68ba      	ldr	r2, [r7, #8]
 80013a8:	601a      	str	r2, [r3, #0]
      dac_lld_put_channel(dacp, channel, dacp->config->init);
 80013aa:	687b      	ldr	r3, [r7, #4]
 80013ac:	691b      	ldr	r3, [r3, #16]
 80013ae:	881b      	ldrh	r3, [r3, #0]
 80013b0:	461a      	mov	r2, r3
 80013b2:	68f9      	ldr	r1, [r7, #12]
 80013b4:	6878      	ldr	r0, [r7, #4]
 80013b6:	f000 f80b 	bl	80013d0 <dac_lld_put_channel>
      dacp->params->dac->CR = DAC_CR_EN1 | dacp->config->cr;
    }
    dac_lld_put_channel(dacp, channel, dacp->config->init);
#endif
  }
}
 80013ba:	bf00      	nop
 80013bc:	3710      	adds	r7, #16
 80013be:	46bd      	mov	sp, r7
 80013c0:	bd80      	pop	{r7, pc}
 80013c2:	bf00      	nop
 80013c4:	20000800 	.word	0x20000800
 80013c8:	40023800 	.word	0x40023800
 80013cc:	20000830 	.word	0x20000830

080013d0 <dac_lld_put_channel>:
 *
 * @api
 */
void dac_lld_put_channel(DACDriver *dacp,
                         dacchannel_t channel,
                         dacsample_t sample) {
 80013d0:	b580      	push	{r7, lr}
 80013d2:	b084      	sub	sp, #16
 80013d4:	af00      	add	r7, sp, #0
 80013d6:	60f8      	str	r0, [r7, #12]
 80013d8:	60b9      	str	r1, [r7, #8]
 80013da:	4613      	mov	r3, r2
 80013dc:	80fb      	strh	r3, [r7, #6]

  switch (dacp->config->datamode) {
 80013de:	68fb      	ldr	r3, [r7, #12]
 80013e0:	691b      	ldr	r3, [r3, #16]
 80013e2:	789b      	ldrb	r3, [r3, #2]
 80013e4:	2b02      	cmp	r3, #2
 80013e6:	d032      	beq.n	800144e <dac_lld_put_channel+0x7e>
 80013e8:	2b02      	cmp	r3, #2
 80013ea:	dc46      	bgt.n	800147a <dac_lld_put_channel+0xaa>
 80013ec:	2b00      	cmp	r3, #0
 80013ee:	d002      	beq.n	80013f6 <dac_lld_put_channel+0x26>
 80013f0:	2b01      	cmp	r3, #1
 80013f2:	d016      	beq.n	8001422 <dac_lld_put_channel+0x52>
 80013f4:	e041      	b.n	800147a <dac_lld_put_channel+0xaa>
  case DAC_DHRM_12BIT_RIGHT:
#if STM32_DAC_DUAL_MODE
  case DAC_DHRM_12BIT_RIGHT_DUAL:
#endif
    if (channel == 0U) {
 80013f6:	68bb      	ldr	r3, [r7, #8]
 80013f8:	2b00      	cmp	r3, #0
 80013fa:	d10c      	bne.n	8001416 <dac_lld_put_channel+0x46>
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR12R1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR12R1 + dacp->params->dataoffset) = (uint32_t)sample;
 80013fc:	68fb      	ldr	r3, [r7, #12]
 80013fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001400:	681b      	ldr	r3, [r3, #0]
 8001402:	f103 0208 	add.w	r2, r3, #8
 8001406:	68fb      	ldr	r3, [r7, #12]
 8001408:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800140a:	685b      	ldr	r3, [r3, #4]
 800140c:	009b      	lsls	r3, r3, #2
 800140e:	4413      	add	r3, r2
 8001410:	88fa      	ldrh	r2, [r7, #6]
 8001412:	601a      	str	r2, [r3, #0]
     STM32_HAS_DAC3_CH2 || STM32_HAS_DAC4_CH2)
    else {
      dacp->params->dac->DHR12R2 = (uint32_t)sample;
    }
#endif
    break;
 8001414:	e035      	b.n	8001482 <dac_lld_put_channel+0xb2>
      dacp->params->dac->DHR12R2 = (uint32_t)sample;
 8001416:	68fb      	ldr	r3, [r7, #12]
 8001418:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800141a:	681b      	ldr	r3, [r3, #0]
 800141c:	88fa      	ldrh	r2, [r7, #6]
 800141e:	615a      	str	r2, [r3, #20]
    break;
 8001420:	e02f      	b.n	8001482 <dac_lld_put_channel+0xb2>
  case DAC_DHRM_12BIT_LEFT:
#if STM32_DAC_DUAL_MODE
  case DAC_DHRM_12BIT_LEFT_DUAL:
#endif
    if (channel == 0U) {
 8001422:	68bb      	ldr	r3, [r7, #8]
 8001424:	2b00      	cmp	r3, #0
 8001426:	d10c      	bne.n	8001442 <dac_lld_put_channel+0x72>
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR12L1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR12L1 + dacp->params->dataoffset) = (uint32_t)sample;
 8001428:	68fb      	ldr	r3, [r7, #12]
 800142a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800142c:	681b      	ldr	r3, [r3, #0]
 800142e:	f103 020c 	add.w	r2, r3, #12
 8001432:	68fb      	ldr	r3, [r7, #12]
 8001434:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001436:	685b      	ldr	r3, [r3, #4]
 8001438:	009b      	lsls	r3, r3, #2
 800143a:	4413      	add	r3, r2
 800143c:	88fa      	ldrh	r2, [r7, #6]
 800143e:	601a      	str	r2, [r3, #0]
     STM32_HAS_DAC3_CH2 || STM32_HAS_DAC4_CH2)
    else {
      dacp->params->dac->DHR12L2 = (uint32_t)sample;
    }
#endif
    break;
 8001440:	e01f      	b.n	8001482 <dac_lld_put_channel+0xb2>
      dacp->params->dac->DHR12L2 = (uint32_t)sample;
 8001442:	68fb      	ldr	r3, [r7, #12]
 8001444:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001446:	681b      	ldr	r3, [r3, #0]
 8001448:	88fa      	ldrh	r2, [r7, #6]
 800144a:	619a      	str	r2, [r3, #24]
    break;
 800144c:	e019      	b.n	8001482 <dac_lld_put_channel+0xb2>
  case DAC_DHRM_8BIT_RIGHT:
#if STM32_DAC_DUAL_MODE
  case DAC_DHRM_8BIT_RIGHT_DUAL:
#endif
    if (channel == 0U) {
 800144e:	68bb      	ldr	r3, [r7, #8]
 8001450:	2b00      	cmp	r3, #0
 8001452:	d10c      	bne.n	800146e <dac_lld_put_channel+0x9e>
#if STM32_DAC_DUAL_MODE
      dacp->params->dac->DHR8R1 = (uint32_t)sample;
#else
      *(&dacp->params->dac->DHR8R1 + dacp->params->dataoffset) = (uint32_t)sample;
 8001454:	68fb      	ldr	r3, [r7, #12]
 8001456:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001458:	681b      	ldr	r3, [r3, #0]
 800145a:	f103 0210 	add.w	r2, r3, #16
 800145e:	68fb      	ldr	r3, [r7, #12]
 8001460:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001462:	685b      	ldr	r3, [r3, #4]
 8001464:	009b      	lsls	r3, r3, #2
 8001466:	4413      	add	r3, r2
 8001468:	88fa      	ldrh	r2, [r7, #6]
 800146a:	601a      	str	r2, [r3, #0]
     STM32_HAS_DAC3_CH2 || STM32_HAS_DAC4_CH2)
    else {
      dacp->params->dac->DHR8R2 = (uint32_t)sample;
    }
#endif
    break;
 800146c:	e009      	b.n	8001482 <dac_lld_put_channel+0xb2>
      dacp->params->dac->DHR8R2 = (uint32_t)sample;
 800146e:	68fb      	ldr	r3, [r7, #12]
 8001470:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001472:	681b      	ldr	r3, [r3, #0]
 8001474:	88fa      	ldrh	r2, [r7, #6]
 8001476:	61da      	str	r2, [r3, #28]
    break;
 8001478:	e003      	b.n	8001482 <dac_lld_put_channel+0xb2>
  default:
    osalDbgAssert(false, "unexpected DAC mode");
 800147a:	4804      	ldr	r0, [pc, #16]	; (800148c <dac_lld_put_channel+0xbc>)
 800147c:	f001 f958 	bl	8002730 <chSysHalt>
    break;
 8001480:	bf00      	nop
  }
}
 8001482:	bf00      	nop
 8001484:	3710      	adds	r7, #16
 8001486:	46bd      	mov	sp, r7
 8001488:	bd80      	pop	{r7, pc}
 800148a:	bf00      	nop
 800148c:	08004c84 	.word	0x08004c84

08001490 <dac_lld_start_conversion>:
#define USE_STM32_DMA_CR_PSIZE STM32_DMA_CR_PSIZE_HWORD
#else
#define USE_STM32_DMA_CR_PSIZE STM32_DMA_CR_PSIZE_WORD
#endif

void dac_lld_start_conversion(DACDriver *dacp) {
 8001490:	b580      	push	{r7, lr}
 8001492:	b086      	sub	sp, #24
 8001494:	af00      	add	r7, sp, #0
 8001496:	6078      	str	r0, [r7, #4]
  uint32_t n, cr, dmamode;

  /* Number of DMA operations per buffer.*/
  n = dacp->depth * dacp->grpp->num_channels;
 8001498:	687b      	ldr	r3, [r7, #4]
 800149a:	68db      	ldr	r3, [r3, #12]
 800149c:	687a      	ldr	r2, [r7, #4]
 800149e:	6852      	ldr	r2, [r2, #4]
 80014a0:	6812      	ldr	r2, [r2, #0]
 80014a2:	fb02 f303 	mul.w	r3, r2, r3
 80014a6:	617b      	str	r3, [r7, #20]

  /* Allocating the DMA channel.*/
  dacp->dma = dmaStreamAllocI(dacp->params->dmastream,
 80014a8:	687b      	ldr	r3, [r7, #4]
 80014aa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80014ac:	6918      	ldr	r0, [r3, #16]
                              dacp->params->dmairqprio,
 80014ae:	687b      	ldr	r3, [r7, #4]
 80014b0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80014b2:	6999      	ldr	r1, [r3, #24]
  dacp->dma = dmaStreamAllocI(dacp->params->dmastream,
 80014b4:	687b      	ldr	r3, [r7, #4]
 80014b6:	4a67      	ldr	r2, [pc, #412]	; (8001654 <dac_lld_start_conversion+0x1c4>)
 80014b8:	f000 fc62 	bl	8001d80 <dmaStreamAllocI>
 80014bc:	4602      	mov	r2, r0
 80014be:	687b      	ldr	r3, [r7, #4]
 80014c0:	62da      	str	r2, [r3, #44]	; 0x2c
                              (stm32_dmaisr_t)dac_lld_serve_tx_interrupt,
                              (void *)dacp);
  osalDbgAssert(dacp->dma != NULL, "unable to allocate stream");
 80014c2:	687b      	ldr	r3, [r7, #4]
 80014c4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80014c6:	2b00      	cmp	r3, #0
 80014c8:	bf0c      	ite	eq
 80014ca:	2301      	moveq	r3, #1
 80014cc:	2300      	movne	r3, #0
 80014ce:	b2db      	uxtb	r3, r3
 80014d0:	2b00      	cmp	r3, #0
 80014d2:	d002      	beq.n	80014da <dac_lld_start_conversion+0x4a>
 80014d4:	4860      	ldr	r0, [pc, #384]	; (8001658 <dac_lld_start_conversion+0x1c8>)
 80014d6:	f001 f92b 	bl	8002730 <chSysHalt>
#if STM32_DMA_SUPPORTS_DMAMUX
  dmaSetRequestSource(dacp->dma, dacp->params->peripheral);
#endif

  /* DMA settings depend on the chosen DAC mode.*/
  switch (dacp->config->datamode) {
 80014da:	687b      	ldr	r3, [r7, #4]
 80014dc:	691b      	ldr	r3, [r3, #16]
 80014de:	789b      	ldrb	r3, [r3, #2]
 80014e0:	2b02      	cmp	r3, #2
 80014e2:	d04a      	beq.n	800157a <dac_lld_start_conversion+0xea>
 80014e4:	2b02      	cmp	r3, #2
 80014e6:	dc6e      	bgt.n	80015c6 <dac_lld_start_conversion+0x136>
 80014e8:	2b00      	cmp	r3, #0
 80014ea:	d002      	beq.n	80014f2 <dac_lld_start_conversion+0x62>
 80014ec:	2b01      	cmp	r3, #1
 80014ee:	d022      	beq.n	8001536 <dac_lld_start_conversion+0xa6>
 80014f0:	e069      	b.n	80015c6 <dac_lld_start_conversion+0x136>
  /* Sets the DAC data register */
  case DAC_DHRM_12BIT_RIGHT:
    osalDbgAssert(dacp->grpp->num_channels == 1, "invalid number of channels");
 80014f2:	687b      	ldr	r3, [r7, #4]
 80014f4:	685b      	ldr	r3, [r3, #4]
 80014f6:	681b      	ldr	r3, [r3, #0]
 80014f8:	2b01      	cmp	r3, #1
 80014fa:	bf14      	ite	ne
 80014fc:	2301      	movne	r3, #1
 80014fe:	2300      	moveq	r3, #0
 8001500:	b2db      	uxtb	r3, r3
 8001502:	2b00      	cmp	r3, #0
 8001504:	d002      	beq.n	800150c <dac_lld_start_conversion+0x7c>
 8001506:	4854      	ldr	r0, [pc, #336]	; (8001658 <dac_lld_start_conversion+0x1c8>)
 8001508:	f001 f912 	bl	8002730 <chSysHalt>

    dmaStreamSetPeripheral(dacp->dma, &dacp->params->dac->DHR12R1 +
 800150c:	687b      	ldr	r3, [r7, #4]
 800150e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001510:	681b      	ldr	r3, [r3, #0]
 8001512:	f103 0208 	add.w	r2, r3, #8
 8001516:	687b      	ldr	r3, [r7, #4]
 8001518:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800151a:	685b      	ldr	r3, [r3, #4]
 800151c:	009b      	lsls	r3, r3, #2
 800151e:	441a      	add	r2, r3
 8001520:	687b      	ldr	r3, [r7, #4]
 8001522:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001524:	681b      	ldr	r3, [r3, #0]
 8001526:	609a      	str	r2, [r3, #8]
                                      dacp->params->dataoffset);
    dmamode = dacp->params->dmamode |
 8001528:	687b      	ldr	r3, [r7, #4]
 800152a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800152c:	695b      	ldr	r3, [r3, #20]
 800152e:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 8001532:	613b      	str	r3, [r7, #16]
             USE_STM32_DMA_CR_PSIZE | STM32_DMA_CR_MSIZE_HWORD;
    break;
 8001534:	e04b      	b.n	80015ce <dac_lld_start_conversion+0x13e>
  case DAC_DHRM_12BIT_LEFT:
    osalDbgAssert(dacp->grpp->num_channels == 1, "invalid number of channels");
 8001536:	687b      	ldr	r3, [r7, #4]
 8001538:	685b      	ldr	r3, [r3, #4]
 800153a:	681b      	ldr	r3, [r3, #0]
 800153c:	2b01      	cmp	r3, #1
 800153e:	bf14      	ite	ne
 8001540:	2301      	movne	r3, #1
 8001542:	2300      	moveq	r3, #0
 8001544:	b2db      	uxtb	r3, r3
 8001546:	2b00      	cmp	r3, #0
 8001548:	d002      	beq.n	8001550 <dac_lld_start_conversion+0xc0>
 800154a:	4843      	ldr	r0, [pc, #268]	; (8001658 <dac_lld_start_conversion+0x1c8>)
 800154c:	f001 f8f0 	bl	8002730 <chSysHalt>

    dmaStreamSetPeripheral(dacp->dma, &dacp->params->dac->DHR12L1 +
 8001550:	687b      	ldr	r3, [r7, #4]
 8001552:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001554:	681b      	ldr	r3, [r3, #0]
 8001556:	f103 020c 	add.w	r2, r3, #12
 800155a:	687b      	ldr	r3, [r7, #4]
 800155c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800155e:	685b      	ldr	r3, [r3, #4]
 8001560:	009b      	lsls	r3, r3, #2
 8001562:	441a      	add	r2, r3
 8001564:	687b      	ldr	r3, [r7, #4]
 8001566:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001568:	681b      	ldr	r3, [r3, #0]
 800156a:	609a      	str	r2, [r3, #8]
                                      dacp->params->dataoffset);
    dmamode = dacp->params->dmamode |
 800156c:	687b      	ldr	r3, [r7, #4]
 800156e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001570:	695b      	ldr	r3, [r3, #20]
 8001572:	f443 5320 	orr.w	r3, r3, #10240	; 0x2800
 8001576:	613b      	str	r3, [r7, #16]
             USE_STM32_DMA_CR_PSIZE | STM32_DMA_CR_MSIZE_HWORD;
    break;
 8001578:	e029      	b.n	80015ce <dac_lld_start_conversion+0x13e>
  case DAC_DHRM_8BIT_RIGHT:
    osalDbgAssert(dacp->grpp->num_channels == 1, "invalid number of channels");
 800157a:	687b      	ldr	r3, [r7, #4]
 800157c:	685b      	ldr	r3, [r3, #4]
 800157e:	681b      	ldr	r3, [r3, #0]
 8001580:	2b01      	cmp	r3, #1
 8001582:	bf14      	ite	ne
 8001584:	2301      	movne	r3, #1
 8001586:	2300      	moveq	r3, #0
 8001588:	b2db      	uxtb	r3, r3
 800158a:	2b00      	cmp	r3, #0
 800158c:	d002      	beq.n	8001594 <dac_lld_start_conversion+0x104>
 800158e:	4832      	ldr	r0, [pc, #200]	; (8001658 <dac_lld_start_conversion+0x1c8>)
 8001590:	f001 f8ce 	bl	8002730 <chSysHalt>

    dmaStreamSetPeripheral(dacp->dma, &dacp->params->dac->DHR8R1 +
 8001594:	687b      	ldr	r3, [r7, #4]
 8001596:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001598:	681b      	ldr	r3, [r3, #0]
 800159a:	f103 0210 	add.w	r2, r3, #16
 800159e:	687b      	ldr	r3, [r7, #4]
 80015a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80015a2:	685b      	ldr	r3, [r3, #4]
 80015a4:	009b      	lsls	r3, r3, #2
 80015a6:	441a      	add	r2, r3
 80015a8:	687b      	ldr	r3, [r7, #4]
 80015aa:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015ac:	681b      	ldr	r3, [r3, #0]
 80015ae:	609a      	str	r2, [r3, #8]
                                      dacp->params->dataoffset);
    dmamode = dacp->params->dmamode |
 80015b0:	687b      	ldr	r3, [r7, #4]
 80015b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80015b4:	695b      	ldr	r3, [r3, #20]
 80015b6:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 80015ba:	613b      	str	r3, [r7, #16]
             USE_STM32_DMA_CR_PSIZE | STM32_DMA_CR_MSIZE_BYTE;

    /* In this mode the size of the buffer is halved because two samples
       packed in a single dacsample_t element.*/
    n = (n + 1) / 2;
 80015bc:	697b      	ldr	r3, [r7, #20]
 80015be:	3301      	adds	r3, #1
 80015c0:	085b      	lsrs	r3, r3, #1
 80015c2:	617b      	str	r3, [r7, #20]
    break;
 80015c4:	e003      	b.n	80015ce <dac_lld_start_conversion+0x13e>
             USE_STM32_DMA_CR_PSIZE | STM32_DMA_CR_MSIZE_HWORD;
    n /= 2;
    break;
#endif
  default:
    osalDbgAssert(false, "unexpected DAC mode");
 80015c6:	4824      	ldr	r0, [pc, #144]	; (8001658 <dac_lld_start_conversion+0x1c8>)
 80015c8:	f001 f8b2 	bl	8002730 <chSysHalt>
    return;
 80015cc:	e03e      	b.n	800164c <dac_lld_start_conversion+0x1bc>
  }

  dmaStreamSetMemory0(dacp->dma, dacp->samples);
 80015ce:	687b      	ldr	r3, [r7, #4]
 80015d0:	689a      	ldr	r2, [r3, #8]
 80015d2:	687b      	ldr	r3, [r7, #4]
 80015d4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015d6:	681b      	ldr	r3, [r3, #0]
 80015d8:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(dacp->dma, n);
 80015da:	687b      	ldr	r3, [r7, #4]
 80015dc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015de:	681b      	ldr	r3, [r3, #0]
 80015e0:	697a      	ldr	r2, [r7, #20]
 80015e2:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(dacp->dma, dmamode            |
 80015e4:	687b      	ldr	r3, [r7, #4]
 80015e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015e8:	681b      	ldr	r3, [r3, #0]
 80015ea:	693a      	ldr	r2, [r7, #16]
 80015ec:	f042 021e 	orr.w	r2, r2, #30
 80015f0:	601a      	str	r2, [r3, #0]
                              STM32_DMA_CR_DMEIE | STM32_DMA_CR_TEIE |
                              STM32_DMA_CR_HTIE  | STM32_DMA_CR_TCIE);
  dmaStreamEnable(dacp->dma);
 80015f2:	687b      	ldr	r3, [r7, #4]
 80015f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015f6:	681b      	ldr	r3, [r3, #0]
 80015f8:	681a      	ldr	r2, [r3, #0]
 80015fa:	687b      	ldr	r3, [r7, #4]
 80015fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80015fe:	681b      	ldr	r3, [r3, #0]
 8001600:	f042 0201 	orr.w	r2, r2, #1
 8001604:	601a      	str	r2, [r3, #0]

  /* DAC configuration.*/
  cr = dacp->params->dac->CR;
 8001606:	687b      	ldr	r3, [r7, #4]
 8001608:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800160a:	681b      	ldr	r3, [r3, #0]
 800160c:	681b      	ldr	r3, [r3, #0]
 800160e:	60fb      	str	r3, [r7, #12]

#if STM32_DAC_DUAL_MODE == FALSE
  cr &= dacp->params->regmask;
 8001610:	687b      	ldr	r3, [r7, #4]
 8001612:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001614:	68db      	ldr	r3, [r3, #12]
 8001616:	68fa      	ldr	r2, [r7, #12]
 8001618:	4013      	ands	r3, r2
 800161a:	60fb      	str	r3, [r7, #12]
  cr |= (DAC_CR_DMAEN1 | (dacp->grpp->trigger << DAC_CR_TSEL1_Pos) | DAC_CR_TEN1 | DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 800161c:	687b      	ldr	r3, [r7, #4]
 800161e:	685b      	ldr	r3, [r3, #4]
 8001620:	68db      	ldr	r3, [r3, #12]
 8001622:	00da      	lsls	r2, r3, #3
 8001624:	687b      	ldr	r3, [r7, #4]
 8001626:	691b      	ldr	r3, [r3, #16]
 8001628:	685b      	ldr	r3, [r3, #4]
 800162a:	4313      	orrs	r3, r2
 800162c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001630:	f043 0305 	orr.w	r3, r3, #5
 8001634:	687a      	ldr	r2, [r7, #4]
 8001636:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8001638:	6892      	ldr	r2, [r2, #8]
 800163a:	4093      	lsls	r3, r2
 800163c:	68fa      	ldr	r2, [r7, #12]
 800163e:	4313      	orrs	r3, r2
 8001640:	60fb      	str	r3, [r7, #12]
#else
  cr = DAC_CR_DMAEN1 | (dacp->grpp->trigger << DAC_CR_TSEL1_Pos) | DAC_CR_TEN1 | DAC_CR_EN1 | dacp->config->cr
                     | (dacp->grpp->trigger << DAC_CR_TSEL2_Pos) | DAC_CR_TEN2 | DAC_CR_EN2 | (dacp->config->cr << 16);
#endif

  dacp->params->dac->CR = cr;
 8001642:	687b      	ldr	r3, [r7, #4]
 8001644:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001646:	681b      	ldr	r3, [r3, #0]
 8001648:	68fa      	ldr	r2, [r7, #12]
 800164a:	601a      	str	r2, [r3, #0]
}
 800164c:	3718      	adds	r7, #24
 800164e:	46bd      	mov	sp, r7
 8001650:	bd80      	pop	{r7, pc}
 8001652:	bf00      	nop
 8001654:	08001211 	.word	0x08001211
 8001658:	08004c98 	.word	0x08004c98
 800165c:	00000000 	.word	0x00000000

08001660 <dac_lld_stop_conversion>:
 *
 * @param[in] dacp      pointer to the @p DACDriver object
 *
 * @iclass
 */
void dac_lld_stop_conversion(DACDriver *dacp) {
 8001660:	b580      	push	{r7, lr}
 8001662:	b084      	sub	sp, #16
 8001664:	af00      	add	r7, sp, #0
 8001666:	6078      	str	r0, [r7, #4]
  uint32_t cr;

  /* DMA channel disabled and released.*/
  dmaStreamDisable(dacp->dma);
 8001668:	687b      	ldr	r3, [r7, #4]
 800166a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800166c:	681b      	ldr	r3, [r3, #0]
 800166e:	681a      	ldr	r2, [r3, #0]
 8001670:	687b      	ldr	r3, [r7, #4]
 8001672:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001674:	681b      	ldr	r3, [r3, #0]
 8001676:	f022 021f 	bic.w	r2, r2, #31
 800167a:	601a      	str	r2, [r3, #0]
 800167c:	bf00      	nop
 800167e:	687b      	ldr	r3, [r7, #4]
 8001680:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001682:	681b      	ldr	r3, [r3, #0]
 8001684:	681b      	ldr	r3, [r3, #0]
 8001686:	f003 0301 	and.w	r3, r3, #1
 800168a:	2b00      	cmp	r3, #0
 800168c:	d1f7      	bne.n	800167e <dac_lld_stop_conversion+0x1e>
 800168e:	687b      	ldr	r3, [r7, #4]
 8001690:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001692:	7a5b      	ldrb	r3, [r3, #9]
 8001694:	4619      	mov	r1, r3
 8001696:	687b      	ldr	r3, [r7, #4]
 8001698:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800169a:	685b      	ldr	r3, [r3, #4]
 800169c:	223d      	movs	r2, #61	; 0x3d
 800169e:	408a      	lsls	r2, r1
 80016a0:	601a      	str	r2, [r3, #0]
  dmaStreamFreeI(dacp->dma);
 80016a2:	687b      	ldr	r3, [r7, #4]
 80016a4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80016a6:	4618      	mov	r0, r3
 80016a8:	f000 fc12 	bl	8001ed0 <dmaStreamFreeI>
  dacp->dma = NULL;
 80016ac:	687b      	ldr	r3, [r7, #4]
 80016ae:	2200      	movs	r2, #0
 80016b0:	62da      	str	r2, [r3, #44]	; 0x2c

  cr = dacp->params->dac->CR;
 80016b2:	687b      	ldr	r3, [r7, #4]
 80016b4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016b6:	681b      	ldr	r3, [r3, #0]
 80016b8:	681b      	ldr	r3, [r3, #0]
 80016ba:	60fb      	str	r3, [r7, #12]

#if STM32_DAC_DUAL_MODE == FALSE
  cr &= dacp->params->regmask;
 80016bc:	687b      	ldr	r3, [r7, #4]
 80016be:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016c0:	68db      	ldr	r3, [r3, #12]
 80016c2:	68fa      	ldr	r2, [r7, #12]
 80016c4:	4013      	ands	r3, r2
 80016c6:	60fb      	str	r3, [r7, #12]
  cr |= (DAC_CR_EN1 | dacp->config->cr) << dacp->params->regshift;
 80016c8:	687b      	ldr	r3, [r7, #4]
 80016ca:	691b      	ldr	r3, [r3, #16]
 80016cc:	685b      	ldr	r3, [r3, #4]
 80016ce:	f043 0201 	orr.w	r2, r3, #1
 80016d2:	687b      	ldr	r3, [r7, #4]
 80016d4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016d6:	689b      	ldr	r3, [r3, #8]
 80016d8:	fa02 f303 	lsl.w	r3, r2, r3
 80016dc:	68fa      	ldr	r2, [r7, #12]
 80016de:	4313      	orrs	r3, r2
 80016e0:	60fb      	str	r3, [r7, #12]
  else {
    cr = DAC_CR_EN1 | dacp->config->cr;
  }
#endif

  dacp->params->dac->CR = cr;
 80016e2:	687b      	ldr	r3, [r7, #4]
 80016e4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80016e6:	681b      	ldr	r3, [r3, #0]
 80016e8:	68fa      	ldr	r2, [r7, #12]
 80016ea:	601a      	str	r2, [r3, #0]
}
 80016ec:	bf00      	nop
 80016ee:	3710      	adds	r7, #16
 80016f0:	46bd      	mov	sp, r7
 80016f2:	bd80      	pop	{r7, pc}
	...

08001700 <Vector6C>:
/**
 * @brief   DMA1 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH0_HANDLER) {
 8001700:	b580      	push	{r7, lr}
 8001702:	b082      	sub	sp, #8
 8001704:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001706:	4811      	ldr	r0, [pc, #68]	; (800174c <Vector6C+0x4c>)
 8001708:	f001 faba 	bl	8002c80 <__trace_isr_enter>
 800170c:	f001 f908 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001710:	4b0f      	ldr	r3, [pc, #60]	; (8001750 <Vector6C+0x50>)
 8001712:	681b      	ldr	r3, [r3, #0]
 8001714:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001718:	607b      	str	r3, [r7, #4]
  DMA1->LIFCR = flags << 0U;
 800171a:	4a0d      	ldr	r2, [pc, #52]	; (8001750 <Vector6C+0x50>)
 800171c:	687b      	ldr	r3, [r7, #4]
 800171e:	6093      	str	r3, [r2, #8]
  if (dma.streams[0].func)
 8001720:	4b0c      	ldr	r3, [pc, #48]	; (8001754 <Vector6C+0x54>)
 8001722:	685b      	ldr	r3, [r3, #4]
 8001724:	2b00      	cmp	r3, #0
 8001726:	d006      	beq.n	8001736 <Vector6C+0x36>
    dma.streams[0].func(dma.streams[0].param, flags);
 8001728:	4b0a      	ldr	r3, [pc, #40]	; (8001754 <Vector6C+0x54>)
 800172a:	685b      	ldr	r3, [r3, #4]
 800172c:	4a09      	ldr	r2, [pc, #36]	; (8001754 <Vector6C+0x54>)
 800172e:	6892      	ldr	r2, [r2, #8]
 8001730:	6879      	ldr	r1, [r7, #4]
 8001732:	4610      	mov	r0, r2
 8001734:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001736:	f001 f92b 	bl	8002990 <__dbg_check_leave_isr>
 800173a:	4804      	ldr	r0, [pc, #16]	; (800174c <Vector6C+0x4c>)
 800173c:	f001 fae0 	bl	8002d00 <__trace_isr_leave>
 8001740:	f003 f8d6 	bl	80048f0 <__port_irq_epilogue>
}
 8001744:	bf00      	nop
 8001746:	3708      	adds	r7, #8
 8001748:	46bd      	mov	sp, r7
 800174a:	bd80      	pop	{r7, pc}
 800174c:	08004d74 	.word	0x08004d74
 8001750:	40026000 	.word	0x40026000
 8001754:	20000860 	.word	0x20000860
	...

08001760 <Vector70>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 8001760:	b580      	push	{r7, lr}
 8001762:	b082      	sub	sp, #8
 8001764:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001766:	4812      	ldr	r0, [pc, #72]	; (80017b0 <Vector70+0x50>)
 8001768:	f001 fa8a 	bl	8002c80 <__trace_isr_enter>
 800176c:	f001 f8d8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001770:	4b10      	ldr	r3, [pc, #64]	; (80017b4 <Vector70+0x54>)
 8001772:	681b      	ldr	r3, [r3, #0]
 8001774:	099b      	lsrs	r3, r3, #6
 8001776:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800177a:	607b      	str	r3, [r7, #4]
  DMA1->LIFCR = flags << 6U;
 800177c:	4a0d      	ldr	r2, [pc, #52]	; (80017b4 <Vector70+0x54>)
 800177e:	687b      	ldr	r3, [r7, #4]
 8001780:	019b      	lsls	r3, r3, #6
 8001782:	6093      	str	r3, [r2, #8]
  if (dma.streams[1].func)
 8001784:	4b0c      	ldr	r3, [pc, #48]	; (80017b8 <Vector70+0x58>)
 8001786:	68db      	ldr	r3, [r3, #12]
 8001788:	2b00      	cmp	r3, #0
 800178a:	d006      	beq.n	800179a <Vector70+0x3a>
    dma.streams[1].func(dma.streams[1].param, flags);
 800178c:	4b0a      	ldr	r3, [pc, #40]	; (80017b8 <Vector70+0x58>)
 800178e:	68db      	ldr	r3, [r3, #12]
 8001790:	4a09      	ldr	r2, [pc, #36]	; (80017b8 <Vector70+0x58>)
 8001792:	6912      	ldr	r2, [r2, #16]
 8001794:	6879      	ldr	r1, [r7, #4]
 8001796:	4610      	mov	r0, r2
 8001798:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800179a:	f001 f8f9 	bl	8002990 <__dbg_check_leave_isr>
 800179e:	4804      	ldr	r0, [pc, #16]	; (80017b0 <Vector70+0x50>)
 80017a0:	f001 faae 	bl	8002d00 <__trace_isr_leave>
 80017a4:	f003 f8a4 	bl	80048f0 <__port_irq_epilogue>
}
 80017a8:	bf00      	nop
 80017aa:	3708      	adds	r7, #8
 80017ac:	46bd      	mov	sp, r7
 80017ae:	bd80      	pop	{r7, pc}
 80017b0:	08004d80 	.word	0x08004d80
 80017b4:	40026000 	.word	0x40026000
 80017b8:	20000860 	.word	0x20000860
 80017bc:	00000000 	.word	0x00000000

080017c0 <Vector74>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 80017c0:	b580      	push	{r7, lr}
 80017c2:	b082      	sub	sp, #8
 80017c4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80017c6:	4812      	ldr	r0, [pc, #72]	; (8001810 <Vector74+0x50>)
 80017c8:	f001 fa5a 	bl	8002c80 <__trace_isr_enter>
 80017cc:	f001 f8a8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 16U) & STM32_DMA_ISR_MASK;
 80017d0:	4b10      	ldr	r3, [pc, #64]	; (8001814 <Vector74+0x54>)
 80017d2:	681b      	ldr	r3, [r3, #0]
 80017d4:	0c1b      	lsrs	r3, r3, #16
 80017d6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80017da:	607b      	str	r3, [r7, #4]
  DMA1->LIFCR = flags << 16U;
 80017dc:	4a0d      	ldr	r2, [pc, #52]	; (8001814 <Vector74+0x54>)
 80017de:	687b      	ldr	r3, [r7, #4]
 80017e0:	041b      	lsls	r3, r3, #16
 80017e2:	6093      	str	r3, [r2, #8]
  if (dma.streams[2].func)
 80017e4:	4b0c      	ldr	r3, [pc, #48]	; (8001818 <Vector74+0x58>)
 80017e6:	695b      	ldr	r3, [r3, #20]
 80017e8:	2b00      	cmp	r3, #0
 80017ea:	d006      	beq.n	80017fa <Vector74+0x3a>
    dma.streams[2].func(dma.streams[2].param, flags);
 80017ec:	4b0a      	ldr	r3, [pc, #40]	; (8001818 <Vector74+0x58>)
 80017ee:	695b      	ldr	r3, [r3, #20]
 80017f0:	4a09      	ldr	r2, [pc, #36]	; (8001818 <Vector74+0x58>)
 80017f2:	6992      	ldr	r2, [r2, #24]
 80017f4:	6879      	ldr	r1, [r7, #4]
 80017f6:	4610      	mov	r0, r2
 80017f8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80017fa:	f001 f8c9 	bl	8002990 <__dbg_check_leave_isr>
 80017fe:	4804      	ldr	r0, [pc, #16]	; (8001810 <Vector74+0x50>)
 8001800:	f001 fa7e 	bl	8002d00 <__trace_isr_leave>
 8001804:	f003 f874 	bl	80048f0 <__port_irq_epilogue>
}
 8001808:	bf00      	nop
 800180a:	3708      	adds	r7, #8
 800180c:	46bd      	mov	sp, r7
 800180e:	bd80      	pop	{r7, pc}
 8001810:	08004d8c 	.word	0x08004d8c
 8001814:	40026000 	.word	0x40026000
 8001818:	20000860 	.word	0x20000860
 800181c:	00000000 	.word	0x00000000

08001820 <Vector78>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 8001820:	b580      	push	{r7, lr}
 8001822:	b082      	sub	sp, #8
 8001824:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001826:	4812      	ldr	r0, [pc, #72]	; (8001870 <Vector78+0x50>)
 8001828:	f001 fa2a 	bl	8002c80 <__trace_isr_enter>
 800182c:	f001 f878 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001830:	4b10      	ldr	r3, [pc, #64]	; (8001874 <Vector78+0x54>)
 8001832:	681b      	ldr	r3, [r3, #0]
 8001834:	0d9b      	lsrs	r3, r3, #22
 8001836:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800183a:	607b      	str	r3, [r7, #4]
  DMA1->LIFCR = flags << 22U;
 800183c:	4a0d      	ldr	r2, [pc, #52]	; (8001874 <Vector78+0x54>)
 800183e:	687b      	ldr	r3, [r7, #4]
 8001840:	059b      	lsls	r3, r3, #22
 8001842:	6093      	str	r3, [r2, #8]
  if (dma.streams[3].func)
 8001844:	4b0c      	ldr	r3, [pc, #48]	; (8001878 <Vector78+0x58>)
 8001846:	69db      	ldr	r3, [r3, #28]
 8001848:	2b00      	cmp	r3, #0
 800184a:	d006      	beq.n	800185a <Vector78+0x3a>
    dma.streams[3].func(dma.streams[3].param, flags);
 800184c:	4b0a      	ldr	r3, [pc, #40]	; (8001878 <Vector78+0x58>)
 800184e:	69db      	ldr	r3, [r3, #28]
 8001850:	4a09      	ldr	r2, [pc, #36]	; (8001878 <Vector78+0x58>)
 8001852:	6a12      	ldr	r2, [r2, #32]
 8001854:	6879      	ldr	r1, [r7, #4]
 8001856:	4610      	mov	r0, r2
 8001858:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800185a:	f001 f899 	bl	8002990 <__dbg_check_leave_isr>
 800185e:	4804      	ldr	r0, [pc, #16]	; (8001870 <Vector78+0x50>)
 8001860:	f001 fa4e 	bl	8002d00 <__trace_isr_leave>
 8001864:	f003 f844 	bl	80048f0 <__port_irq_epilogue>
}
 8001868:	bf00      	nop
 800186a:	3708      	adds	r7, #8
 800186c:	46bd      	mov	sp, r7
 800186e:	bd80      	pop	{r7, pc}
 8001870:	08004d98 	.word	0x08004d98
 8001874:	40026000 	.word	0x40026000
 8001878:	20000860 	.word	0x20000860
 800187c:	00000000 	.word	0x00000000

08001880 <Vector7C>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8001880:	b580      	push	{r7, lr}
 8001882:	b082      	sub	sp, #8
 8001884:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001886:	4811      	ldr	r0, [pc, #68]	; (80018cc <Vector7C+0x4c>)
 8001888:	f001 f9fa 	bl	8002c80 <__trace_isr_enter>
 800188c:	f001 f848 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001890:	4b0f      	ldr	r3, [pc, #60]	; (80018d0 <Vector7C+0x50>)
 8001892:	685b      	ldr	r3, [r3, #4]
 8001894:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001898:	607b      	str	r3, [r7, #4]
  DMA1->HIFCR = flags << 0U;
 800189a:	4a0d      	ldr	r2, [pc, #52]	; (80018d0 <Vector7C+0x50>)
 800189c:	687b      	ldr	r3, [r7, #4]
 800189e:	60d3      	str	r3, [r2, #12]
  if (dma.streams[4].func)
 80018a0:	4b0c      	ldr	r3, [pc, #48]	; (80018d4 <Vector7C+0x54>)
 80018a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80018a4:	2b00      	cmp	r3, #0
 80018a6:	d006      	beq.n	80018b6 <Vector7C+0x36>
    dma.streams[4].func(dma.streams[4].param, flags);
 80018a8:	4b0a      	ldr	r3, [pc, #40]	; (80018d4 <Vector7C+0x54>)
 80018aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80018ac:	4a09      	ldr	r2, [pc, #36]	; (80018d4 <Vector7C+0x54>)
 80018ae:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80018b0:	6879      	ldr	r1, [r7, #4]
 80018b2:	4610      	mov	r0, r2
 80018b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80018b6:	f001 f86b 	bl	8002990 <__dbg_check_leave_isr>
 80018ba:	4804      	ldr	r0, [pc, #16]	; (80018cc <Vector7C+0x4c>)
 80018bc:	f001 fa20 	bl	8002d00 <__trace_isr_leave>
 80018c0:	f003 f816 	bl	80048f0 <__port_irq_epilogue>
}
 80018c4:	bf00      	nop
 80018c6:	3708      	adds	r7, #8
 80018c8:	46bd      	mov	sp, r7
 80018ca:	bd80      	pop	{r7, pc}
 80018cc:	08004da4 	.word	0x08004da4
 80018d0:	40026000 	.word	0x40026000
 80018d4:	20000860 	.word	0x20000860
	...

080018e0 <Vector80>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80018e0:	b580      	push	{r7, lr}
 80018e2:	b082      	sub	sp, #8
 80018e4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80018e6:	4812      	ldr	r0, [pc, #72]	; (8001930 <Vector80+0x50>)
 80018e8:	f001 f9ca 	bl	8002c80 <__trace_isr_enter>
 80018ec:	f001 f818 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 6U) & STM32_DMA_ISR_MASK;
 80018f0:	4b10      	ldr	r3, [pc, #64]	; (8001934 <Vector80+0x54>)
 80018f2:	685b      	ldr	r3, [r3, #4]
 80018f4:	099b      	lsrs	r3, r3, #6
 80018f6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80018fa:	607b      	str	r3, [r7, #4]
  DMA1->HIFCR = flags << 6U;
 80018fc:	4a0d      	ldr	r2, [pc, #52]	; (8001934 <Vector80+0x54>)
 80018fe:	687b      	ldr	r3, [r7, #4]
 8001900:	019b      	lsls	r3, r3, #6
 8001902:	60d3      	str	r3, [r2, #12]
  if (dma.streams[5].func)
 8001904:	4b0c      	ldr	r3, [pc, #48]	; (8001938 <Vector80+0x58>)
 8001906:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001908:	2b00      	cmp	r3, #0
 800190a:	d006      	beq.n	800191a <Vector80+0x3a>
    dma.streams[5].func(dma.streams[5].param, flags);
 800190c:	4b0a      	ldr	r3, [pc, #40]	; (8001938 <Vector80+0x58>)
 800190e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001910:	4a09      	ldr	r2, [pc, #36]	; (8001938 <Vector80+0x58>)
 8001912:	6b12      	ldr	r2, [r2, #48]	; 0x30
 8001914:	6879      	ldr	r1, [r7, #4]
 8001916:	4610      	mov	r0, r2
 8001918:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800191a:	f001 f839 	bl	8002990 <__dbg_check_leave_isr>
 800191e:	4804      	ldr	r0, [pc, #16]	; (8001930 <Vector80+0x50>)
 8001920:	f001 f9ee 	bl	8002d00 <__trace_isr_leave>
 8001924:	f002 ffe4 	bl	80048f0 <__port_irq_epilogue>
}
 8001928:	bf00      	nop
 800192a:	3708      	adds	r7, #8
 800192c:	46bd      	mov	sp, r7
 800192e:	bd80      	pop	{r7, pc}
 8001930:	08004db0 	.word	0x08004db0
 8001934:	40026000 	.word	0x40026000
 8001938:	20000860 	.word	0x20000860
 800193c:	00000000 	.word	0x00000000

08001940 <Vector84>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8001940:	b580      	push	{r7, lr}
 8001942:	b082      	sub	sp, #8
 8001944:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001946:	4812      	ldr	r0, [pc, #72]	; (8001990 <Vector84+0x50>)
 8001948:	f001 f99a 	bl	8002c80 <__trace_isr_enter>
 800194c:	f000 ffe8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001950:	4b10      	ldr	r3, [pc, #64]	; (8001994 <Vector84+0x54>)
 8001952:	685b      	ldr	r3, [r3, #4]
 8001954:	0c1b      	lsrs	r3, r3, #16
 8001956:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 800195a:	607b      	str	r3, [r7, #4]
  DMA1->HIFCR = flags << 16U;
 800195c:	4a0d      	ldr	r2, [pc, #52]	; (8001994 <Vector84+0x54>)
 800195e:	687b      	ldr	r3, [r7, #4]
 8001960:	041b      	lsls	r3, r3, #16
 8001962:	60d3      	str	r3, [r2, #12]
  if (dma.streams[6].func)
 8001964:	4b0c      	ldr	r3, [pc, #48]	; (8001998 <Vector84+0x58>)
 8001966:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001968:	2b00      	cmp	r3, #0
 800196a:	d006      	beq.n	800197a <Vector84+0x3a>
    dma.streams[6].func(dma.streams[6].param, flags);
 800196c:	4b0a      	ldr	r3, [pc, #40]	; (8001998 <Vector84+0x58>)
 800196e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001970:	4a09      	ldr	r2, [pc, #36]	; (8001998 <Vector84+0x58>)
 8001972:	6b92      	ldr	r2, [r2, #56]	; 0x38
 8001974:	6879      	ldr	r1, [r7, #4]
 8001976:	4610      	mov	r0, r2
 8001978:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 800197a:	f001 f809 	bl	8002990 <__dbg_check_leave_isr>
 800197e:	4804      	ldr	r0, [pc, #16]	; (8001990 <Vector84+0x50>)
 8001980:	f001 f9be 	bl	8002d00 <__trace_isr_leave>
 8001984:	f002 ffb4 	bl	80048f0 <__port_irq_epilogue>
}
 8001988:	bf00      	nop
 800198a:	3708      	adds	r7, #8
 800198c:	46bd      	mov	sp, r7
 800198e:	bd80      	pop	{r7, pc}
 8001990:	08004dbc 	.word	0x08004dbc
 8001994:	40026000 	.word	0x40026000
 8001998:	20000860 	.word	0x20000860
 800199c:	00000000 	.word	0x00000000

080019a0 <VectorFC>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 80019a0:	b580      	push	{r7, lr}
 80019a2:	b082      	sub	sp, #8
 80019a4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 80019a6:	4812      	ldr	r0, [pc, #72]	; (80019f0 <VectorFC+0x50>)
 80019a8:	f001 f96a 	bl	8002c80 <__trace_isr_enter>
 80019ac:	f000 ffb8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA1->HISR >> 22U) & STM32_DMA_ISR_MASK;
 80019b0:	4b10      	ldr	r3, [pc, #64]	; (80019f4 <VectorFC+0x54>)
 80019b2:	685b      	ldr	r3, [r3, #4]
 80019b4:	0d9b      	lsrs	r3, r3, #22
 80019b6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 80019ba:	607b      	str	r3, [r7, #4]
  DMA1->HIFCR = flags << 22U;
 80019bc:	4a0d      	ldr	r2, [pc, #52]	; (80019f4 <VectorFC+0x54>)
 80019be:	687b      	ldr	r3, [r7, #4]
 80019c0:	059b      	lsls	r3, r3, #22
 80019c2:	60d3      	str	r3, [r2, #12]
  if (dma.streams[7].func)
 80019c4:	4b0c      	ldr	r3, [pc, #48]	; (80019f8 <VectorFC+0x58>)
 80019c6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80019c8:	2b00      	cmp	r3, #0
 80019ca:	d006      	beq.n	80019da <VectorFC+0x3a>
    dma.streams[7].func(dma.streams[7].param, flags);
 80019cc:	4b0a      	ldr	r3, [pc, #40]	; (80019f8 <VectorFC+0x58>)
 80019ce:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80019d0:	4a09      	ldr	r2, [pc, #36]	; (80019f8 <VectorFC+0x58>)
 80019d2:	6c12      	ldr	r2, [r2, #64]	; 0x40
 80019d4:	6879      	ldr	r1, [r7, #4]
 80019d6:	4610      	mov	r0, r2
 80019d8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 80019da:	f000 ffd9 	bl	8002990 <__dbg_check_leave_isr>
 80019de:	4804      	ldr	r0, [pc, #16]	; (80019f0 <VectorFC+0x50>)
 80019e0:	f001 f98e 	bl	8002d00 <__trace_isr_leave>
 80019e4:	f002 ff84 	bl	80048f0 <__port_irq_epilogue>
}
 80019e8:	bf00      	nop
 80019ea:	3708      	adds	r7, #8
 80019ec:	46bd      	mov	sp, r7
 80019ee:	bd80      	pop	{r7, pc}
 80019f0:	08004dc8 	.word	0x08004dc8
 80019f4:	40026000 	.word	0x40026000
 80019f8:	20000860 	.word	0x20000860
 80019fc:	00000000 	.word	0x00000000

08001a00 <Vector120>:
/**
 * @brief   DMA2 stream 0 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH0_HANDLER) {
 8001a00:	b580      	push	{r7, lr}
 8001a02:	b082      	sub	sp, #8
 8001a04:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a06:	4811      	ldr	r0, [pc, #68]	; (8001a4c <Vector120+0x4c>)
 8001a08:	f001 f93a 	bl	8002c80 <__trace_isr_enter>
 8001a0c:	f000 ff88 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 0U) & STM32_DMA_ISR_MASK;
 8001a10:	4b0f      	ldr	r3, [pc, #60]	; (8001a50 <Vector120+0x50>)
 8001a12:	681b      	ldr	r3, [r3, #0]
 8001a14:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001a18:	607b      	str	r3, [r7, #4]
  DMA2->LIFCR = flags << 0U;
 8001a1a:	4a0d      	ldr	r2, [pc, #52]	; (8001a50 <Vector120+0x50>)
 8001a1c:	687b      	ldr	r3, [r7, #4]
 8001a1e:	6093      	str	r3, [r2, #8]
  if (dma.streams[8].func)
 8001a20:	4b0c      	ldr	r3, [pc, #48]	; (8001a54 <Vector120+0x54>)
 8001a22:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001a24:	2b00      	cmp	r3, #0
 8001a26:	d006      	beq.n	8001a36 <Vector120+0x36>
    dma.streams[8].func(dma.streams[8].param, flags);
 8001a28:	4b0a      	ldr	r3, [pc, #40]	; (8001a54 <Vector120+0x54>)
 8001a2a:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001a2c:	4a09      	ldr	r2, [pc, #36]	; (8001a54 <Vector120+0x54>)
 8001a2e:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8001a30:	6879      	ldr	r1, [r7, #4]
 8001a32:	4610      	mov	r0, r2
 8001a34:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001a36:	f000 ffab 	bl	8002990 <__dbg_check_leave_isr>
 8001a3a:	4804      	ldr	r0, [pc, #16]	; (8001a4c <Vector120+0x4c>)
 8001a3c:	f001 f960 	bl	8002d00 <__trace_isr_leave>
 8001a40:	f002 ff56 	bl	80048f0 <__port_irq_epilogue>
}
 8001a44:	bf00      	nop
 8001a46:	3708      	adds	r7, #8
 8001a48:	46bd      	mov	sp, r7
 8001a4a:	bd80      	pop	{r7, pc}
 8001a4c:	08004dd4 	.word	0x08004dd4
 8001a50:	40026400 	.word	0x40026400
 8001a54:	20000860 	.word	0x20000860
	...

08001a60 <Vector124>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8001a60:	b580      	push	{r7, lr}
 8001a62:	b082      	sub	sp, #8
 8001a64:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001a66:	4812      	ldr	r0, [pc, #72]	; (8001ab0 <Vector124+0x50>)
 8001a68:	f001 f90a 	bl	8002c80 <__trace_isr_enter>
 8001a6c:	f000 ff58 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 6U) & STM32_DMA_ISR_MASK;
 8001a70:	4b10      	ldr	r3, [pc, #64]	; (8001ab4 <Vector124+0x54>)
 8001a72:	681b      	ldr	r3, [r3, #0]
 8001a74:	099b      	lsrs	r3, r3, #6
 8001a76:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001a7a:	607b      	str	r3, [r7, #4]
  DMA2->LIFCR = flags << 6U;
 8001a7c:	4a0d      	ldr	r2, [pc, #52]	; (8001ab4 <Vector124+0x54>)
 8001a7e:	687b      	ldr	r3, [r7, #4]
 8001a80:	019b      	lsls	r3, r3, #6
 8001a82:	6093      	str	r3, [r2, #8]
  if (dma.streams[9].func)
 8001a84:	4b0c      	ldr	r3, [pc, #48]	; (8001ab8 <Vector124+0x58>)
 8001a86:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001a88:	2b00      	cmp	r3, #0
 8001a8a:	d006      	beq.n	8001a9a <Vector124+0x3a>
    dma.streams[9].func(dma.streams[9].param, flags);
 8001a8c:	4b0a      	ldr	r3, [pc, #40]	; (8001ab8 <Vector124+0x58>)
 8001a8e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001a90:	4a09      	ldr	r2, [pc, #36]	; (8001ab8 <Vector124+0x58>)
 8001a92:	6d12      	ldr	r2, [r2, #80]	; 0x50
 8001a94:	6879      	ldr	r1, [r7, #4]
 8001a96:	4610      	mov	r0, r2
 8001a98:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001a9a:	f000 ff79 	bl	8002990 <__dbg_check_leave_isr>
 8001a9e:	4804      	ldr	r0, [pc, #16]	; (8001ab0 <Vector124+0x50>)
 8001aa0:	f001 f92e 	bl	8002d00 <__trace_isr_leave>
 8001aa4:	f002 ff24 	bl	80048f0 <__port_irq_epilogue>
}
 8001aa8:	bf00      	nop
 8001aaa:	3708      	adds	r7, #8
 8001aac:	46bd      	mov	sp, r7
 8001aae:	bd80      	pop	{r7, pc}
 8001ab0:	08004de0 	.word	0x08004de0
 8001ab4:	40026400 	.word	0x40026400
 8001ab8:	20000860 	.word	0x20000860
 8001abc:	00000000 	.word	0x00000000

08001ac0 <Vector128>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8001ac0:	b580      	push	{r7, lr}
 8001ac2:	b082      	sub	sp, #8
 8001ac4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001ac6:	4812      	ldr	r0, [pc, #72]	; (8001b10 <Vector128+0x50>)
 8001ac8:	f001 f8da 	bl	8002c80 <__trace_isr_enter>
 8001acc:	f000 ff28 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 16U) & STM32_DMA_ISR_MASK;
 8001ad0:	4b10      	ldr	r3, [pc, #64]	; (8001b14 <Vector128+0x54>)
 8001ad2:	681b      	ldr	r3, [r3, #0]
 8001ad4:	0c1b      	lsrs	r3, r3, #16
 8001ad6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001ada:	607b      	str	r3, [r7, #4]
  DMA2->LIFCR = flags << 16U;
 8001adc:	4a0d      	ldr	r2, [pc, #52]	; (8001b14 <Vector128+0x54>)
 8001ade:	687b      	ldr	r3, [r7, #4]
 8001ae0:	041b      	lsls	r3, r3, #16
 8001ae2:	6093      	str	r3, [r2, #8]
  if (dma.streams[10].func)
 8001ae4:	4b0c      	ldr	r3, [pc, #48]	; (8001b18 <Vector128+0x58>)
 8001ae6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001ae8:	2b00      	cmp	r3, #0
 8001aea:	d006      	beq.n	8001afa <Vector128+0x3a>
    dma.streams[10].func(dma.streams[10].param, flags);
 8001aec:	4b0a      	ldr	r3, [pc, #40]	; (8001b18 <Vector128+0x58>)
 8001aee:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8001af0:	4a09      	ldr	r2, [pc, #36]	; (8001b18 <Vector128+0x58>)
 8001af2:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8001af4:	6879      	ldr	r1, [r7, #4]
 8001af6:	4610      	mov	r0, r2
 8001af8:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001afa:	f000 ff49 	bl	8002990 <__dbg_check_leave_isr>
 8001afe:	4804      	ldr	r0, [pc, #16]	; (8001b10 <Vector128+0x50>)
 8001b00:	f001 f8fe 	bl	8002d00 <__trace_isr_leave>
 8001b04:	f002 fef4 	bl	80048f0 <__port_irq_epilogue>
}
 8001b08:	bf00      	nop
 8001b0a:	3708      	adds	r7, #8
 8001b0c:	46bd      	mov	sp, r7
 8001b0e:	bd80      	pop	{r7, pc}
 8001b10:	08004dec 	.word	0x08004dec
 8001b14:	40026400 	.word	0x40026400
 8001b18:	20000860 	.word	0x20000860
 8001b1c:	00000000 	.word	0x00000000

08001b20 <Vector12C>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8001b20:	b580      	push	{r7, lr}
 8001b22:	b082      	sub	sp, #8
 8001b24:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001b26:	4812      	ldr	r0, [pc, #72]	; (8001b70 <Vector12C+0x50>)
 8001b28:	f001 f8aa 	bl	8002c80 <__trace_isr_enter>
 8001b2c:	f000 fef8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->LISR >> 22U) & STM32_DMA_ISR_MASK;
 8001b30:	4b10      	ldr	r3, [pc, #64]	; (8001b74 <Vector12C+0x54>)
 8001b32:	681b      	ldr	r3, [r3, #0]
 8001b34:	0d9b      	lsrs	r3, r3, #22
 8001b36:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001b3a:	607b      	str	r3, [r7, #4]
  DMA2->LIFCR = flags << 22U;
 8001b3c:	4a0d      	ldr	r2, [pc, #52]	; (8001b74 <Vector12C+0x54>)
 8001b3e:	687b      	ldr	r3, [r7, #4]
 8001b40:	059b      	lsls	r3, r3, #22
 8001b42:	6093      	str	r3, [r2, #8]
  if (dma.streams[11].func)
 8001b44:	4b0c      	ldr	r3, [pc, #48]	; (8001b78 <Vector12C+0x58>)
 8001b46:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001b48:	2b00      	cmp	r3, #0
 8001b4a:	d006      	beq.n	8001b5a <Vector12C+0x3a>
    dma.streams[11].func(dma.streams[11].param, flags);
 8001b4c:	4b0a      	ldr	r3, [pc, #40]	; (8001b78 <Vector12C+0x58>)
 8001b4e:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 8001b50:	4a09      	ldr	r2, [pc, #36]	; (8001b78 <Vector12C+0x58>)
 8001b52:	6e12      	ldr	r2, [r2, #96]	; 0x60
 8001b54:	6879      	ldr	r1, [r7, #4]
 8001b56:	4610      	mov	r0, r2
 8001b58:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001b5a:	f000 ff19 	bl	8002990 <__dbg_check_leave_isr>
 8001b5e:	4804      	ldr	r0, [pc, #16]	; (8001b70 <Vector12C+0x50>)
 8001b60:	f001 f8ce 	bl	8002d00 <__trace_isr_leave>
 8001b64:	f002 fec4 	bl	80048f0 <__port_irq_epilogue>
}
 8001b68:	bf00      	nop
 8001b6a:	3708      	adds	r7, #8
 8001b6c:	46bd      	mov	sp, r7
 8001b6e:	bd80      	pop	{r7, pc}
 8001b70:	08004df8 	.word	0x08004df8
 8001b74:	40026400 	.word	0x40026400
 8001b78:	20000860 	.word	0x20000860
 8001b7c:	00000000 	.word	0x00000000

08001b80 <Vector130>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8001b80:	b580      	push	{r7, lr}
 8001b82:	b082      	sub	sp, #8
 8001b84:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001b86:	4811      	ldr	r0, [pc, #68]	; (8001bcc <Vector130+0x4c>)
 8001b88:	f001 f87a 	bl	8002c80 <__trace_isr_enter>
 8001b8c:	f000 fec8 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 0U) & STM32_DMA_ISR_MASK;
 8001b90:	4b0f      	ldr	r3, [pc, #60]	; (8001bd0 <Vector130+0x50>)
 8001b92:	685b      	ldr	r3, [r3, #4]
 8001b94:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001b98:	607b      	str	r3, [r7, #4]
  DMA2->HIFCR = flags << 0U;
 8001b9a:	4a0d      	ldr	r2, [pc, #52]	; (8001bd0 <Vector130+0x50>)
 8001b9c:	687b      	ldr	r3, [r7, #4]
 8001b9e:	60d3      	str	r3, [r2, #12]
  if (dma.streams[12].func)
 8001ba0:	4b0c      	ldr	r3, [pc, #48]	; (8001bd4 <Vector130+0x54>)
 8001ba2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001ba4:	2b00      	cmp	r3, #0
 8001ba6:	d006      	beq.n	8001bb6 <Vector130+0x36>
    dma.streams[12].func(dma.streams[12].param, flags);
 8001ba8:	4b0a      	ldr	r3, [pc, #40]	; (8001bd4 <Vector130+0x54>)
 8001baa:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001bac:	4a09      	ldr	r2, [pc, #36]	; (8001bd4 <Vector130+0x54>)
 8001bae:	6e92      	ldr	r2, [r2, #104]	; 0x68
 8001bb0:	6879      	ldr	r1, [r7, #4]
 8001bb2:	4610      	mov	r0, r2
 8001bb4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001bb6:	f000 feeb 	bl	8002990 <__dbg_check_leave_isr>
 8001bba:	4804      	ldr	r0, [pc, #16]	; (8001bcc <Vector130+0x4c>)
 8001bbc:	f001 f8a0 	bl	8002d00 <__trace_isr_leave>
 8001bc0:	f002 fe96 	bl	80048f0 <__port_irq_epilogue>
}
 8001bc4:	bf00      	nop
 8001bc6:	3708      	adds	r7, #8
 8001bc8:	46bd      	mov	sp, r7
 8001bca:	bd80      	pop	{r7, pc}
 8001bcc:	08004e04 	.word	0x08004e04
 8001bd0:	40026400 	.word	0x40026400
 8001bd4:	20000860 	.word	0x20000860
	...

08001be0 <Vector150>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8001be0:	b580      	push	{r7, lr}
 8001be2:	b082      	sub	sp, #8
 8001be4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001be6:	4812      	ldr	r0, [pc, #72]	; (8001c30 <Vector150+0x50>)
 8001be8:	f001 f84a 	bl	8002c80 <__trace_isr_enter>
 8001bec:	f000 fe98 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 6U) & STM32_DMA_ISR_MASK;
 8001bf0:	4b10      	ldr	r3, [pc, #64]	; (8001c34 <Vector150+0x54>)
 8001bf2:	685b      	ldr	r3, [r3, #4]
 8001bf4:	099b      	lsrs	r3, r3, #6
 8001bf6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001bfa:	607b      	str	r3, [r7, #4]
  DMA2->HIFCR = flags << 6U;
 8001bfc:	4a0d      	ldr	r2, [pc, #52]	; (8001c34 <Vector150+0x54>)
 8001bfe:	687b      	ldr	r3, [r7, #4]
 8001c00:	019b      	lsls	r3, r3, #6
 8001c02:	60d3      	str	r3, [r2, #12]
  if (dma.streams[13].func)
 8001c04:	4b0c      	ldr	r3, [pc, #48]	; (8001c38 <Vector150+0x58>)
 8001c06:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001c08:	2b00      	cmp	r3, #0
 8001c0a:	d006      	beq.n	8001c1a <Vector150+0x3a>
    dma.streams[13].func(dma.streams[13].param, flags);
 8001c0c:	4b0a      	ldr	r3, [pc, #40]	; (8001c38 <Vector150+0x58>)
 8001c0e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001c10:	4a09      	ldr	r2, [pc, #36]	; (8001c38 <Vector150+0x58>)
 8001c12:	6f12      	ldr	r2, [r2, #112]	; 0x70
 8001c14:	6879      	ldr	r1, [r7, #4]
 8001c16:	4610      	mov	r0, r2
 8001c18:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001c1a:	f000 feb9 	bl	8002990 <__dbg_check_leave_isr>
 8001c1e:	4804      	ldr	r0, [pc, #16]	; (8001c30 <Vector150+0x50>)
 8001c20:	f001 f86e 	bl	8002d00 <__trace_isr_leave>
 8001c24:	f002 fe64 	bl	80048f0 <__port_irq_epilogue>
}
 8001c28:	bf00      	nop
 8001c2a:	3708      	adds	r7, #8
 8001c2c:	46bd      	mov	sp, r7
 8001c2e:	bd80      	pop	{r7, pc}
 8001c30:	08004e10 	.word	0x08004e10
 8001c34:	40026400 	.word	0x40026400
 8001c38:	20000860 	.word	0x20000860
 8001c3c:	00000000 	.word	0x00000000

08001c40 <Vector154>:
/**
 * @brief   DMA2 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8001c40:	b580      	push	{r7, lr}
 8001c42:	b082      	sub	sp, #8
 8001c44:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001c46:	4812      	ldr	r0, [pc, #72]	; (8001c90 <Vector154+0x50>)
 8001c48:	f001 f81a 	bl	8002c80 <__trace_isr_enter>
 8001c4c:	f000 fe68 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 16U) & STM32_DMA_ISR_MASK;
 8001c50:	4b10      	ldr	r3, [pc, #64]	; (8001c94 <Vector154+0x54>)
 8001c52:	685b      	ldr	r3, [r3, #4]
 8001c54:	0c1b      	lsrs	r3, r3, #16
 8001c56:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001c5a:	607b      	str	r3, [r7, #4]
  DMA2->HIFCR = flags << 16U;
 8001c5c:	4a0d      	ldr	r2, [pc, #52]	; (8001c94 <Vector154+0x54>)
 8001c5e:	687b      	ldr	r3, [r7, #4]
 8001c60:	041b      	lsls	r3, r3, #16
 8001c62:	60d3      	str	r3, [r2, #12]
  if (dma.streams[14].func)
 8001c64:	4b0c      	ldr	r3, [pc, #48]	; (8001c98 <Vector154+0x58>)
 8001c66:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	d006      	beq.n	8001c7a <Vector154+0x3a>
    dma.streams[14].func(dma.streams[14].param, flags);
 8001c6c:	4b0a      	ldr	r3, [pc, #40]	; (8001c98 <Vector154+0x58>)
 8001c6e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001c70:	4a09      	ldr	r2, [pc, #36]	; (8001c98 <Vector154+0x58>)
 8001c72:	6f92      	ldr	r2, [r2, #120]	; 0x78
 8001c74:	6879      	ldr	r1, [r7, #4]
 8001c76:	4610      	mov	r0, r2
 8001c78:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001c7a:	f000 fe89 	bl	8002990 <__dbg_check_leave_isr>
 8001c7e:	4804      	ldr	r0, [pc, #16]	; (8001c90 <Vector154+0x50>)
 8001c80:	f001 f83e 	bl	8002d00 <__trace_isr_leave>
 8001c84:	f002 fe34 	bl	80048f0 <__port_irq_epilogue>
}
 8001c88:	bf00      	nop
 8001c8a:	3708      	adds	r7, #8
 8001c8c:	46bd      	mov	sp, r7
 8001c8e:	bd80      	pop	{r7, pc}
 8001c90:	08004e1c 	.word	0x08004e1c
 8001c94:	40026400 	.word	0x40026400
 8001c98:	20000860 	.word	0x20000860
 8001c9c:	00000000 	.word	0x00000000

08001ca0 <Vector158>:
/**
 * @brief   DMA2 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8001ca0:	b580      	push	{r7, lr}
 8001ca2:	b082      	sub	sp, #8
 8001ca4:	af00      	add	r7, sp, #0
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();
 8001ca6:	4813      	ldr	r0, [pc, #76]	; (8001cf4 <Vector158+0x54>)
 8001ca8:	f000 ffea 	bl	8002c80 <__trace_isr_enter>
 8001cac:	f000 fe38 	bl	8002920 <__dbg_check_enter_isr>

  flags = (DMA2->HISR >> 22U) & STM32_DMA_ISR_MASK;
 8001cb0:	4b11      	ldr	r3, [pc, #68]	; (8001cf8 <Vector158+0x58>)
 8001cb2:	685b      	ldr	r3, [r3, #4]
 8001cb4:	0d9b      	lsrs	r3, r3, #22
 8001cb6:	f003 033d 	and.w	r3, r3, #61	; 0x3d
 8001cba:	607b      	str	r3, [r7, #4]
  DMA2->HIFCR = flags << 22U;
 8001cbc:	4a0e      	ldr	r2, [pc, #56]	; (8001cf8 <Vector158+0x58>)
 8001cbe:	687b      	ldr	r3, [r7, #4]
 8001cc0:	059b      	lsls	r3, r3, #22
 8001cc2:	60d3      	str	r3, [r2, #12]
  if (dma.streams[15].func)
 8001cc4:	4b0d      	ldr	r3, [pc, #52]	; (8001cfc <Vector158+0x5c>)
 8001cc6:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001cc8:	2b00      	cmp	r3, #0
 8001cca:	d007      	beq.n	8001cdc <Vector158+0x3c>
    dma.streams[15].func(dma.streams[15].param, flags);
 8001ccc:	4b0b      	ldr	r3, [pc, #44]	; (8001cfc <Vector158+0x5c>)
 8001cce:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 8001cd0:	4a0a      	ldr	r2, [pc, #40]	; (8001cfc <Vector158+0x5c>)
 8001cd2:	f8d2 2080 	ldr.w	r2, [r2, #128]	; 0x80
 8001cd6:	6879      	ldr	r1, [r7, #4]
 8001cd8:	4610      	mov	r0, r2
 8001cda:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
 8001cdc:	f000 fe58 	bl	8002990 <__dbg_check_leave_isr>
 8001ce0:	4804      	ldr	r0, [pc, #16]	; (8001cf4 <Vector158+0x54>)
 8001ce2:	f001 f80d 	bl	8002d00 <__trace_isr_leave>
 8001ce6:	f002 fe03 	bl	80048f0 <__port_irq_epilogue>
}
 8001cea:	bf00      	nop
 8001cec:	3708      	adds	r7, #8
 8001cee:	46bd      	mov	sp, r7
 8001cf0:	bd80      	pop	{r7, pc}
 8001cf2:	bf00      	nop
 8001cf4:	08004e28 	.word	0x08004e28
 8001cf8:	40026400 	.word	0x40026400
 8001cfc:	20000860 	.word	0x20000860

08001d00 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8001d00:	b480      	push	{r7}
 8001d02:	b083      	sub	sp, #12
 8001d04:	af00      	add	r7, sp, #0
  unsigned i;

  dma.allocated_mask = 0U;
 8001d06:	4b18      	ldr	r3, [pc, #96]	; (8001d68 <dmaInit+0x68>)
 8001d08:	2200      	movs	r2, #0
 8001d0a:	601a      	str	r2, [r3, #0]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001d0c:	2300      	movs	r3, #0
 8001d0e:	607b      	str	r3, [r7, #4]
 8001d10:	e012      	b.n	8001d38 <dmaInit+0x38>
    _stm32_dma_streams[i].stream->CR = STM32_DMA_CR_RESET_VALUE;
 8001d12:	4916      	ldr	r1, [pc, #88]	; (8001d6c <dmaInit+0x6c>)
 8001d14:	687a      	ldr	r2, [r7, #4]
 8001d16:	4613      	mov	r3, r2
 8001d18:	005b      	lsls	r3, r3, #1
 8001d1a:	4413      	add	r3, r2
 8001d1c:	009b      	lsls	r3, r3, #2
 8001d1e:	440b      	add	r3, r1
 8001d20:	681b      	ldr	r3, [r3, #0]
 8001d22:	2200      	movs	r2, #0
 8001d24:	601a      	str	r2, [r3, #0]
    dma.streams[i].func = NULL;
 8001d26:	4a10      	ldr	r2, [pc, #64]	; (8001d68 <dmaInit+0x68>)
 8001d28:	687b      	ldr	r3, [r7, #4]
 8001d2a:	00db      	lsls	r3, r3, #3
 8001d2c:	4413      	add	r3, r2
 8001d2e:	2200      	movs	r2, #0
 8001d30:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < STM32_DMA_STREAMS; i++) {
 8001d32:	687b      	ldr	r3, [r7, #4]
 8001d34:	3301      	adds	r3, #1
 8001d36:	607b      	str	r3, [r7, #4]
 8001d38:	687b      	ldr	r3, [r7, #4]
 8001d3a:	2b0f      	cmp	r3, #15
 8001d3c:	d9e9      	bls.n	8001d12 <dmaInit+0x12>
  }
  DMA1->LIFCR = 0xFFFFFFFFU;
 8001d3e:	4b0c      	ldr	r3, [pc, #48]	; (8001d70 <dmaInit+0x70>)
 8001d40:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001d44:	609a      	str	r2, [r3, #8]
  DMA1->HIFCR = 0xFFFFFFFFU;
 8001d46:	4b0a      	ldr	r3, [pc, #40]	; (8001d70 <dmaInit+0x70>)
 8001d48:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001d4c:	60da      	str	r2, [r3, #12]
  DMA2->LIFCR = 0xFFFFFFFFU;
 8001d4e:	4b09      	ldr	r3, [pc, #36]	; (8001d74 <dmaInit+0x74>)
 8001d50:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001d54:	609a      	str	r2, [r3, #8]
  DMA2->HIFCR = 0xFFFFFFFFU;
 8001d56:	4b07      	ldr	r3, [pc, #28]	; (8001d74 <dmaInit+0x74>)
 8001d58:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001d5c:	60da      	str	r2, [r3, #12]
}
 8001d5e:	bf00      	nop
 8001d60:	370c      	adds	r7, #12
 8001d62:	46bd      	mov	sp, r7
 8001d64:	bc80      	pop	{r7}
 8001d66:	4770      	bx	lr
 8001d68:	20000860 	.word	0x20000860
 8001d6c:	08004cb4 	.word	0x08004cb4
 8001d70:	40026000 	.word	0x40026000
 8001d74:	40026400 	.word	0x40026400
	...

08001d80 <dmaStreamAllocI>:
 * @iclass
 */
const stm32_dma_stream_t *dmaStreamAllocI(uint32_t id,
                                          uint32_t priority,
                                          stm32_dmaisr_t func,
                                          void *param) {
 8001d80:	b580      	push	{r7, lr}
 8001d82:	b08a      	sub	sp, #40	; 0x28
 8001d84:	af00      	add	r7, sp, #0
 8001d86:	60f8      	str	r0, [r7, #12]
 8001d88:	60b9      	str	r1, [r7, #8]
 8001d8a:	607a      	str	r2, [r7, #4]
 8001d8c:	603b      	str	r3, [r7, #0]
  uint32_t i, startid, endid;

  osalDbgCheckClassI();
 8001d8e:	f000 fe3f 	bl	8002a10 <chDbgCheckClassI>

  if (id < STM32_DMA_STREAMS) {
 8001d92:	68fb      	ldr	r3, [r7, #12]
 8001d94:	2b0f      	cmp	r3, #15
 8001d96:	d806      	bhi.n	8001da6 <dmaStreamAllocI+0x26>
    startid = id;
 8001d98:	68fb      	ldr	r3, [r7, #12]
 8001d9a:	623b      	str	r3, [r7, #32]
    endid   = id;
 8001d9c:	68fb      	ldr	r3, [r7, #12]
 8001d9e:	61fb      	str	r3, [r7, #28]
  else {
    osalDbgCheck(false);
    return NULL;
  }

  for (i = startid; i <= endid; i++) {
 8001da0:	6a3b      	ldr	r3, [r7, #32]
 8001da2:	627b      	str	r3, [r7, #36]	; 0x24
 8001da4:	e07c      	b.n	8001ea0 <dmaStreamAllocI+0x120>
    osalDbgCheck(false);
 8001da6:	4843      	ldr	r0, [pc, #268]	; (8001eb4 <dmaStreamAllocI+0x134>)
 8001da8:	f000 fcc2 	bl	8002730 <chSysHalt>
    return NULL;
 8001dac:	2300      	movs	r3, #0
 8001dae:	e07c      	b.n	8001eaa <dmaStreamAllocI+0x12a>
    uint32_t mask = (1U << i);
 8001db0:	2201      	movs	r2, #1
 8001db2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001db4:	fa02 f303 	lsl.w	r3, r2, r3
 8001db8:	61bb      	str	r3, [r7, #24]
    if ((dma.allocated_mask & mask) == 0U) {
 8001dba:	4b3f      	ldr	r3, [pc, #252]	; (8001eb8 <dmaStreamAllocI+0x138>)
 8001dbc:	681a      	ldr	r2, [r3, #0]
 8001dbe:	69bb      	ldr	r3, [r7, #24]
 8001dc0:	4013      	ands	r3, r2
 8001dc2:	2b00      	cmp	r3, #0
 8001dc4:	d169      	bne.n	8001e9a <dmaStreamAllocI+0x11a>
      const stm32_dma_stream_t *dmastp = STM32_DMA_STREAM(i);
 8001dc6:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001dc8:	4613      	mov	r3, r2
 8001dca:	005b      	lsls	r3, r3, #1
 8001dcc:	4413      	add	r3, r2
 8001dce:	009b      	lsls	r3, r3, #2
 8001dd0:	4a3a      	ldr	r2, [pc, #232]	; (8001ebc <dmaStreamAllocI+0x13c>)
 8001dd2:	4413      	add	r3, r2
 8001dd4:	617b      	str	r3, [r7, #20]

      /* Installs the DMA handler.*/
      dma.streams[i].func  = func;
 8001dd6:	4a38      	ldr	r2, [pc, #224]	; (8001eb8 <dmaStreamAllocI+0x138>)
 8001dd8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001dda:	00db      	lsls	r3, r3, #3
 8001ddc:	4413      	add	r3, r2
 8001dde:	687a      	ldr	r2, [r7, #4]
 8001de0:	605a      	str	r2, [r3, #4]
      dma.streams[i].param = param;
 8001de2:	4a35      	ldr	r2, [pc, #212]	; (8001eb8 <dmaStreamAllocI+0x138>)
 8001de4:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001de6:	00db      	lsls	r3, r3, #3
 8001de8:	4413      	add	r3, r2
 8001dea:	683a      	ldr	r2, [r7, #0]
 8001dec:	609a      	str	r2, [r3, #8]
      dma.allocated_mask  |= mask;
 8001dee:	4b32      	ldr	r3, [pc, #200]	; (8001eb8 <dmaStreamAllocI+0x138>)
 8001df0:	681a      	ldr	r2, [r3, #0]
 8001df2:	69bb      	ldr	r3, [r7, #24]
 8001df4:	4313      	orrs	r3, r2
 8001df6:	4a30      	ldr	r2, [pc, #192]	; (8001eb8 <dmaStreamAllocI+0x138>)
 8001df8:	6013      	str	r3, [r2, #0]

      /* Enabling DMA clocks required by the current streams set.*/
      if ((STM32_DMA1_STREAMS_MASK & mask) != 0U) {
 8001dfa:	69bb      	ldr	r3, [r7, #24]
 8001dfc:	b2db      	uxtb	r3, r3
 8001dfe:	2b00      	cmp	r3, #0
 8001e00:	d00d      	beq.n	8001e1e <dmaStreamAllocI+0x9e>
        rccEnableDMA1(true);
 8001e02:	4b2f      	ldr	r3, [pc, #188]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e04:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001e06:	4a2e      	ldr	r2, [pc, #184]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e08:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001e0c:	6313      	str	r3, [r2, #48]	; 0x30
 8001e0e:	4b2c      	ldr	r3, [pc, #176]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e10:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001e12:	4a2b      	ldr	r2, [pc, #172]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e14:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 8001e18:	6513      	str	r3, [r2, #80]	; 0x50
 8001e1a:	4b29      	ldr	r3, [pc, #164]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e1c:	6d1b      	ldr	r3, [r3, #80]	; 0x50
      }
      if ((STM32_DMA2_STREAMS_MASK & mask) != 0U) {
 8001e1e:	69bb      	ldr	r3, [r7, #24]
 8001e20:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8001e24:	2b00      	cmp	r3, #0
 8001e26:	d00d      	beq.n	8001e44 <dmaStreamAllocI+0xc4>
        rccEnableDMA2(true);
 8001e28:	4b25      	ldr	r3, [pc, #148]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e2a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001e2c:	4a24      	ldr	r2, [pc, #144]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e2e:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001e32:	6313      	str	r3, [r2, #48]	; 0x30
 8001e34:	4b22      	ldr	r3, [pc, #136]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e36:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001e38:	4a21      	ldr	r2, [pc, #132]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e3a:	f443 0380 	orr.w	r3, r3, #4194304	; 0x400000
 8001e3e:	6513      	str	r3, [r2, #80]	; 0x50
 8001e40:	4b1f      	ldr	r3, [pc, #124]	; (8001ec0 <dmaStreamAllocI+0x140>)
 8001e42:	6d1b      	ldr	r3, [r3, #80]	; 0x50
        rccEnableDMAMUX(true);
      }
#endif

      /* Putting the stream in a safe state.*/
      dmaStreamDisable(dmastp);
 8001e44:	697b      	ldr	r3, [r7, #20]
 8001e46:	681b      	ldr	r3, [r3, #0]
 8001e48:	681a      	ldr	r2, [r3, #0]
 8001e4a:	697b      	ldr	r3, [r7, #20]
 8001e4c:	681b      	ldr	r3, [r3, #0]
 8001e4e:	f022 021f 	bic.w	r2, r2, #31
 8001e52:	601a      	str	r2, [r3, #0]
 8001e54:	bf00      	nop
 8001e56:	697b      	ldr	r3, [r7, #20]
 8001e58:	681b      	ldr	r3, [r3, #0]
 8001e5a:	681b      	ldr	r3, [r3, #0]
 8001e5c:	f003 0301 	and.w	r3, r3, #1
 8001e60:	2b00      	cmp	r3, #0
 8001e62:	d1f8      	bne.n	8001e56 <dmaStreamAllocI+0xd6>
 8001e64:	697b      	ldr	r3, [r7, #20]
 8001e66:	7a5b      	ldrb	r3, [r3, #9]
 8001e68:	4619      	mov	r1, r3
 8001e6a:	697b      	ldr	r3, [r7, #20]
 8001e6c:	685b      	ldr	r3, [r3, #4]
 8001e6e:	223d      	movs	r2, #61	; 0x3d
 8001e70:	408a      	lsls	r2, r1
 8001e72:	601a      	str	r2, [r3, #0]
      dmastp->stream->CR = STM32_DMA_CR_RESET_VALUE;
 8001e74:	697b      	ldr	r3, [r7, #20]
 8001e76:	681b      	ldr	r3, [r3, #0]
 8001e78:	2200      	movs	r2, #0
 8001e7a:	601a      	str	r2, [r3, #0]
      dmastp->stream->FCR = STM32_DMA_FCR_RESET_VALUE;
 8001e7c:	697b      	ldr	r3, [r7, #20]
 8001e7e:	681b      	ldr	r3, [r3, #0]
 8001e80:	2221      	movs	r2, #33	; 0x21
 8001e82:	615a      	str	r2, [r3, #20]

      /* Enables the associated IRQ vector if a callback is defined.*/
      if (func != NULL) {
 8001e84:	687b      	ldr	r3, [r7, #4]
 8001e86:	2b00      	cmp	r3, #0
 8001e88:	d005      	beq.n	8001e96 <dmaStreamAllocI+0x116>
        nvicEnableVector(dmastp->vector, priority);
 8001e8a:	697b      	ldr	r3, [r7, #20]
 8001e8c:	7adb      	ldrb	r3, [r3, #11]
 8001e8e:	68b9      	ldr	r1, [r7, #8]
 8001e90:	4618      	mov	r0, r3
 8001e92:	f7fe fe55 	bl	8000b40 <nvicEnableVector>
      }

      return dmastp;
 8001e96:	697b      	ldr	r3, [r7, #20]
 8001e98:	e007      	b.n	8001eaa <dmaStreamAllocI+0x12a>
  for (i = startid; i <= endid; i++) {
 8001e9a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001e9c:	3301      	adds	r3, #1
 8001e9e:	627b      	str	r3, [r7, #36]	; 0x24
 8001ea0:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8001ea2:	69fb      	ldr	r3, [r7, #28]
 8001ea4:	429a      	cmp	r2, r3
 8001ea6:	d983      	bls.n	8001db0 <dmaStreamAllocI+0x30>
    }
  }

  return NULL;
 8001ea8:	2300      	movs	r3, #0
}
 8001eaa:	4618      	mov	r0, r3
 8001eac:	3728      	adds	r7, #40	; 0x28
 8001eae:	46bd      	mov	sp, r7
 8001eb0:	bd80      	pop	{r7, pc}
 8001eb2:	bf00      	nop
 8001eb4:	08004e34 	.word	0x08004e34
 8001eb8:	20000860 	.word	0x20000860
 8001ebc:	08004cb4 	.word	0x08004cb4
 8001ec0:	40023800 	.word	0x40023800
	...

08001ed0 <dmaStreamFreeI>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @iclass
 */
void dmaStreamFreeI(const stm32_dma_stream_t *dmastp) {
 8001ed0:	b580      	push	{r7, lr}
 8001ed2:	b082      	sub	sp, #8
 8001ed4:	af00      	add	r7, sp, #0
 8001ed6:	6078      	str	r0, [r7, #4]

  osalDbgCheck(dmastp != NULL);
 8001ed8:	687b      	ldr	r3, [r7, #4]
 8001eda:	2b00      	cmp	r3, #0
 8001edc:	bf0c      	ite	eq
 8001ede:	2301      	moveq	r3, #1
 8001ee0:	2300      	movne	r3, #0
 8001ee2:	b2db      	uxtb	r3, r3
 8001ee4:	2b00      	cmp	r3, #0
 8001ee6:	d002      	beq.n	8001eee <dmaStreamFreeI+0x1e>
 8001ee8:	4827      	ldr	r0, [pc, #156]	; (8001f88 <dmaStreamFreeI+0xb8>)
 8001eea:	f000 fc21 	bl	8002730 <chSysHalt>

  /* Check if the streams is not taken.*/
  osalDbgAssert((dma.allocated_mask & (1U << dmastp->selfindex)) != 0U,
 8001eee:	4b27      	ldr	r3, [pc, #156]	; (8001f8c <dmaStreamFreeI+0xbc>)
 8001ef0:	681a      	ldr	r2, [r3, #0]
 8001ef2:	687b      	ldr	r3, [r7, #4]
 8001ef4:	7a9b      	ldrb	r3, [r3, #10]
 8001ef6:	4619      	mov	r1, r3
 8001ef8:	2301      	movs	r3, #1
 8001efa:	408b      	lsls	r3, r1
 8001efc:	4013      	ands	r3, r2
 8001efe:	2b00      	cmp	r3, #0
 8001f00:	bf0c      	ite	eq
 8001f02:	2301      	moveq	r3, #1
 8001f04:	2300      	movne	r3, #0
 8001f06:	b2db      	uxtb	r3, r3
 8001f08:	2b00      	cmp	r3, #0
 8001f0a:	d002      	beq.n	8001f12 <dmaStreamFreeI+0x42>
 8001f0c:	481e      	ldr	r0, [pc, #120]	; (8001f88 <dmaStreamFreeI+0xb8>)
 8001f0e:	f000 fc0f 	bl	8002730 <chSysHalt>
                "not allocated");

  /* Disables the associated IRQ vector.*/
  nvicDisableVector(dmastp->vector);
 8001f12:	687b      	ldr	r3, [r7, #4]
 8001f14:	7adb      	ldrb	r3, [r3, #11]
 8001f16:	4618      	mov	r0, r3
 8001f18:	f7fe fe42 	bl	8000ba0 <nvicDisableVector>

  /* Marks the stream as not allocated.*/
  dma.allocated_mask &= ~(1U << dmastp->selfindex);
 8001f1c:	4b1b      	ldr	r3, [pc, #108]	; (8001f8c <dmaStreamFreeI+0xbc>)
 8001f1e:	681a      	ldr	r2, [r3, #0]
 8001f20:	687b      	ldr	r3, [r7, #4]
 8001f22:	7a9b      	ldrb	r3, [r3, #10]
 8001f24:	4619      	mov	r1, r3
 8001f26:	2301      	movs	r3, #1
 8001f28:	408b      	lsls	r3, r1
 8001f2a:	43db      	mvns	r3, r3
 8001f2c:	4013      	ands	r3, r2
 8001f2e:	4a17      	ldr	r2, [pc, #92]	; (8001f8c <dmaStreamFreeI+0xbc>)
 8001f30:	6013      	str	r3, [r2, #0]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma.allocated_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8001f32:	4b16      	ldr	r3, [pc, #88]	; (8001f8c <dmaStreamFreeI+0xbc>)
 8001f34:	681b      	ldr	r3, [r3, #0]
 8001f36:	b2db      	uxtb	r3, r3
 8001f38:	2b00      	cmp	r3, #0
 8001f3a:	d10d      	bne.n	8001f58 <dmaStreamFreeI+0x88>
    rccDisableDMA1();
 8001f3c:	4b14      	ldr	r3, [pc, #80]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f3e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f40:	4a13      	ldr	r2, [pc, #76]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f42:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001f46:	6313      	str	r3, [r2, #48]	; 0x30
 8001f48:	4b11      	ldr	r3, [pc, #68]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f4a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001f4c:	4a10      	ldr	r2, [pc, #64]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f4e:	f423 1300 	bic.w	r3, r3, #2097152	; 0x200000
 8001f52:	6513      	str	r3, [r2, #80]	; 0x50
 8001f54:	4b0e      	ldr	r3, [pc, #56]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f56:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  }
  if ((dma.allocated_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8001f58:	4b0c      	ldr	r3, [pc, #48]	; (8001f8c <dmaStreamFreeI+0xbc>)
 8001f5a:	681b      	ldr	r3, [r3, #0]
 8001f5c:	f403 437f 	and.w	r3, r3, #65280	; 0xff00
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d10d      	bne.n	8001f80 <dmaStreamFreeI+0xb0>
    rccDisableDMA2();
 8001f64:	4b0a      	ldr	r3, [pc, #40]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f66:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001f68:	4a09      	ldr	r2, [pc, #36]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f6a:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001f6e:	6313      	str	r3, [r2, #48]	; 0x30
 8001f70:	4b07      	ldr	r3, [pc, #28]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f72:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001f74:	4a06      	ldr	r2, [pc, #24]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f76:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 8001f7a:	6513      	str	r3, [r2, #80]	; 0x50
 8001f7c:	4b04      	ldr	r3, [pc, #16]	; (8001f90 <dmaStreamFreeI+0xc0>)
 8001f7e:	6d1b      	ldr	r3, [r3, #80]	; 0x50
  /* Shutting down DMAMUX if present.*/
  if (dma.allocated_mask == 0U) {
    rccDisableDMAMUX();
  }
#endif
}
 8001f80:	bf00      	nop
 8001f82:	3708      	adds	r7, #8
 8001f84:	46bd      	mov	sp, r7
 8001f86:	bd80      	pop	{r7, pc}
 8001f88:	08004e44 	.word	0x08004e44
 8001f8c:	20000860 	.word	0x20000860
 8001f90:	40023800 	.word	0x40023800
	...

08001fa0 <_pal_lld_init>:
/**
 * @brief   PAL driver initialization.
 *
 * @notapi
 */
void _pal_lld_init(void) {
 8001fa0:	b480      	push	{r7}
 8001fa2:	af00      	add	r7, sp, #0

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001fa4:	bf00      	nop
 8001fa6:	46bd      	mov	sp, r7
 8001fa8:	bc80      	pop	{r7}
 8001faa:	4770      	bx	lr
 8001fac:	0000      	movs	r0, r0
	...

08001fb0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001fb0:	b480      	push	{r7}
 8001fb2:	b08f      	sub	sp, #60	; 0x3c
 8001fb4:	af00      	add	r7, sp, #0
 8001fb6:	60f8      	str	r0, [r7, #12]
 8001fb8:	60b9      	str	r1, [r7, #8]
 8001fba:	607a      	str	r2, [r7, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001fbc:	687b      	ldr	r3, [r7, #4]
 8001fbe:	f003 0303 	and.w	r3, r3, #3
 8001fc2:	637b      	str	r3, [r7, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001fc4:	687b      	ldr	r3, [r7, #4]
 8001fc6:	089b      	lsrs	r3, r3, #2
 8001fc8:	f003 0301 	and.w	r3, r3, #1
 8001fcc:	633b      	str	r3, [r7, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 8001fce:	687b      	ldr	r3, [r7, #4]
 8001fd0:	08db      	lsrs	r3, r3, #3
 8001fd2:	f003 0303 	and.w	r3, r3, #3
 8001fd6:	62fb      	str	r3, [r7, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001fd8:	687b      	ldr	r3, [r7, #4]
 8001fda:	095b      	lsrs	r3, r3, #5
 8001fdc:	f003 0303 	and.w	r3, r3, #3
 8001fe0:	62bb      	str	r3, [r7, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 8001fe2:	687b      	ldr	r3, [r7, #4]
 8001fe4:	09db      	lsrs	r3, r3, #7
 8001fe6:	f003 030f 	and.w	r3, r3, #15
 8001fea:	623b      	str	r3, [r7, #32]
  uint32_t bit     = 0;
 8001fec:	2300      	movs	r3, #0
 8001fee:	627b      	str	r3, [r7, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 8001ff0:	68bb      	ldr	r3, [r7, #8]
 8001ff2:	f003 0301 	and.w	r3, r3, #1
 8001ff6:	2b00      	cmp	r3, #0
 8001ff8:	d079      	beq.n	80020ee <_pal_lld_setgroupmode+0x13e>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8001ffa:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8001ffc:	f003 0307 	and.w	r3, r3, #7
 8002000:	009b      	lsls	r3, r3, #2
 8002002:	6a3a      	ldr	r2, [r7, #32]
 8002004:	fa02 f303 	lsl.w	r3, r2, r3
 8002008:	61fb      	str	r3, [r7, #28]
      m1 = 1 << bit;
 800200a:	2201      	movs	r2, #1
 800200c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 800200e:	fa02 f303 	lsl.w	r3, r2, r3
 8002012:	61bb      	str	r3, [r7, #24]
      m2 = 3 << (bit * 2);
 8002014:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002016:	005b      	lsls	r3, r3, #1
 8002018:	2203      	movs	r2, #3
 800201a:	fa02 f303 	lsl.w	r3, r2, r3
 800201e:	617b      	str	r3, [r7, #20]
      m4 = 15 << ((bit & 7) * 4);
 8002020:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002022:	f003 0307 	and.w	r3, r3, #7
 8002026:	009b      	lsls	r3, r3, #2
 8002028:	220f      	movs	r2, #15
 800202a:	fa02 f303 	lsl.w	r3, r2, r3
 800202e:	613b      	str	r3, [r7, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8002030:	68fb      	ldr	r3, [r7, #12]
 8002032:	685a      	ldr	r2, [r3, #4]
 8002034:	69bb      	ldr	r3, [r7, #24]
 8002036:	43db      	mvns	r3, r3
 8002038:	401a      	ands	r2, r3
 800203a:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 800203c:	431a      	orrs	r2, r3
 800203e:	68fb      	ldr	r3, [r7, #12]
 8002040:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8002042:	68fb      	ldr	r3, [r7, #12]
 8002044:	689a      	ldr	r2, [r3, #8]
 8002046:	697b      	ldr	r3, [r7, #20]
 8002048:	43db      	mvns	r3, r3
 800204a:	401a      	ands	r2, r3
 800204c:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 800204e:	431a      	orrs	r2, r3
 8002050:	68fb      	ldr	r3, [r7, #12]
 8002052:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8002054:	68fb      	ldr	r3, [r7, #12]
 8002056:	68da      	ldr	r2, [r3, #12]
 8002058:	697b      	ldr	r3, [r7, #20]
 800205a:	43db      	mvns	r3, r3
 800205c:	401a      	ands	r2, r3
 800205e:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002060:	431a      	orrs	r2, r3
 8002062:	68fb      	ldr	r3, [r7, #12]
 8002064:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8002066:	687b      	ldr	r3, [r7, #4]
 8002068:	f003 0303 	and.w	r3, r3, #3
 800206c:	2b02      	cmp	r3, #2
 800206e:	d11f      	bne.n	80020b0 <_pal_lld_setgroupmode+0x100>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8002070:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002072:	2b07      	cmp	r3, #7
 8002074:	d809      	bhi.n	800208a <_pal_lld_setgroupmode+0xda>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8002076:	68fb      	ldr	r3, [r7, #12]
 8002078:	6a1a      	ldr	r2, [r3, #32]
 800207a:	693b      	ldr	r3, [r7, #16]
 800207c:	43db      	mvns	r3, r3
 800207e:	401a      	ands	r2, r3
 8002080:	69fb      	ldr	r3, [r7, #28]
 8002082:	431a      	orrs	r2, r3
 8002084:	68fb      	ldr	r3, [r7, #12]
 8002086:	621a      	str	r2, [r3, #32]
 8002088:	e008      	b.n	800209c <_pal_lld_setgroupmode+0xec>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800208a:	68fb      	ldr	r3, [r7, #12]
 800208c:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800208e:	693b      	ldr	r3, [r7, #16]
 8002090:	43db      	mvns	r3, r3
 8002092:	401a      	ands	r2, r3
 8002094:	69fb      	ldr	r3, [r7, #28]
 8002096:	431a      	orrs	r2, r3
 8002098:	68fb      	ldr	r3, [r7, #12]
 800209a:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 800209c:	68fb      	ldr	r3, [r7, #12]
 800209e:	681a      	ldr	r2, [r3, #0]
 80020a0:	697b      	ldr	r3, [r7, #20]
 80020a2:	43db      	mvns	r3, r3
 80020a4:	401a      	ands	r2, r3
 80020a6:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80020a8:	431a      	orrs	r2, r3
 80020aa:	68fb      	ldr	r3, [r7, #12]
 80020ac:	601a      	str	r2, [r3, #0]
 80020ae:	e01e      	b.n	80020ee <_pal_lld_setgroupmode+0x13e>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80020b0:	68fb      	ldr	r3, [r7, #12]
 80020b2:	681a      	ldr	r2, [r3, #0]
 80020b4:	697b      	ldr	r3, [r7, #20]
 80020b6:	43db      	mvns	r3, r3
 80020b8:	401a      	ands	r2, r3
 80020ba:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 80020bc:	431a      	orrs	r2, r3
 80020be:	68fb      	ldr	r3, [r7, #12]
 80020c0:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 80020c2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80020c4:	2b07      	cmp	r3, #7
 80020c6:	d809      	bhi.n	80020dc <_pal_lld_setgroupmode+0x12c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80020c8:	68fb      	ldr	r3, [r7, #12]
 80020ca:	6a1a      	ldr	r2, [r3, #32]
 80020cc:	693b      	ldr	r3, [r7, #16]
 80020ce:	43db      	mvns	r3, r3
 80020d0:	401a      	ands	r2, r3
 80020d2:	69fb      	ldr	r3, [r7, #28]
 80020d4:	431a      	orrs	r2, r3
 80020d6:	68fb      	ldr	r3, [r7, #12]
 80020d8:	621a      	str	r2, [r3, #32]
 80020da:	e008      	b.n	80020ee <_pal_lld_setgroupmode+0x13e>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80020dc:	68fb      	ldr	r3, [r7, #12]
 80020de:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80020e0:	693b      	ldr	r3, [r7, #16]
 80020e2:	43db      	mvns	r3, r3
 80020e4:	401a      	ands	r2, r3
 80020e6:	69fb      	ldr	r3, [r7, #28]
 80020e8:	431a      	orrs	r2, r3
 80020ea:	68fb      	ldr	r3, [r7, #12]
 80020ec:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 80020ee:	68bb      	ldr	r3, [r7, #8]
 80020f0:	085b      	lsrs	r3, r3, #1
 80020f2:	60bb      	str	r3, [r7, #8]
    if (!mask)
 80020f4:	68bb      	ldr	r3, [r7, #8]
 80020f6:	2b00      	cmp	r3, #0
 80020f8:	d00f      	beq.n	800211a <_pal_lld_setgroupmode+0x16a>
      return;
    otyper <<= 1;
 80020fa:	6b3b      	ldr	r3, [r7, #48]	; 0x30
 80020fc:	005b      	lsls	r3, r3, #1
 80020fe:	633b      	str	r3, [r7, #48]	; 0x30
    ospeedr <<= 2;
 8002100:	6afb      	ldr	r3, [r7, #44]	; 0x2c
 8002102:	009b      	lsls	r3, r3, #2
 8002104:	62fb      	str	r3, [r7, #44]	; 0x2c
    pupdr <<= 2;
 8002106:	6abb      	ldr	r3, [r7, #40]	; 0x28
 8002108:	009b      	lsls	r3, r3, #2
 800210a:	62bb      	str	r3, [r7, #40]	; 0x28
    moder <<= 2;
 800210c:	6b7b      	ldr	r3, [r7, #52]	; 0x34
 800210e:	009b      	lsls	r3, r3, #2
 8002110:	637b      	str	r3, [r7, #52]	; 0x34
    bit++;
 8002112:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002114:	3301      	adds	r3, #1
 8002116:	627b      	str	r3, [r7, #36]	; 0x24
    if ((mask & 1) != 0) {
 8002118:	e76a      	b.n	8001ff0 <_pal_lld_setgroupmode+0x40>
      return;
 800211a:	bf00      	nop
  }
}
 800211c:	373c      	adds	r7, #60	; 0x3c
 800211e:	46bd      	mov	sp, r7
 8002120:	bc80      	pop	{r7}
 8002122:	4770      	bx	lr
	...

08002130 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8002130:	b580      	push	{r7, lr}
 8002132:	b082      	sub	sp, #8
 8002134:	af00      	add	r7, sp, #0
 8002136:	2330      	movs	r3, #48	; 0x30
 8002138:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800213a:	687b      	ldr	r3, [r7, #4]
 800213c:	f383 8811 	msr	BASEPRI, r3
}
 8002140:	bf00      	nop
}
 8002142:	bf00      	nop
}
 8002144:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002146:	f000 fb9b 	bl	8002880 <__dbg_check_lock_from_isr>
}
 800214a:	bf00      	nop
 800214c:	3708      	adds	r7, #8
 800214e:	46bd      	mov	sp, r7
 8002150:	bd80      	pop	{r7, pc}
 8002152:	bf00      	nop
	...

08002160 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8002160:	b580      	push	{r7, lr}
 8002162:	b082      	sub	sp, #8
 8002164:	af00      	add	r7, sp, #0
  __dbg_check_unlock_from_isr();
 8002166:	f000 fbb3 	bl	80028d0 <__dbg_check_unlock_from_isr>
 800216a:	2300      	movs	r3, #0
 800216c:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800216e:	687b      	ldr	r3, [r7, #4]
 8002170:	f383 8811 	msr	BASEPRI, r3
}
 8002174:	bf00      	nop
}
 8002176:	bf00      	nop
}
 8002178:	bf00      	nop
}
 800217a:	bf00      	nop
 800217c:	3708      	adds	r7, #8
 800217e:	46bd      	mov	sp, r7
 8002180:	bd80      	pop	{r7, pc}
 8002182:	bf00      	nop
	...

08002190 <osalSysLockFromISR>:
static inline void osalSysLockFromISR(void) {
 8002190:	b580      	push	{r7, lr}
 8002192:	af00      	add	r7, sp, #0
  chSysLockFromISR();
 8002194:	f7ff ffcc 	bl	8002130 <chSysLockFromISR>
}
 8002198:	bf00      	nop
 800219a:	bd80      	pop	{r7, pc}
 800219c:	0000      	movs	r0, r0
	...

080021a0 <osalSysUnlockFromISR>:
static inline void osalSysUnlockFromISR(void) {
 80021a0:	b580      	push	{r7, lr}
 80021a2:	af00      	add	r7, sp, #0
  chSysUnlockFromISR();
 80021a4:	f7ff ffdc 	bl	8002160 <chSysUnlockFromISR>
}
 80021a8:	bf00      	nop
 80021aa:	bd80      	pop	{r7, pc}
 80021ac:	0000      	movs	r0, r0
	...

080021b0 <osalOsTimerHandlerI>:
static inline void osalOsTimerHandlerI(void) {
 80021b0:	b580      	push	{r7, lr}
 80021b2:	af00      	add	r7, sp, #0
  chSysTimerHandlerI();
 80021b4:	f000 faf4 	bl	80027a0 <chSysTimerHandlerI>
}
 80021b8:	bf00      	nop
 80021ba:	bd80      	pop	{r7, pc}
 80021bc:	0000      	movs	r0, r0
	...

080021c0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 80021c0:	b480      	push	{r7}
 80021c2:	af00      	add	r7, sp, #0
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 80021c4:	4b1c      	ldr	r3, [pc, #112]	; (8002238 <st_lld_init+0x78>)
 80021c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80021c8:	4a1b      	ldr	r2, [pc, #108]	; (8002238 <st_lld_init+0x78>)
 80021ca:	f043 0301 	orr.w	r3, r3, #1
 80021ce:	6413      	str	r3, [r2, #64]	; 0x40
 80021d0:	4b19      	ldr	r3, [pc, #100]	; (8002238 <st_lld_init+0x78>)
 80021d2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80021d4:	4a18      	ldr	r2, [pc, #96]	; (8002238 <st_lld_init+0x78>)
 80021d6:	f043 0301 	orr.w	r3, r3, #1
 80021da:	6613      	str	r3, [r2, #96]	; 0x60
 80021dc:	4b16      	ldr	r3, [pc, #88]	; (8002238 <st_lld_init+0x78>)
 80021de:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 80021e0:	4b16      	ldr	r3, [pc, #88]	; (800223c <st_lld_init+0x7c>)
 80021e2:	689b      	ldr	r3, [r3, #8]
 80021e4:	4a15      	ldr	r2, [pc, #84]	; (800223c <st_lld_init+0x7c>)
 80021e6:	f043 0301 	orr.w	r3, r3, #1
 80021ea:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 80021ec:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80021f0:	f242 02cf 	movw	r2, #8399	; 0x20cf
 80021f4:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 80021f6:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80021fa:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80021fe:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 8002200:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002204:	2200      	movs	r2, #0
 8002206:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8002208:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800220c:	2200      	movs	r2, #0
 800220e:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 8002210:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002214:	2200      	movs	r2, #0
 8002216:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8002218:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800221c:	2200      	movs	r2, #0
 800221e:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8002220:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8002224:	2201      	movs	r2, #1
 8002226:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8002228:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800222c:	2201      	movs	r2, #1
 800222e:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8002230:	bf00      	nop
 8002232:	46bd      	mov	sp, r7
 8002234:	bc80      	pop	{r7}
 8002236:	4770      	bx	lr
 8002238:	40023800 	.word	0x40023800
 800223c:	e0042000 	.word	0xe0042000

08002240 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 8002240:	b580      	push	{r7, lr}
 8002242:	b082      	sub	sp, #8
 8002244:	af00      	add	r7, sp, #0
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 8002246:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800224a:	607b      	str	r3, [r7, #4]

  sr  = timp->SR;
 800224c:	687b      	ldr	r3, [r7, #4]
 800224e:	691b      	ldr	r3, [r3, #16]
 8002250:	603b      	str	r3, [r7, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002252:	687b      	ldr	r3, [r7, #4]
 8002254:	68db      	ldr	r3, [r3, #12]
 8002256:	b2db      	uxtb	r3, r3
 8002258:	683a      	ldr	r2, [r7, #0]
 800225a:	4013      	ands	r3, r2
 800225c:	603b      	str	r3, [r7, #0]
  timp->SR = ~sr;
 800225e:	683b      	ldr	r3, [r7, #0]
 8002260:	43da      	mvns	r2, r3
 8002262:	687b      	ldr	r3, [r7, #4]
 8002264:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 8002266:	683b      	ldr	r3, [r7, #0]
 8002268:	f003 0302 	and.w	r3, r3, #2
 800226c:	2b00      	cmp	r3, #0
 800226e:	d005      	beq.n	800227c <st_lld_serve_interrupt+0x3c>
#endif
  {
    osalSysLockFromISR();
 8002270:	f7ff ff8e 	bl	8002190 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 8002274:	f7ff ff9c 	bl	80021b0 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 8002278:	f7ff ff92 	bl	80021a0 <osalSysUnlockFromISR>
      st_callbacks[2](3U);
    }
  }
#endif
#endif
}
 800227c:	bf00      	nop
 800227e:	3708      	adds	r7, #8
 8002280:	46bd      	mov	sp, r7
 8002282:	bd80      	pop	{r7, pc}
	...

08002290 <gpt_lld_init>:
/**
 * @brief   Low level GPT driver initialization.
 *
 * @notapi
 */
void gpt_lld_init(void) {
 8002290:	b580      	push	{r7, lr}
 8002292:	af00      	add	r7, sp, #0
  gptObjectInit(&GPTD5);
#endif

#if STM32_GPT_USE_TIM6
  /* Driver initialization.*/
  GPTD6.tim = STM32_TIM6;
 8002294:	4b03      	ldr	r3, [pc, #12]	; (80022a4 <gpt_lld_init+0x14>)
 8002296:	4a04      	ldr	r2, [pc, #16]	; (80022a8 <gpt_lld_init+0x18>)
 8002298:	60da      	str	r2, [r3, #12]
  gptObjectInit(&GPTD6);
 800229a:	4802      	ldr	r0, [pc, #8]	; (80022a4 <gpt_lld_init+0x14>)
 800229c:	f7fe fb58 	bl	8000950 <gptObjectInit>
#if STM32_GPT_USE_TIM22
  /* Driver initialization.*/
  GPTD22.tim = STM32_TIM22;
  gptObjectInit(&GPTD22);
#endif
}
 80022a0:	bf00      	nop
 80022a2:	bd80      	pop	{r7, pc}
 80022a4:	200008e4 	.word	0x200008e4
 80022a8:	40001000 	.word	0x40001000
 80022ac:	00000000 	.word	0x00000000

080022b0 <gpt_lld_start>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_start(GPTDriver *gptp) {
 80022b0:	b580      	push	{r7, lr}
 80022b2:	b084      	sub	sp, #16
 80022b4:	af00      	add	r7, sp, #0
 80022b6:	6078      	str	r0, [r7, #4]
  uint16_t psc;

  if (gptp->state == GPT_STOP) {
 80022b8:	687b      	ldr	r3, [r7, #4]
 80022ba:	781b      	ldrb	r3, [r3, #0]
 80022bc:	2b01      	cmp	r3, #1
 80022be:	d122      	bne.n	8002306 <gpt_lld_start+0x56>
#endif
    }
#endif

#if STM32_GPT_USE_TIM6
    if (&GPTD6 == gptp) {
 80022c0:	687b      	ldr	r3, [r7, #4]
 80022c2:	4a2f      	ldr	r2, [pc, #188]	; (8002380 <gpt_lld_start+0xd0>)
 80022c4:	4293      	cmp	r3, r2
 80022c6:	d11e      	bne.n	8002306 <gpt_lld_start+0x56>
      rccEnableTIM6(true);
 80022c8:	4b2e      	ldr	r3, [pc, #184]	; (8002384 <gpt_lld_start+0xd4>)
 80022ca:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80022cc:	4a2d      	ldr	r2, [pc, #180]	; (8002384 <gpt_lld_start+0xd4>)
 80022ce:	f043 0310 	orr.w	r3, r3, #16
 80022d2:	6413      	str	r3, [r2, #64]	; 0x40
 80022d4:	4b2b      	ldr	r3, [pc, #172]	; (8002384 <gpt_lld_start+0xd4>)
 80022d6:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80022d8:	4a2a      	ldr	r2, [pc, #168]	; (8002384 <gpt_lld_start+0xd4>)
 80022da:	f043 0310 	orr.w	r3, r3, #16
 80022de:	6613      	str	r3, [r2, #96]	; 0x60
 80022e0:	4b28      	ldr	r3, [pc, #160]	; (8002384 <gpt_lld_start+0xd4>)
 80022e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      rccResetTIM6();
 80022e4:	4b27      	ldr	r3, [pc, #156]	; (8002384 <gpt_lld_start+0xd4>)
 80022e6:	6a1b      	ldr	r3, [r3, #32]
 80022e8:	4a26      	ldr	r2, [pc, #152]	; (8002384 <gpt_lld_start+0xd4>)
 80022ea:	f043 0310 	orr.w	r3, r3, #16
 80022ee:	6213      	str	r3, [r2, #32]
 80022f0:	4b24      	ldr	r3, [pc, #144]	; (8002384 <gpt_lld_start+0xd4>)
 80022f2:	6a1b      	ldr	r3, [r3, #32]
 80022f4:	4a23      	ldr	r2, [pc, #140]	; (8002384 <gpt_lld_start+0xd4>)
 80022f6:	f023 0310 	bic.w	r3, r3, #16
 80022fa:	6213      	str	r3, [r2, #32]
 80022fc:	4b21      	ldr	r3, [pc, #132]	; (8002384 <gpt_lld_start+0xd4>)
 80022fe:	6a1b      	ldr	r3, [r3, #32]
      nvicEnableVector(STM32_TIM6_NUMBER, STM32_GPT_TIM6_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM6CLK)
      gptp->clock = STM32_TIM6CLK;
#else
      gptp->clock = STM32_TIMCLK1;
 8002300:	687b      	ldr	r3, [r7, #4]
 8002302:	4a21      	ldr	r2, [pc, #132]	; (8002388 <gpt_lld_start+0xd8>)
 8002304:	609a      	str	r2, [r3, #8]
    }
#endif
  }

  /* Prescaler value calculation.*/
  psc = (uint16_t)((gptp->clock / gptp->config->frequency) - 1);
 8002306:	687b      	ldr	r3, [r7, #4]
 8002308:	689a      	ldr	r2, [r3, #8]
 800230a:	687b      	ldr	r3, [r7, #4]
 800230c:	685b      	ldr	r3, [r3, #4]
 800230e:	681b      	ldr	r3, [r3, #0]
 8002310:	fbb2 f3f3 	udiv	r3, r2, r3
 8002314:	b29b      	uxth	r3, r3
 8002316:	3b01      	subs	r3, #1
 8002318:	81fb      	strh	r3, [r7, #14]
  osalDbgAssert(((uint32_t)(psc + 1) * gptp->config->frequency) == gptp->clock,
 800231a:	89fb      	ldrh	r3, [r7, #14]
 800231c:	3301      	adds	r3, #1
 800231e:	461a      	mov	r2, r3
 8002320:	687b      	ldr	r3, [r7, #4]
 8002322:	685b      	ldr	r3, [r3, #4]
 8002324:	681b      	ldr	r3, [r3, #0]
 8002326:	fb03 f202 	mul.w	r2, r3, r2
 800232a:	687b      	ldr	r3, [r7, #4]
 800232c:	689b      	ldr	r3, [r3, #8]
 800232e:	429a      	cmp	r2, r3
 8002330:	bf14      	ite	ne
 8002332:	2301      	movne	r3, #1
 8002334:	2300      	moveq	r3, #0
 8002336:	b2db      	uxtb	r3, r3
 8002338:	2b00      	cmp	r3, #0
 800233a:	d002      	beq.n	8002342 <gpt_lld_start+0x92>
 800233c:	4813      	ldr	r0, [pc, #76]	; (800238c <gpt_lld_start+0xdc>)
 800233e:	f000 f9f7 	bl	8002730 <chSysHalt>
                "invalid frequency");

  /* Timer configuration.*/
  gptp->tim->CR1  = 0;                          /* Initially stopped.       */
 8002342:	687b      	ldr	r3, [r7, #4]
 8002344:	68db      	ldr	r3, [r3, #12]
 8002346:	2200      	movs	r2, #0
 8002348:	601a      	str	r2, [r3, #0]
  gptp->tim->CR2  = gptp->config->cr2;
 800234a:	687b      	ldr	r3, [r7, #4]
 800234c:	685a      	ldr	r2, [r3, #4]
 800234e:	687b      	ldr	r3, [r7, #4]
 8002350:	68db      	ldr	r3, [r3, #12]
 8002352:	6892      	ldr	r2, [r2, #8]
 8002354:	605a      	str	r2, [r3, #4]
  gptp->tim->PSC  = psc;                        /* Prescaler value.         */
 8002356:	687b      	ldr	r3, [r7, #4]
 8002358:	68db      	ldr	r3, [r3, #12]
 800235a:	89fa      	ldrh	r2, [r7, #14]
 800235c:	629a      	str	r2, [r3, #40]	; 0x28
  gptp->tim->SR   = 0;                          /* Clear pending IRQs.      */
 800235e:	687b      	ldr	r3, [r7, #4]
 8002360:	68db      	ldr	r3, [r3, #12]
 8002362:	2200      	movs	r2, #0
 8002364:	611a      	str	r2, [r3, #16]
  gptp->tim->DIER = gptp->config->dier &        /* DMA-related DIER bits.   */
 8002366:	687b      	ldr	r3, [r7, #4]
 8002368:	685b      	ldr	r3, [r3, #4]
 800236a:	68da      	ldr	r2, [r3, #12]
 800236c:	687b      	ldr	r3, [r7, #4]
 800236e:	68db      	ldr	r3, [r3, #12]
 8002370:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8002374:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
}
 8002376:	bf00      	nop
 8002378:	3710      	adds	r7, #16
 800237a:	46bd      	mov	sp, r7
 800237c:	bd80      	pop	{r7, pc}
 800237e:	bf00      	nop
 8002380:	200008e4 	.word	0x200008e4
 8002384:	40023800 	.word	0x40023800
 8002388:	0501bd00 	.word	0x0501bd00
 800238c:	08004e54 	.word	0x08004e54

08002390 <gpt_lld_start_timer>:
 * @param[in] gptp      pointer to the @p GPTDriver object
 * @param[in] interval  period in ticks
 *
 * @notapi
 */
void gpt_lld_start_timer(GPTDriver *gptp, gptcnt_t interval) {
 8002390:	b480      	push	{r7}
 8002392:	b083      	sub	sp, #12
 8002394:	af00      	add	r7, sp, #0
 8002396:	6078      	str	r0, [r7, #4]
 8002398:	6039      	str	r1, [r7, #0]

  gptp->tim->ARR = (uint32_t)(interval - 1U);   /* Time constant.           */
 800239a:	687b      	ldr	r3, [r7, #4]
 800239c:	68db      	ldr	r3, [r3, #12]
 800239e:	683a      	ldr	r2, [r7, #0]
 80023a0:	3a01      	subs	r2, #1
 80023a2:	62da      	str	r2, [r3, #44]	; 0x2c
  gptp->tim->EGR = STM32_TIM_EGR_UG;            /* Update event.            */
 80023a4:	687b      	ldr	r3, [r7, #4]
 80023a6:	68db      	ldr	r3, [r3, #12]
 80023a8:	2201      	movs	r2, #1
 80023aa:	615a      	str	r2, [r3, #20]
  gptp->tim->CNT = 0;                           /* Reset counter.           */
 80023ac:	687b      	ldr	r3, [r7, #4]
 80023ae:	68db      	ldr	r3, [r3, #12]
 80023b0:	2200      	movs	r2, #0
 80023b2:	625a      	str	r2, [r3, #36]	; 0x24

  /* NOTE: After generating the UG event it takes several clock cycles before
     SR bit 0 goes to 1. This is why the clearing of CNT has been inserted
     before the clearing of SR, to give it some time.*/
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 80023b4:	687b      	ldr	r3, [r7, #4]
 80023b6:	68db      	ldr	r3, [r3, #12]
 80023b8:	2200      	movs	r2, #0
 80023ba:	611a      	str	r2, [r3, #16]
  if (NULL != gptp->config->callback)
 80023bc:	687b      	ldr	r3, [r7, #4]
 80023be:	685b      	ldr	r3, [r3, #4]
 80023c0:	685b      	ldr	r3, [r3, #4]
 80023c2:	2b00      	cmp	r3, #0
 80023c4:	d007      	beq.n	80023d6 <gpt_lld_start_timer+0x46>
    gptp->tim->DIER |= STM32_TIM_DIER_UIE;      /* Update Event IRQ enabled.*/
 80023c6:	687b      	ldr	r3, [r7, #4]
 80023c8:	68db      	ldr	r3, [r3, #12]
 80023ca:	68da      	ldr	r2, [r3, #12]
 80023cc:	687b      	ldr	r3, [r7, #4]
 80023ce:	68db      	ldr	r3, [r3, #12]
 80023d0:	f042 0201 	orr.w	r2, r2, #1
 80023d4:	60da      	str	r2, [r3, #12]
  gptp->tim->CR1 = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 80023d6:	687b      	ldr	r3, [r7, #4]
 80023d8:	68db      	ldr	r3, [r3, #12]
 80023da:	2285      	movs	r2, #133	; 0x85
 80023dc:	601a      	str	r2, [r3, #0]
}
 80023de:	bf00      	nop
 80023e0:	370c      	adds	r7, #12
 80023e2:	46bd      	mov	sp, r7
 80023e4:	bc80      	pop	{r7}
 80023e6:	4770      	bx	lr
	...

080023f0 <gpt_lld_stop_timer>:
 *
 * @param[in] gptp      pointer to the @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_stop_timer(GPTDriver *gptp) {
 80023f0:	b480      	push	{r7}
 80023f2:	b083      	sub	sp, #12
 80023f4:	af00      	add	r7, sp, #0
 80023f6:	6078      	str	r0, [r7, #4]

  gptp->tim->CR1 = 0;                           /* Initially stopped.       */
 80023f8:	687b      	ldr	r3, [r7, #4]
 80023fa:	68db      	ldr	r3, [r3, #12]
 80023fc:	2200      	movs	r2, #0
 80023fe:	601a      	str	r2, [r3, #0]
  gptp->tim->SR = 0;                            /* Clear pending IRQs.      */
 8002400:	687b      	ldr	r3, [r7, #4]
 8002402:	68db      	ldr	r3, [r3, #12]
 8002404:	2200      	movs	r2, #0
 8002406:	611a      	str	r2, [r3, #16]

  /* All interrupts disabled.*/
  gptp->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 8002408:	687b      	ldr	r3, [r7, #4]
 800240a:	68db      	ldr	r3, [r3, #12]
 800240c:	68da      	ldr	r2, [r3, #12]
 800240e:	687b      	ldr	r3, [r7, #4]
 8002410:	68db      	ldr	r3, [r3, #12]
 8002412:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8002416:	60da      	str	r2, [r3, #12]
}
 8002418:	bf00      	nop
 800241a:	370c      	adds	r7, #12
 800241c:	46bd      	mov	sp, r7
 800241e:	bc80      	pop	{r7}
 8002420:	4770      	bx	lr
 8002422:	bf00      	nop
	...

08002430 <gpt_lld_serve_interrupt>:
 *
 * @param[in] gptp      pointer to a @p GPTDriver object
 *
 * @notapi
 */
void gpt_lld_serve_interrupt(GPTDriver *gptp) {
 8002430:	b580      	push	{r7, lr}
 8002432:	b084      	sub	sp, #16
 8002434:	af00      	add	r7, sp, #0
 8002436:	6078      	str	r0, [r7, #4]
  uint32_t sr;

  sr  = gptp->tim->SR;
 8002438:	687b      	ldr	r3, [r7, #4]
 800243a:	68db      	ldr	r3, [r3, #12]
 800243c:	691b      	ldr	r3, [r3, #16]
 800243e:	60fb      	str	r3, [r7, #12]
  sr &= gptp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8002440:	687b      	ldr	r3, [r7, #4]
 8002442:	68db      	ldr	r3, [r3, #12]
 8002444:	68db      	ldr	r3, [r3, #12]
 8002446:	b2db      	uxtb	r3, r3
 8002448:	68fa      	ldr	r2, [r7, #12]
 800244a:	4013      	ands	r3, r2
 800244c:	60fb      	str	r3, [r7, #12]
  gptp->tim->SR = ~sr;
 800244e:	687b      	ldr	r3, [r7, #4]
 8002450:	68db      	ldr	r3, [r3, #12]
 8002452:	68fa      	ldr	r2, [r7, #12]
 8002454:	43d2      	mvns	r2, r2
 8002456:	611a      	str	r2, [r3, #16]
  if ((sr & STM32_TIM_SR_UIF) != 0) {
 8002458:	68fb      	ldr	r3, [r7, #12]
 800245a:	f003 0301 	and.w	r3, r3, #1
 800245e:	2b00      	cmp	r3, #0
 8002460:	d013      	beq.n	800248a <gpt_lld_serve_interrupt+0x5a>
    _gpt_isr_invoke_cb(gptp);
 8002462:	687b      	ldr	r3, [r7, #4]
 8002464:	781b      	ldrb	r3, [r3, #0]
 8002466:	2b04      	cmp	r3, #4
 8002468:	d105      	bne.n	8002476 <gpt_lld_serve_interrupt+0x46>
 800246a:	687b      	ldr	r3, [r7, #4]
 800246c:	2202      	movs	r2, #2
 800246e:	701a      	strb	r2, [r3, #0]
 8002470:	6878      	ldr	r0, [r7, #4]
 8002472:	f7ff ffbd 	bl	80023f0 <gpt_lld_stop_timer>
 8002476:	687b      	ldr	r3, [r7, #4]
 8002478:	685b      	ldr	r3, [r3, #4]
 800247a:	685b      	ldr	r3, [r3, #4]
 800247c:	2b00      	cmp	r3, #0
 800247e:	d004      	beq.n	800248a <gpt_lld_serve_interrupt+0x5a>
 8002480:	687b      	ldr	r3, [r7, #4]
 8002482:	685b      	ldr	r3, [r3, #4]
 8002484:	685b      	ldr	r3, [r3, #4]
 8002486:	6878      	ldr	r0, [r7, #4]
 8002488:	4798      	blx	r3
  }
}
 800248a:	bf00      	nop
 800248c:	3710      	adds	r7, #16
 800248e:	46bd      	mov	sp, r7
 8002490:	bd80      	pop	{r7, pc}
 8002492:	bf00      	nop
	...

080024a0 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 80024a0:	b480      	push	{r7}
 80024a2:	b083      	sub	sp, #12
 80024a4:	af00      	add	r7, sp, #0
 80024a6:	6078      	str	r0, [r7, #4]
 80024a8:	6039      	str	r1, [r7, #0]

  gpiop->OTYPER  = config->otyper;
 80024aa:	683b      	ldr	r3, [r7, #0]
 80024ac:	685a      	ldr	r2, [r3, #4]
 80024ae:	687b      	ldr	r3, [r7, #4]
 80024b0:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 80024b2:	683b      	ldr	r3, [r7, #0]
 80024b4:	689a      	ldr	r2, [r3, #8]
 80024b6:	687b      	ldr	r3, [r7, #4]
 80024b8:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 80024ba:	683b      	ldr	r3, [r7, #0]
 80024bc:	68da      	ldr	r2, [r3, #12]
 80024be:	687b      	ldr	r3, [r7, #4]
 80024c0:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 80024c2:	683b      	ldr	r3, [r7, #0]
 80024c4:	691a      	ldr	r2, [r3, #16]
 80024c6:	687b      	ldr	r3, [r7, #4]
 80024c8:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 80024ca:	683b      	ldr	r3, [r7, #0]
 80024cc:	695a      	ldr	r2, [r3, #20]
 80024ce:	687b      	ldr	r3, [r7, #4]
 80024d0:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 80024d2:	683b      	ldr	r3, [r7, #0]
 80024d4:	699a      	ldr	r2, [r3, #24]
 80024d6:	687b      	ldr	r3, [r7, #4]
 80024d8:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 80024da:	683b      	ldr	r3, [r7, #0]
 80024dc:	681a      	ldr	r2, [r3, #0]
 80024de:	687b      	ldr	r3, [r7, #4]
 80024e0:	601a      	str	r2, [r3, #0]
}
 80024e2:	bf00      	nop
 80024e4:	370c      	adds	r7, #12
 80024e6:	46bd      	mov	sp, r7
 80024e8:	bc80      	pop	{r7}
 80024ea:	4770      	bx	lr
 80024ec:	0000      	movs	r0, r0
	...

080024f0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 80024f0:	b580      	push	{r7, lr}
 80024f2:	af00      	add	r7, sp, #0

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 80024f4:	4b24      	ldr	r3, [pc, #144]	; (8002588 <stm32_gpio_init+0x98>)
 80024f6:	691b      	ldr	r3, [r3, #16]
 80024f8:	4a23      	ldr	r2, [pc, #140]	; (8002588 <stm32_gpio_init+0x98>)
 80024fa:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 80024fe:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002502:	6113      	str	r3, [r2, #16]
 8002504:	4b20      	ldr	r3, [pc, #128]	; (8002588 <stm32_gpio_init+0x98>)
 8002506:	691b      	ldr	r3, [r3, #16]
 8002508:	4a1f      	ldr	r2, [pc, #124]	; (8002588 <stm32_gpio_init+0x98>)
 800250a:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 800250e:	f023 0301 	bic.w	r3, r3, #1
 8002512:	6113      	str	r3, [r2, #16]
 8002514:	4b1c      	ldr	r3, [pc, #112]	; (8002588 <stm32_gpio_init+0x98>)
 8002516:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8002518:	4b1b      	ldr	r3, [pc, #108]	; (8002588 <stm32_gpio_init+0x98>)
 800251a:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800251c:	4a1a      	ldr	r2, [pc, #104]	; (8002588 <stm32_gpio_init+0x98>)
 800251e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002522:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002526:	6313      	str	r3, [r2, #48]	; 0x30
 8002528:	4b17      	ldr	r3, [pc, #92]	; (8002588 <stm32_gpio_init+0x98>)
 800252a:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 800252c:	4a16      	ldr	r2, [pc, #88]	; (8002588 <stm32_gpio_init+0x98>)
 800252e:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002532:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002536:	6513      	str	r3, [r2, #80]	; 0x50
 8002538:	4b13      	ldr	r3, [pc, #76]	; (8002588 <stm32_gpio_init+0x98>)
 800253a:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800253c:	4913      	ldr	r1, [pc, #76]	; (800258c <stm32_gpio_init+0x9c>)
 800253e:	4814      	ldr	r0, [pc, #80]	; (8002590 <stm32_gpio_init+0xa0>)
 8002540:	f7ff ffae 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002544:	4913      	ldr	r1, [pc, #76]	; (8002594 <stm32_gpio_init+0xa4>)
 8002546:	4814      	ldr	r0, [pc, #80]	; (8002598 <stm32_gpio_init+0xa8>)
 8002548:	f7ff ffaa 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800254c:	4913      	ldr	r1, [pc, #76]	; (800259c <stm32_gpio_init+0xac>)
 800254e:	4814      	ldr	r0, [pc, #80]	; (80025a0 <stm32_gpio_init+0xb0>)
 8002550:	f7ff ffa6 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8002554:	4913      	ldr	r1, [pc, #76]	; (80025a4 <stm32_gpio_init+0xb4>)
 8002556:	4814      	ldr	r0, [pc, #80]	; (80025a8 <stm32_gpio_init+0xb8>)
 8002558:	f7ff ffa2 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800255c:	4913      	ldr	r1, [pc, #76]	; (80025ac <stm32_gpio_init+0xbc>)
 800255e:	4814      	ldr	r0, [pc, #80]	; (80025b0 <stm32_gpio_init+0xc0>)
 8002560:	f7ff ff9e 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8002564:	4913      	ldr	r1, [pc, #76]	; (80025b4 <stm32_gpio_init+0xc4>)
 8002566:	4814      	ldr	r0, [pc, #80]	; (80025b8 <stm32_gpio_init+0xc8>)
 8002568:	f7ff ff9a 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800256c:	4913      	ldr	r1, [pc, #76]	; (80025bc <stm32_gpio_init+0xcc>)
 800256e:	4814      	ldr	r0, [pc, #80]	; (80025c0 <stm32_gpio_init+0xd0>)
 8002570:	f7ff ff96 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8002574:	4913      	ldr	r1, [pc, #76]	; (80025c4 <stm32_gpio_init+0xd4>)
 8002576:	4814      	ldr	r0, [pc, #80]	; (80025c8 <stm32_gpio_init+0xd8>)
 8002578:	f7ff ff92 	bl	80024a0 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 800257c:	4913      	ldr	r1, [pc, #76]	; (80025cc <stm32_gpio_init+0xdc>)
 800257e:	4814      	ldr	r0, [pc, #80]	; (80025d0 <stm32_gpio_init+0xe0>)
 8002580:	f7ff ff8e 	bl	80024a0 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8002584:	bf00      	nop
 8002586:	bd80      	pop	{r7, pc}
 8002588:	40023800 	.word	0x40023800
 800258c:	08004e64 	.word	0x08004e64
 8002590:	40020000 	.word	0x40020000
 8002594:	08004e80 	.word	0x08004e80
 8002598:	40020400 	.word	0x40020400
 800259c:	08004e9c 	.word	0x08004e9c
 80025a0:	40020800 	.word	0x40020800
 80025a4:	08004eb8 	.word	0x08004eb8
 80025a8:	40020c00 	.word	0x40020c00
 80025ac:	08004ed4 	.word	0x08004ed4
 80025b0:	40021000 	.word	0x40021000
 80025b4:	08004ef0 	.word	0x08004ef0
 80025b8:	40021400 	.word	0x40021400
 80025bc:	08004f0c 	.word	0x08004f0c
 80025c0:	40021800 	.word	0x40021800
 80025c4:	08004f28 	.word	0x08004f28
 80025c8:	40021c00 	.word	0x40021c00
 80025cc:	08004f44 	.word	0x08004f44
 80025d0:	40022000 	.word	0x40022000
	...

080025e0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80025e0:	b580      	push	{r7, lr}
 80025e2:	af00      	add	r7, sp, #0

  stm32_gpio_init();
 80025e4:	f7ff ff84 	bl	80024f0 <stm32_gpio_init>
  stm32_clock_init();
 80025e8:	f7fe fd02 	bl	8000ff0 <stm32_clock_init>
}
 80025ec:	bf00      	nop
 80025ee:	bd80      	pop	{r7, pc}

080025f0 <boardInit>:

/**
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {
 80025f0:	b480      	push	{r7}
 80025f2:	af00      	add	r7, sp, #0

}
 80025f4:	bf00      	nop
 80025f6:	46bd      	mov	sp, r7
 80025f8:	bc80      	pop	{r7}
 80025fa:	4770      	bx	lr
 80025fc:	0000      	movs	r0, r0
	...

08002600 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 8002600:	b580      	push	{r7, lr}
 8002602:	b08a      	sub	sp, #40	; 0x28
 8002604:	af00      	add	r7, sp, #0
 8002606:	6078      	str	r0, [r7, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 8002608:	687b      	ldr	r3, [r7, #4]
 800260a:	2200      	movs	r2, #0
 800260c:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 800260e:	f107 0308 	add.w	r3, r7, #8
 8002612:	4618      	mov	r0, r3
 8002614:	f001 febc 	bl	8004390 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 8002618:	2304      	movs	r3, #4
 800261a:	627b      	str	r3, [r7, #36]	; 0x24
  do {
    chTMStartMeasurementX(&tm);
 800261c:	f107 0308 	add.w	r3, r7, #8
 8002620:	4618      	mov	r0, r3
 8002622:	f001 fed5 	bl	80043d0 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 8002626:	f107 0308 	add.w	r3, r7, #8
 800262a:	4618      	mov	r0, r3
 800262c:	f001 fee0 	bl	80043f0 <chTMStopMeasurementX>
    i--;
 8002630:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002632:	3b01      	subs	r3, #1
 8002634:	627b      	str	r3, [r7, #36]	; 0x24
  } while (i > 0U);
 8002636:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8002638:	2b00      	cmp	r3, #0
 800263a:	d1ef      	bne.n	800261c <__tm_calibration_object_init+0x1c>
  tcp->offset = tm.best;
 800263c:	68ba      	ldr	r2, [r7, #8]
 800263e:	687b      	ldr	r3, [r7, #4]
 8002640:	601a      	str	r2, [r3, #0]
}
 8002642:	bf00      	nop
 8002644:	3728      	adds	r7, #40	; 0x28
 8002646:	46bd      	mov	sp, r7
 8002648:	bd80      	pop	{r7, pc}
 800264a:	bf00      	nop
 800264c:	0000      	movs	r0, r0
	...

08002650 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8002650:	b580      	push	{r7, lr}
 8002652:	b082      	sub	sp, #8
 8002654:	af00      	add	r7, sp, #0
  __dbg_check_unlock();
 8002656:	f000 f8eb 	bl	8002830 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 800265a:	4b12      	ldr	r3, [pc, #72]	; (80026a4 <chSysUnlock+0x54>)
 800265c:	681b      	ldr	r3, [r3, #0]
 800265e:	4a11      	ldr	r2, [pc, #68]	; (80026a4 <chSysUnlock+0x54>)
 8002660:	4293      	cmp	r3, r2
 8002662:	bf14      	ite	ne
 8002664:	2301      	movne	r3, #1
 8002666:	2300      	moveq	r3, #0
 8002668:	b2db      	uxtb	r3, r3
 800266a:	2b00      	cmp	r3, #0
 800266c:	d00f      	beq.n	800268e <chSysUnlock+0x3e>
 800266e:	4b0d      	ldr	r3, [pc, #52]	; (80026a4 <chSysUnlock+0x54>)
 8002670:	68db      	ldr	r3, [r3, #12]
 8002672:	689a      	ldr	r2, [r3, #8]
 8002674:	4b0b      	ldr	r3, [pc, #44]	; (80026a4 <chSysUnlock+0x54>)
 8002676:	681b      	ldr	r3, [r3, #0]
 8002678:	689b      	ldr	r3, [r3, #8]
 800267a:	429a      	cmp	r2, r3
 800267c:	bf34      	ite	cc
 800267e:	2301      	movcc	r3, #1
 8002680:	2300      	movcs	r3, #0
 8002682:	b2db      	uxtb	r3, r3
 8002684:	2b00      	cmp	r3, #0
 8002686:	d002      	beq.n	800268e <chSysUnlock+0x3e>
 8002688:	4807      	ldr	r0, [pc, #28]	; (80026a8 <chSysUnlock+0x58>)
 800268a:	f000 f851 	bl	8002730 <chSysHalt>
 800268e:	2300      	movs	r3, #0
 8002690:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002692:	687b      	ldr	r3, [r7, #4]
 8002694:	f383 8811 	msr	BASEPRI, r3
}
 8002698:	bf00      	nop
}
 800269a:	bf00      	nop
}
 800269c:	bf00      	nop
 800269e:	3708      	adds	r7, #8
 80026a0:	46bd      	mov	sp, r7
 80026a2:	bd80      	pop	{r7, pc}
 80026a4:	20000900 	.word	0x20000900
 80026a8:	08004f74 	.word	0x08004f74
 80026ac:	00000000 	.word	0x00000000

080026b0 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 80026b0:	b580      	push	{r7, lr}
 80026b2:	af00      	add	r7, sp, #0

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 80026b4:	f001 ff24 	bl	8004500 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 80026b8:	f001 ff9a 	bl	80045f0 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 80026bc:	f002 f838 	bl	8004730 <__factory_init>
#endif
}
 80026c0:	bf00      	nop
 80026c2:	bd80      	pop	{r7, pc}
	...

080026d0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80026d0:	b580      	push	{r7, lr}
 80026d2:	b082      	sub	sp, #8
 80026d4:	af00      	add	r7, sp, #0
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80026d6:	4b12      	ldr	r3, [pc, #72]	; (8002720 <chSysInit+0x50>)
 80026d8:	2201      	movs	r2, #1
 80026da:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80026dc:	2300      	movs	r3, #0
 80026de:	607b      	str	r3, [r7, #4]
 80026e0:	e008      	b.n	80026f4 <chSysInit+0x24>
    ch_system.instances[i] = NULL;
 80026e2:	4a0f      	ldr	r2, [pc, #60]	; (8002720 <chSysInit+0x50>)
 80026e4:	687b      	ldr	r3, [r7, #4]
 80026e6:	009b      	lsls	r3, r3, #2
 80026e8:	4413      	add	r3, r2
 80026ea:	2200      	movs	r2, #0
 80026ec:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80026ee:	687b      	ldr	r3, [r7, #4]
 80026f0:	3301      	adds	r3, #1
 80026f2:	607b      	str	r3, [r7, #4]
 80026f4:	687b      	ldr	r3, [r7, #4]
 80026f6:	2b00      	cmp	r3, #0
 80026f8:	d0f3      	beq.n	80026e2 <chSysInit+0x12>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 80026fa:	480a      	ldr	r0, [pc, #40]	; (8002724 <chSysInit+0x54>)
 80026fc:	f7ff ff80 	bl	8002600 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 8002700:	f7ff ffd6 	bl	80026b0 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 8002704:	4908      	ldr	r1, [pc, #32]	; (8002728 <chSysInit+0x58>)
 8002706:	4809      	ldr	r0, [pc, #36]	; (800272c <chSysInit+0x5c>)
 8002708:	f001 fada 	bl	8003cc0 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 800270c:	4b04      	ldr	r3, [pc, #16]	; (8002720 <chSysInit+0x50>)
 800270e:	2202      	movs	r2, #2
 8002710:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 8002712:	f7ff ff9d 	bl	8002650 <chSysUnlock>
}
 8002716:	bf00      	nop
 8002718:	3708      	adds	r7, #8
 800271a:	46bd      	mov	sp, r7
 800271c:	bd80      	pop	{r7, pc}
 800271e:	bf00      	nop
 8002720:	200008f4 	.word	0x200008f4
 8002724:	200008fc 	.word	0x200008fc
 8002728:	08004f60 	.word	0x08004f60
 800272c:	20000900 	.word	0x20000900

08002730 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002730:	b580      	push	{r7, lr}
 8002732:	b082      	sub	sp, #8
 8002734:	af00      	add	r7, sp, #0
 8002736:	6078      	str	r0, [r7, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8002738:	b672      	cpsid	i
}
 800273a:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 800273c:	bf00      	nop

  port_disable();

  /* Logging the event.*/
  __trace_halt(reason);
 800273e:	6878      	ldr	r0, [r7, #4]
 8002740:	f000 fb1e 	bl	8002d80 <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8002744:	4a03      	ldr	r2, [pc, #12]	; (8002754 <chSysHalt+0x24>)
 8002746:	687b      	ldr	r3, [r7, #4]
 8002748:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 800274c:	4b02      	ldr	r3, [pc, #8]	; (8002758 <chSysHalt+0x28>)
 800274e:	2203      	movs	r2, #3
 8002750:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 8002752:	e7fe      	b.n	8002752 <chSysHalt+0x22>
 8002754:	20000900 	.word	0x20000900
 8002758:	200008f4 	.word	0x200008f4
 800275c:	00000000 	.word	0x00000000

08002760 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002760:	b580      	push	{r7, lr}
 8002762:	b082      	sub	sp, #8
 8002764:	af00      	add	r7, sp, #0
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002766:	4b0a      	ldr	r3, [pc, #40]	; (8002790 <chSysGetIdleThreadX+0x30>)
 8002768:	685b      	ldr	r3, [r3, #4]
 800276a:	607b      	str	r3, [r7, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800276c:	687b      	ldr	r3, [r7, #4]
 800276e:	689b      	ldr	r3, [r3, #8]
 8002770:	2b01      	cmp	r3, #1
 8002772:	bf14      	ite	ne
 8002774:	2301      	movne	r3, #1
 8002776:	2300      	moveq	r3, #0
 8002778:	b2db      	uxtb	r3, r3
 800277a:	2b00      	cmp	r3, #0
 800277c:	d002      	beq.n	8002784 <chSysGetIdleThreadX+0x24>
 800277e:	4805      	ldr	r0, [pc, #20]	; (8002794 <chSysGetIdleThreadX+0x34>)
 8002780:	f7ff ffd6 	bl	8002730 <chSysHalt>

  return tp;
 8002784:	687b      	ldr	r3, [r7, #4]
}
 8002786:	4618      	mov	r0, r3
 8002788:	3708      	adds	r7, #8
 800278a:	46bd      	mov	sp, r7
 800278c:	bd80      	pop	{r7, pc}
 800278e:	bf00      	nop
 8002790:	20000900 	.word	0x20000900
 8002794:	08004f80 	.word	0x08004f80
	...

080027a0 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 80027a0:	b580      	push	{r7, lr}
 80027a2:	af00      	add	r7, sp, #0
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 80027a4:	f000 f934 	bl	8002a10 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 80027a8:	f000 fe32 	bl	8003410 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 80027ac:	bf00      	nop
 80027ae:	bd80      	pop	{r7, pc}

080027b0 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 80027b0:	b480      	push	{r7}
 80027b2:	b083      	sub	sp, #12
 80027b4:	af00      	add	r7, sp, #0
 80027b6:	6078      	str	r0, [r7, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 80027b8:	4b05      	ldr	r3, [pc, #20]	; (80027d0 <chRFCUCollectFaultsI+0x20>)
 80027ba:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80027bc:	687b      	ldr	r3, [r7, #4]
 80027be:	4313      	orrs	r3, r2
 80027c0:	4a03      	ldr	r2, [pc, #12]	; (80027d0 <chRFCUCollectFaultsI+0x20>)
 80027c2:	6353      	str	r3, [r2, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 80027c4:	bf00      	nop
 80027c6:	370c      	adds	r7, #12
 80027c8:	46bd      	mov	sp, r7
 80027ca:	bc80      	pop	{r7}
 80027cc:	4770      	bx	lr
 80027ce:	bf00      	nop
 80027d0:	20000900 	.word	0x20000900
	...

080027e0 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 80027e0:	b580      	push	{r7, lr}
 80027e2:	b082      	sub	sp, #8
 80027e4:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 80027e6:	4b10      	ldr	r3, [pc, #64]	; (8002828 <__dbg_check_lock+0x48>)
 80027e8:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80027ea:	687b      	ldr	r3, [r7, #4]
 80027ec:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80027f0:	2b00      	cmp	r3, #0
 80027f2:	bf14      	ite	ne
 80027f4:	2301      	movne	r3, #1
 80027f6:	2300      	moveq	r3, #0
 80027f8:	b2db      	uxtb	r3, r3
 80027fa:	2b00      	cmp	r3, #0
 80027fc:	d109      	bne.n	8002812 <__dbg_check_lock+0x32>
 80027fe:	687b      	ldr	r3, [r7, #4]
 8002800:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002804:	2b00      	cmp	r3, #0
 8002806:	bf14      	ite	ne
 8002808:	2301      	movne	r3, #1
 800280a:	2300      	moveq	r3, #0
 800280c:	b2db      	uxtb	r3, r3
 800280e:	2b00      	cmp	r3, #0
 8002810:	d002      	beq.n	8002818 <__dbg_check_lock+0x38>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 8002812:	4806      	ldr	r0, [pc, #24]	; (800282c <__dbg_check_lock+0x4c>)
 8002814:	f7ff ff8c 	bl	8002730 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002818:	687b      	ldr	r3, [r7, #4]
 800281a:	2201      	movs	r2, #1
 800281c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 8002820:	bf00      	nop
 8002822:	3708      	adds	r7, #8
 8002824:	46bd      	mov	sp, r7
 8002826:	bd80      	pop	{r7, pc}
 8002828:	20000900 	.word	0x20000900
 800282c:	08004ab8 	.word	0x08004ab8

08002830 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 8002830:	b580      	push	{r7, lr}
 8002832:	b082      	sub	sp, #8
 8002834:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002836:	4b10      	ldr	r3, [pc, #64]	; (8002878 <__dbg_check_unlock+0x48>)
 8002838:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 800283a:	687b      	ldr	r3, [r7, #4]
 800283c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002840:	2b00      	cmp	r3, #0
 8002842:	bf14      	ite	ne
 8002844:	2301      	movne	r3, #1
 8002846:	2300      	moveq	r3, #0
 8002848:	b2db      	uxtb	r3, r3
 800284a:	2b00      	cmp	r3, #0
 800284c:	d109      	bne.n	8002862 <__dbg_check_unlock+0x32>
 800284e:	687b      	ldr	r3, [r7, #4]
 8002850:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002854:	2b00      	cmp	r3, #0
 8002856:	bfd4      	ite	le
 8002858:	2301      	movle	r3, #1
 800285a:	2300      	movgt	r3, #0
 800285c:	b2db      	uxtb	r3, r3
 800285e:	2b00      	cmp	r3, #0
 8002860:	d002      	beq.n	8002868 <__dbg_check_unlock+0x38>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002862:	4806      	ldr	r0, [pc, #24]	; (800287c <__dbg_check_unlock+0x4c>)
 8002864:	f7ff ff64 	bl	8002730 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002868:	687b      	ldr	r3, [r7, #4]
 800286a:	2200      	movs	r2, #0
 800286c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 8002870:	bf00      	nop
 8002872:	3708      	adds	r7, #8
 8002874:	46bd      	mov	sp, r7
 8002876:	bd80      	pop	{r7, pc}
 8002878:	20000900 	.word	0x20000900
 800287c:	08004ac0 	.word	0x08004ac0

08002880 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8002880:	b580      	push	{r7, lr}
 8002882:	b082      	sub	sp, #8
 8002884:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002886:	4b10      	ldr	r3, [pc, #64]	; (80028c8 <__dbg_check_lock_from_isr+0x48>)
 8002888:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 800288a:	687b      	ldr	r3, [r7, #4]
 800288c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002890:	2b00      	cmp	r3, #0
 8002892:	bfd4      	ite	le
 8002894:	2301      	movle	r3, #1
 8002896:	2300      	movgt	r3, #0
 8002898:	b2db      	uxtb	r3, r3
 800289a:	2b00      	cmp	r3, #0
 800289c:	d109      	bne.n	80028b2 <__dbg_check_lock_from_isr+0x32>
 800289e:	687b      	ldr	r3, [r7, #4]
 80028a0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80028a4:	2b00      	cmp	r3, #0
 80028a6:	bf14      	ite	ne
 80028a8:	2301      	movne	r3, #1
 80028aa:	2300      	moveq	r3, #0
 80028ac:	b2db      	uxtb	r3, r3
 80028ae:	2b00      	cmp	r3, #0
 80028b0:	d002      	beq.n	80028b8 <__dbg_check_lock_from_isr+0x38>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 80028b2:	4806      	ldr	r0, [pc, #24]	; (80028cc <__dbg_check_lock_from_isr+0x4c>)
 80028b4:	f7ff ff3c 	bl	8002730 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80028b8:	687b      	ldr	r3, [r7, #4]
 80028ba:	2201      	movs	r2, #1
 80028bc:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 80028c0:	bf00      	nop
 80028c2:	3708      	adds	r7, #8
 80028c4:	46bd      	mov	sp, r7
 80028c6:	bd80      	pop	{r7, pc}
 80028c8:	20000900 	.word	0x20000900
 80028cc:	08004ac8 	.word	0x08004ac8

080028d0 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 80028d0:	b580      	push	{r7, lr}
 80028d2:	b082      	sub	sp, #8
 80028d4:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 80028d6:	4b10      	ldr	r3, [pc, #64]	; (8002918 <__dbg_check_unlock_from_isr+0x48>)
 80028d8:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80028da:	687b      	ldr	r3, [r7, #4]
 80028dc:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80028e0:	2b00      	cmp	r3, #0
 80028e2:	bfd4      	ite	le
 80028e4:	2301      	movle	r3, #1
 80028e6:	2300      	movgt	r3, #0
 80028e8:	b2db      	uxtb	r3, r3
 80028ea:	2b00      	cmp	r3, #0
 80028ec:	d109      	bne.n	8002902 <__dbg_check_unlock_from_isr+0x32>
 80028ee:	687b      	ldr	r3, [r7, #4]
 80028f0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80028f4:	2b00      	cmp	r3, #0
 80028f6:	bfd4      	ite	le
 80028f8:	2301      	movle	r3, #1
 80028fa:	2300      	movgt	r3, #0
 80028fc:	b2db      	uxtb	r3, r3
 80028fe:	2b00      	cmp	r3, #0
 8002900:	d002      	beq.n	8002908 <__dbg_check_unlock_from_isr+0x38>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 8002902:	4806      	ldr	r0, [pc, #24]	; (800291c <__dbg_check_unlock_from_isr+0x4c>)
 8002904:	f7ff ff14 	bl	8002730 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002908:	687b      	ldr	r3, [r7, #4]
 800290a:	2200      	movs	r2, #0
 800290c:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 8002910:	bf00      	nop
 8002912:	3708      	adds	r7, #8
 8002914:	46bd      	mov	sp, r7
 8002916:	bd80      	pop	{r7, pc}
 8002918:	20000900 	.word	0x20000900
 800291c:	08004ad0 	.word	0x08004ad0

08002920 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 8002920:	b580      	push	{r7, lr}
 8002922:	b084      	sub	sp, #16
 8002924:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002926:	4b18      	ldr	r3, [pc, #96]	; (8002988 <__dbg_check_enter_isr+0x68>)
 8002928:	60fb      	str	r3, [r7, #12]
 800292a:	2330      	movs	r3, #48	; 0x30
 800292c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800292e:	68bb      	ldr	r3, [r7, #8]
 8002930:	f383 8811 	msr	BASEPRI, r3
}
 8002934:	bf00      	nop
}
 8002936:	bf00      	nop
}
 8002938:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 800293a:	68fb      	ldr	r3, [r7, #12]
 800293c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002940:	0fdb      	lsrs	r3, r3, #31
 8002942:	b2db      	uxtb	r3, r3
 8002944:	2b00      	cmp	r3, #0
 8002946:	d109      	bne.n	800295c <__dbg_check_enter_isr+0x3c>
 8002948:	68fb      	ldr	r3, [r7, #12]
 800294a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800294e:	2b00      	cmp	r3, #0
 8002950:	bf14      	ite	ne
 8002952:	2301      	movne	r3, #1
 8002954:	2300      	moveq	r3, #0
 8002956:	b2db      	uxtb	r3, r3
 8002958:	2b00      	cmp	r3, #0
 800295a:	d002      	beq.n	8002962 <__dbg_check_enter_isr+0x42>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 800295c:	480b      	ldr	r0, [pc, #44]	; (800298c <__dbg_check_enter_isr+0x6c>)
 800295e:	f7ff fee7 	bl	8002730 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002962:	68fb      	ldr	r3, [r7, #12]
 8002964:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002968:	1c5a      	adds	r2, r3, #1
 800296a:	68fb      	ldr	r3, [r7, #12]
 800296c:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 8002970:	2300      	movs	r3, #0
 8002972:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002974:	687b      	ldr	r3, [r7, #4]
 8002976:	f383 8811 	msr	BASEPRI, r3
}
 800297a:	bf00      	nop
}
 800297c:	bf00      	nop
}
 800297e:	bf00      	nop
  port_unlock_from_isr();
}
 8002980:	bf00      	nop
 8002982:	3710      	adds	r7, #16
 8002984:	46bd      	mov	sp, r7
 8002986:	bd80      	pop	{r7, pc}
 8002988:	20000900 	.word	0x20000900
 800298c:	08004ad8 	.word	0x08004ad8

08002990 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8002990:	b580      	push	{r7, lr}
 8002992:	b084      	sub	sp, #16
 8002994:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002996:	4b1a      	ldr	r3, [pc, #104]	; (8002a00 <__dbg_check_leave_isr+0x70>)
 8002998:	60fb      	str	r3, [r7, #12]
 800299a:	2330      	movs	r3, #48	; 0x30
 800299c:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800299e:	68bb      	ldr	r3, [r7, #8]
 80029a0:	f383 8811 	msr	BASEPRI, r3
}
 80029a4:	bf00      	nop
}
 80029a6:	bf00      	nop
}
 80029a8:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 80029aa:	68fb      	ldr	r3, [r7, #12]
 80029ac:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80029b0:	2b00      	cmp	r3, #0
 80029b2:	bfd4      	ite	le
 80029b4:	2301      	movle	r3, #1
 80029b6:	2300      	movgt	r3, #0
 80029b8:	b2db      	uxtb	r3, r3
 80029ba:	2b00      	cmp	r3, #0
 80029bc:	d109      	bne.n	80029d2 <__dbg_check_leave_isr+0x42>
 80029be:	68fb      	ldr	r3, [r7, #12]
 80029c0:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80029c4:	2b00      	cmp	r3, #0
 80029c6:	bf14      	ite	ne
 80029c8:	2301      	movne	r3, #1
 80029ca:	2300      	moveq	r3, #0
 80029cc:	b2db      	uxtb	r3, r3
 80029ce:	2b00      	cmp	r3, #0
 80029d0:	d002      	beq.n	80029d8 <__dbg_check_leave_isr+0x48>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 80029d2:	480c      	ldr	r0, [pc, #48]	; (8002a04 <__dbg_check_leave_isr+0x74>)
 80029d4:	f7ff feac 	bl	8002730 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 80029d8:	68fb      	ldr	r3, [r7, #12]
 80029da:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80029de:	1e5a      	subs	r2, r3, #1
 80029e0:	68fb      	ldr	r3, [r7, #12]
 80029e2:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 80029e6:	2300      	movs	r3, #0
 80029e8:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80029ea:	687b      	ldr	r3, [r7, #4]
 80029ec:	f383 8811 	msr	BASEPRI, r3
}
 80029f0:	bf00      	nop
}
 80029f2:	bf00      	nop
}
 80029f4:	bf00      	nop
  port_unlock_from_isr();
}
 80029f6:	bf00      	nop
 80029f8:	3710      	adds	r7, #16
 80029fa:	46bd      	mov	sp, r7
 80029fc:	bd80      	pop	{r7, pc}
 80029fe:	bf00      	nop
 8002a00:	20000900 	.word	0x20000900
 8002a04:	08004ae0 	.word	0x08004ae0
	...

08002a10 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 8002a10:	b580      	push	{r7, lr}
 8002a12:	b082      	sub	sp, #8
 8002a14:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002a16:	4b0d      	ldr	r3, [pc, #52]	; (8002a4c <chDbgCheckClassI+0x3c>)
 8002a18:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 8002a1a:	687b      	ldr	r3, [r7, #4]
 8002a1c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002a20:	0fdb      	lsrs	r3, r3, #31
 8002a22:	b2db      	uxtb	r3, r3
 8002a24:	2b00      	cmp	r3, #0
 8002a26:	d109      	bne.n	8002a3c <chDbgCheckClassI+0x2c>
 8002a28:	687b      	ldr	r3, [r7, #4]
 8002a2a:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002a2e:	2b00      	cmp	r3, #0
 8002a30:	bfd4      	ite	le
 8002a32:	2301      	movle	r3, #1
 8002a34:	2300      	movgt	r3, #0
 8002a36:	b2db      	uxtb	r3, r3
 8002a38:	2b00      	cmp	r3, #0
 8002a3a:	d002      	beq.n	8002a42 <chDbgCheckClassI+0x32>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 8002a3c:	4804      	ldr	r0, [pc, #16]	; (8002a50 <chDbgCheckClassI+0x40>)
 8002a3e:	f7ff fe77 	bl	8002730 <chSysHalt>
  }
}
 8002a42:	bf00      	nop
 8002a44:	3708      	adds	r7, #8
 8002a46:	46bd      	mov	sp, r7
 8002a48:	bd80      	pop	{r7, pc}
 8002a4a:	bf00      	nop
 8002a4c:	20000900 	.word	0x20000900
 8002a50:	08004ae8 	.word	0x08004ae8
	...

08002a60 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002a60:	b580      	push	{r7, lr}
 8002a62:	b082      	sub	sp, #8
 8002a64:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8002a66:	4b0e      	ldr	r3, [pc, #56]	; (8002aa0 <chDbgCheckClassS+0x40>)
 8002a68:	607b      	str	r3, [r7, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002a6a:	687b      	ldr	r3, [r7, #4]
 8002a6c:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002a70:	2b00      	cmp	r3, #0
 8002a72:	bf14      	ite	ne
 8002a74:	2301      	movne	r3, #1
 8002a76:	2300      	moveq	r3, #0
 8002a78:	b2db      	uxtb	r3, r3
 8002a7a:	2b00      	cmp	r3, #0
 8002a7c:	d109      	bne.n	8002a92 <chDbgCheckClassS+0x32>
 8002a7e:	687b      	ldr	r3, [r7, #4]
 8002a80:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002a84:	2b00      	cmp	r3, #0
 8002a86:	bfd4      	ite	le
 8002a88:	2301      	movle	r3, #1
 8002a8a:	2300      	movgt	r3, #0
 8002a8c:	b2db      	uxtb	r3, r3
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	d002      	beq.n	8002a98 <chDbgCheckClassS+0x38>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002a92:	4804      	ldr	r0, [pc, #16]	; (8002aa4 <chDbgCheckClassS+0x44>)
 8002a94:	f7ff fe4c 	bl	8002730 <chSysHalt>
  }
}
 8002a98:	bf00      	nop
 8002a9a:	3708      	adds	r7, #8
 8002a9c:	46bd      	mov	sp, r7
 8002a9e:	bd80      	pop	{r7, pc}
 8002aa0:	20000900 	.word	0x20000900
 8002aa4:	08004af0 	.word	0x08004af0
	...

08002ab0 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002ab0:	b580      	push	{r7, lr}
 8002ab2:	af00      	add	r7, sp, #0

  return stGetCounter();
 8002ab4:	f7fd fcf4 	bl	80004a0 <stGetCounter>
 8002ab8:	4603      	mov	r3, r0
}
 8002aba:	4618      	mov	r0, r3
 8002abc:	bd80      	pop	{r7, pc}
 8002abe:	bf00      	nop

08002ac0 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002ac0:	b580      	push	{r7, lr}
 8002ac2:	af00      	add	r7, sp, #0

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002ac4:	f7ff fff4 	bl	8002ab0 <port_timer_get_time>
 8002ac8:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002aca:	4618      	mov	r0, r3
 8002acc:	bd80      	pop	{r7, pc}
 8002ace:	bf00      	nop

08002ad0 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8002ad0:	b590      	push	{r4, r7, lr}
 8002ad2:	b083      	sub	sp, #12
 8002ad4:	af00      	add	r7, sp, #0
 8002ad6:	6078      	str	r0, [r7, #4]

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002ad8:	687b      	ldr	r3, [r7, #4]
 8002ada:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
 8002ade:	f7ff ffef 	bl	8002ac0 <chVTGetSystemTimeX>
 8002ae2:	4603      	mov	r3, r0
 8002ae4:	6063      	str	r3, [r4, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002ae6:	4b12      	ldr	r3, [pc, #72]	; (8002b30 <trace_next+0x60>)
 8002ae8:	685b      	ldr	r3, [r3, #4]
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8002aea:	687a      	ldr	r2, [r7, #4]
 8002aec:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8002af0:	f023 417f 	bic.w	r1, r3, #4278190080	; 0xff000000
 8002af4:	6813      	ldr	r3, [r2, #0]
 8002af6:	f361 231f 	bfi	r3, r1, #8, #24
 8002afa:	6013      	str	r3, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 8002afc:	687b      	ldr	r3, [r7, #4]
 8002afe:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002b02:	f103 0210 	add.w	r2, r3, #16
 8002b06:	687b      	ldr	r3, [r7, #4]
 8002b08:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 8002b0c:	687b      	ldr	r3, [r7, #4]
 8002b0e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002b12:	687b      	ldr	r3, [r7, #4]
 8002b14:	f603 0398 	addw	r3, r3, #2200	; 0x898
 8002b18:	429a      	cmp	r2, r3
 8002b1a:	d305      	bcc.n	8002b28 <trace_next+0x58>
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 8002b1c:	687b      	ldr	r3, [r7, #4]
 8002b1e:	f103 0298 	add.w	r2, r3, #152	; 0x98
 8002b22:	687b      	ldr	r3, [r7, #4]
 8002b24:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  }
}
 8002b28:	bf00      	nop
 8002b2a:	370c      	adds	r7, #12
 8002b2c:	46bd      	mov	sp, r7
 8002b2e:	bd90      	pop	{r4, r7, pc}
 8002b30:	e0001000 	.word	0xe0001000
	...

08002b40 <__trace_object_init>:
 *
 * @param[out] tbp      pointer to the @p trace_buffer_t structure
 *
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
 8002b40:	b480      	push	{r7}
 8002b42:	b085      	sub	sp, #20
 8002b44:	af00      	add	r7, sp, #0
 8002b46:	6078      	str	r0, [r7, #4]
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 8002b48:	687b      	ldr	r3, [r7, #4]
 8002b4a:	f64f 72e0 	movw	r2, #65504	; 0xffe0
 8002b4e:	801a      	strh	r2, [r3, #0]
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
 8002b50:	687b      	ldr	r3, [r7, #4]
 8002b52:	2280      	movs	r2, #128	; 0x80
 8002b54:	805a      	strh	r2, [r3, #2]
  tbp->ptr       = &tbp->buffer[0];
 8002b56:	687b      	ldr	r3, [r7, #4]
 8002b58:	f103 0208 	add.w	r2, r3, #8
 8002b5c:	687b      	ldr	r3, [r7, #4]
 8002b5e:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002b60:	2300      	movs	r3, #0
 8002b62:	60fb      	str	r3, [r7, #12]
 8002b64:	e00c      	b.n	8002b80 <__trace_object_init+0x40>
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002b66:	687a      	ldr	r2, [r7, #4]
 8002b68:	68fb      	ldr	r3, [r7, #12]
 8002b6a:	011b      	lsls	r3, r3, #4
 8002b6c:	4413      	add	r3, r2
 8002b6e:	f103 0208 	add.w	r2, r3, #8
 8002b72:	7813      	ldrb	r3, [r2, #0]
 8002b74:	f36f 0302 	bfc	r3, #0, #3
 8002b78:	7013      	strb	r3, [r2, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002b7a:	68fb      	ldr	r3, [r7, #12]
 8002b7c:	3301      	adds	r3, #1
 8002b7e:	60fb      	str	r3, [r7, #12]
 8002b80:	68fb      	ldr	r3, [r7, #12]
 8002b82:	2b7f      	cmp	r3, #127	; 0x7f
 8002b84:	d9ef      	bls.n	8002b66 <__trace_object_init+0x26>
  }
}
 8002b86:	bf00      	nop
 8002b88:	bf00      	nop
 8002b8a:	3714      	adds	r7, #20
 8002b8c:	46bd      	mov	sp, r7
 8002b8e:	bc80      	pop	{r7}
 8002b90:	4770      	bx	lr
 8002b92:	bf00      	nop
	...

08002ba0 <__trace_ready>:
 * @param[in] tp        the thread that just become ready
 * @param[in] msg       the thread ready message
 *
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
 8002ba0:	b580      	push	{r7, lr}
 8002ba2:	b084      	sub	sp, #16
 8002ba4:	af00      	add	r7, sp, #0
 8002ba6:	6078      	str	r0, [r7, #4]
 8002ba8:	6039      	str	r1, [r7, #0]
  os_instance_t *oip = currcore;
 8002baa:	4b18      	ldr	r3, [pc, #96]	; (8002c0c <__trace_ready+0x6c>)
 8002bac:	60fb      	str	r3, [r7, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 8002bae:	68fb      	ldr	r3, [r7, #12]
 8002bb0:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002bb4:	f003 0301 	and.w	r3, r3, #1
 8002bb8:	2b00      	cmp	r3, #0
 8002bba:	d122      	bne.n	8002c02 <__trace_ready+0x62>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 8002bbc:	68fb      	ldr	r3, [r7, #12]
 8002bbe:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002bc2:	7813      	ldrb	r3, [r2, #0]
 8002bc4:	2101      	movs	r1, #1
 8002bc6:	f361 0302 	bfi	r3, r1, #0, #3
 8002bca:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
 8002bcc:	687b      	ldr	r3, [r7, #4]
 8002bce:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 8002bd2:	68fb      	ldr	r3, [r7, #12]
 8002bd4:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002bd8:	460b      	mov	r3, r1
 8002bda:	f003 031f 	and.w	r3, r3, #31
 8002bde:	b2d9      	uxtb	r1, r3
 8002be0:	7813      	ldrb	r3, [r2, #0]
 8002be2:	f361 03c7 	bfi	r3, r1, #3, #5
 8002be6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
 8002be8:	68fb      	ldr	r3, [r7, #12]
 8002bea:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002bee:	687a      	ldr	r2, [r7, #4]
 8002bf0:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8002bf2:	68fb      	ldr	r3, [r7, #12]
 8002bf4:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002bf8:	683a      	ldr	r2, [r7, #0]
 8002bfa:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 8002bfc:	68f8      	ldr	r0, [r7, #12]
 8002bfe:	f7ff ff67 	bl	8002ad0 <trace_next>
  }
}
 8002c02:	bf00      	nop
 8002c04:	3710      	adds	r7, #16
 8002c06:	46bd      	mov	sp, r7
 8002c08:	bd80      	pop	{r7, pc}
 8002c0a:	bf00      	nop
 8002c0c:	20000900 	.word	0x20000900

08002c10 <__trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
 8002c10:	b580      	push	{r7, lr}
 8002c12:	b084      	sub	sp, #16
 8002c14:	af00      	add	r7, sp, #0
 8002c16:	6078      	str	r0, [r7, #4]
 8002c18:	6039      	str	r1, [r7, #0]
  os_instance_t *oip = currcore;
 8002c1a:	4b18      	ldr	r3, [pc, #96]	; (8002c7c <__trace_switch+0x6c>)
 8002c1c:	60fb      	str	r3, [r7, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 8002c1e:	68fb      	ldr	r3, [r7, #12]
 8002c20:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002c24:	f003 0302 	and.w	r3, r3, #2
 8002c28:	2b00      	cmp	r3, #0
 8002c2a:	d123      	bne.n	8002c74 <__trace_switch+0x64>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 8002c2c:	68fb      	ldr	r3, [r7, #12]
 8002c2e:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002c32:	7813      	ldrb	r3, [r2, #0]
 8002c34:	2102      	movs	r1, #2
 8002c36:	f361 0302 	bfi	r3, r1, #0, #3
 8002c3a:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
 8002c3c:	683b      	ldr	r3, [r7, #0]
 8002c3e:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 8002c42:	68fb      	ldr	r3, [r7, #12]
 8002c44:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002c48:	460b      	mov	r3, r1
 8002c4a:	f003 031f 	and.w	r3, r3, #31
 8002c4e:	b2d9      	uxtb	r1, r3
 8002c50:	7813      	ldrb	r3, [r2, #0]
 8002c52:	f361 03c7 	bfi	r3, r1, #3, #5
 8002c56:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 8002c58:	68fb      	ldr	r3, [r7, #12]
 8002c5a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002c5e:	687a      	ldr	r2, [r7, #4]
 8002c60:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 8002c62:	68fb      	ldr	r3, [r7, #12]
 8002c64:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002c68:	683a      	ldr	r2, [r7, #0]
 8002c6a:	6a92      	ldr	r2, [r2, #40]	; 0x28
 8002c6c:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 8002c6e:	68f8      	ldr	r0, [r7, #12]
 8002c70:	f7ff ff2e 	bl	8002ad0 <trace_next>
  }
}
 8002c74:	bf00      	nop
 8002c76:	3710      	adds	r7, #16
 8002c78:	46bd      	mov	sp, r7
 8002c7a:	bd80      	pop	{r7, pc}
 8002c7c:	20000900 	.word	0x20000900

08002c80 <__trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
 8002c80:	b580      	push	{r7, lr}
 8002c82:	b086      	sub	sp, #24
 8002c84:	af00      	add	r7, sp, #0
 8002c86:	6078      	str	r0, [r7, #4]
  os_instance_t *oip = currcore;
 8002c88:	4b19      	ldr	r3, [pc, #100]	; (8002cf0 <__trace_isr_enter+0x70>)
 8002c8a:	617b      	str	r3, [r7, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002c8c:	697b      	ldr	r3, [r7, #20]
 8002c8e:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002c92:	f003 0304 	and.w	r3, r3, #4
 8002c96:	2b00      	cmp	r3, #0
 8002c98:	d126      	bne.n	8002ce8 <__trace_isr_enter+0x68>
 8002c9a:	2330      	movs	r3, #48	; 0x30
 8002c9c:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002c9e:	68fb      	ldr	r3, [r7, #12]
 8002ca0:	f383 8811 	msr	BASEPRI, r3
}
 8002ca4:	bf00      	nop
}
 8002ca6:	bf00      	nop
}
 8002ca8:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002caa:	697b      	ldr	r3, [r7, #20]
 8002cac:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002cb0:	7813      	ldrb	r3, [r2, #0]
 8002cb2:	2103      	movs	r1, #3
 8002cb4:	f361 0302 	bfi	r3, r1, #0, #3
 8002cb8:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002cba:	697b      	ldr	r3, [r7, #20]
 8002cbc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002cc0:	7813      	ldrb	r3, [r2, #0]
 8002cc2:	f36f 03c7 	bfc	r3, #3, #5
 8002cc6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002cc8:	697b      	ldr	r3, [r7, #20]
 8002cca:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002cce:	687a      	ldr	r2, [r7, #4]
 8002cd0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002cd2:	6978      	ldr	r0, [r7, #20]
 8002cd4:	f7ff fefc 	bl	8002ad0 <trace_next>
 8002cd8:	2300      	movs	r3, #0
 8002cda:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002cdc:	693b      	ldr	r3, [r7, #16]
 8002cde:	f383 8811 	msr	BASEPRI, r3
}
 8002ce2:	bf00      	nop
}
 8002ce4:	bf00      	nop
}
 8002ce6:	bf00      	nop
    port_unlock_from_isr();
  }
}
 8002ce8:	bf00      	nop
 8002cea:	3718      	adds	r7, #24
 8002cec:	46bd      	mov	sp, r7
 8002cee:	bd80      	pop	{r7, pc}
 8002cf0:	20000900 	.word	0x20000900
	...

08002d00 <__trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
 8002d00:	b580      	push	{r7, lr}
 8002d02:	b086      	sub	sp, #24
 8002d04:	af00      	add	r7, sp, #0
 8002d06:	6078      	str	r0, [r7, #4]
  os_instance_t *oip = currcore;
 8002d08:	4b19      	ldr	r3, [pc, #100]	; (8002d70 <__trace_isr_leave+0x70>)
 8002d0a:	617b      	str	r3, [r7, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 8002d0c:	697b      	ldr	r3, [r7, #20]
 8002d0e:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002d12:	f003 0304 	and.w	r3, r3, #4
 8002d16:	2b00      	cmp	r3, #0
 8002d18:	d126      	bne.n	8002d68 <__trace_isr_leave+0x68>
 8002d1a:	2330      	movs	r3, #48	; 0x30
 8002d1c:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d1e:	68fb      	ldr	r3, [r7, #12]
 8002d20:	f383 8811 	msr	BASEPRI, r3
}
 8002d24:	bf00      	nop
}
 8002d26:	bf00      	nop
}
 8002d28:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 8002d2a:	697b      	ldr	r3, [r7, #20]
 8002d2c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002d30:	7813      	ldrb	r3, [r2, #0]
 8002d32:	2104      	movs	r1, #4
 8002d34:	f361 0302 	bfi	r3, r1, #0, #3
 8002d38:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002d3a:	697b      	ldr	r3, [r7, #20]
 8002d3c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002d40:	7813      	ldrb	r3, [r2, #0]
 8002d42:	f36f 03c7 	bfc	r3, #3, #5
 8002d46:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002d48:	697b      	ldr	r3, [r7, #20]
 8002d4a:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002d4e:	687a      	ldr	r2, [r7, #4]
 8002d50:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002d52:	6978      	ldr	r0, [r7, #20]
 8002d54:	f7ff febc 	bl	8002ad0 <trace_next>
 8002d58:	2300      	movs	r3, #0
 8002d5a:	613b      	str	r3, [r7, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002d5c:	693b      	ldr	r3, [r7, #16]
 8002d5e:	f383 8811 	msr	BASEPRI, r3
}
 8002d62:	bf00      	nop
}
 8002d64:	bf00      	nop
}
 8002d66:	bf00      	nop
    port_unlock_from_isr();
  }
}
 8002d68:	bf00      	nop
 8002d6a:	3718      	adds	r7, #24
 8002d6c:	46bd      	mov	sp, r7
 8002d6e:	bd80      	pop	{r7, pc}
 8002d70:	20000900 	.word	0x20000900
	...

08002d80 <__trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void __trace_halt(const char *reason) {
 8002d80:	b580      	push	{r7, lr}
 8002d82:	b084      	sub	sp, #16
 8002d84:	af00      	add	r7, sp, #0
 8002d86:	6078      	str	r0, [r7, #4]
  os_instance_t *oip = currcore;
 8002d88:	4b11      	ldr	r3, [pc, #68]	; (8002dd0 <__trace_halt+0x50>)
 8002d8a:	60fb      	str	r3, [r7, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 8002d8c:	68fb      	ldr	r3, [r7, #12]
 8002d8e:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002d92:	f003 0308 	and.w	r3, r3, #8
 8002d96:	2b00      	cmp	r3, #0
 8002d98:	d116      	bne.n	8002dc8 <__trace_halt+0x48>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002d9a:	68fb      	ldr	r3, [r7, #12]
 8002d9c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002da0:	7813      	ldrb	r3, [r2, #0]
 8002da2:	2105      	movs	r1, #5
 8002da4:	f361 0302 	bfi	r3, r1, #0, #3
 8002da8:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state         = 0;
 8002daa:	68fb      	ldr	r3, [r7, #12]
 8002dac:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002db0:	7813      	ldrb	r3, [r2, #0]
 8002db2:	f36f 03c7 	bfc	r3, #3, #5
 8002db6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.halt.reason = reason;
 8002db8:	68fb      	ldr	r3, [r7, #12]
 8002dba:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002dbe:	687a      	ldr	r2, [r7, #4]
 8002dc0:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002dc2:	68f8      	ldr	r0, [r7, #12]
 8002dc4:	f7ff fe84 	bl	8002ad0 <trace_next>
  }
}
 8002dc8:	bf00      	nop
 8002dca:	3710      	adds	r7, #16
 8002dcc:	46bd      	mov	sp, r7
 8002dce:	bd80      	pop	{r7, pc}
 8002dd0:	20000900 	.word	0x20000900
	...

08002de0 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002de0:	b480      	push	{r7}
 8002de2:	b083      	sub	sp, #12
 8002de4:	af00      	add	r7, sp, #0
 8002de6:	6078      	str	r0, [r7, #4]
 8002de8:	6039      	str	r1, [r7, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002dea:	687a      	ldr	r2, [r7, #4]
 8002dec:	683b      	ldr	r3, [r7, #0]
 8002dee:	4413      	add	r3, r2
}
 8002df0:	4618      	mov	r0, r3
 8002df2:	370c      	adds	r7, #12
 8002df4:	46bd      	mov	sp, r7
 8002df6:	bc80      	pop	{r7}
 8002df8:	4770      	bx	lr
 8002dfa:	bf00      	nop
 8002dfc:	0000      	movs	r0, r0
	...

08002e00 <chTimeDiffX>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002e00:	b480      	push	{r7}
 8002e02:	b083      	sub	sp, #12
 8002e04:	af00      	add	r7, sp, #0
 8002e06:	6078      	str	r0, [r7, #4]
 8002e08:	6039      	str	r1, [r7, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002e0a:	683a      	ldr	r2, [r7, #0]
 8002e0c:	687b      	ldr	r3, [r7, #4]
 8002e0e:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 8002e10:	4618      	mov	r0, r3
 8002e12:	370c      	adds	r7, #12
 8002e14:	46bd      	mov	sp, r7
 8002e16:	bc80      	pop	{r7}
 8002e18:	4770      	bx	lr
 8002e1a:	bf00      	nop
 8002e1c:	0000      	movs	r0, r0
	...

08002e20 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 8002e20:	b480      	push	{r7}
 8002e22:	b083      	sub	sp, #12
 8002e24:	af00      	add	r7, sp, #0
 8002e26:	6078      	str	r0, [r7, #4]

  return (bool)(dlhp == dlhp->next);
 8002e28:	687b      	ldr	r3, [r7, #4]
 8002e2a:	681b      	ldr	r3, [r3, #0]
 8002e2c:	687a      	ldr	r2, [r7, #4]
 8002e2e:	429a      	cmp	r2, r3
 8002e30:	bf0c      	ite	eq
 8002e32:	2301      	moveq	r3, #1
 8002e34:	2300      	movne	r3, #0
 8002e36:	b2db      	uxtb	r3, r3
}
 8002e38:	4618      	mov	r0, r3
 8002e3a:	370c      	adds	r7, #12
 8002e3c:	46bd      	mov	sp, r7
 8002e3e:	bc80      	pop	{r7}
 8002e40:	4770      	bx	lr
 8002e42:	bf00      	nop
	...

08002e50 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 8002e50:	b480      	push	{r7}
 8002e52:	b083      	sub	sp, #12
 8002e54:	af00      	add	r7, sp, #0
 8002e56:	6078      	str	r0, [r7, #4]
 8002e58:	6039      	str	r1, [r7, #0]

  return (bool)(dlhp->next == dlp);
 8002e5a:	687b      	ldr	r3, [r7, #4]
 8002e5c:	681b      	ldr	r3, [r3, #0]
 8002e5e:	683a      	ldr	r2, [r7, #0]
 8002e60:	429a      	cmp	r2, r3
 8002e62:	bf0c      	ite	eq
 8002e64:	2301      	moveq	r3, #1
 8002e66:	2300      	movne	r3, #0
 8002e68:	b2db      	uxtb	r3, r3
}
 8002e6a:	4618      	mov	r0, r3
 8002e6c:	370c      	adds	r7, #12
 8002e6e:	46bd      	mov	sp, r7
 8002e70:	bc80      	pop	{r7}
 8002e72:	4770      	bx	lr
	...

08002e80 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 8002e80:	b480      	push	{r7}
 8002e82:	b085      	sub	sp, #20
 8002e84:	af00      	add	r7, sp, #0
 8002e86:	60f8      	str	r0, [r7, #12]
 8002e88:	60b9      	str	r1, [r7, #8]
 8002e8a:	607a      	str	r2, [r7, #4]

  dlp->delta      = delta;
 8002e8c:	68bb      	ldr	r3, [r7, #8]
 8002e8e:	687a      	ldr	r2, [r7, #4]
 8002e90:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 8002e92:	68bb      	ldr	r3, [r7, #8]
 8002e94:	68fa      	ldr	r2, [r7, #12]
 8002e96:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002e98:	68bb      	ldr	r3, [r7, #8]
 8002e9a:	685b      	ldr	r3, [r3, #4]
 8002e9c:	681a      	ldr	r2, [r3, #0]
 8002e9e:	68bb      	ldr	r3, [r7, #8]
 8002ea0:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 8002ea2:	68bb      	ldr	r3, [r7, #8]
 8002ea4:	681b      	ldr	r3, [r3, #0]
 8002ea6:	68ba      	ldr	r2, [r7, #8]
 8002ea8:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002eaa:	68fb      	ldr	r3, [r7, #12]
 8002eac:	68ba      	ldr	r2, [r7, #8]
 8002eae:	601a      	str	r2, [r3, #0]
}
 8002eb0:	bf00      	nop
 8002eb2:	3714      	adds	r7, #20
 8002eb4:	46bd      	mov	sp, r7
 8002eb6:	bc80      	pop	{r7}
 8002eb8:	4770      	bx	lr
 8002eba:	bf00      	nop
 8002ebc:	0000      	movs	r0, r0
	...

08002ec0 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002ec0:	b480      	push	{r7}
 8002ec2:	b085      	sub	sp, #20
 8002ec4:	af00      	add	r7, sp, #0
 8002ec6:	60f8      	str	r0, [r7, #12]
 8002ec8:	60b9      	str	r1, [r7, #8]
 8002eca:	607a      	str	r2, [r7, #4]

  dlp->delta      = delta;
 8002ecc:	68bb      	ldr	r3, [r7, #8]
 8002ece:	687a      	ldr	r2, [r7, #4]
 8002ed0:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 8002ed2:	68bb      	ldr	r3, [r7, #8]
 8002ed4:	68fa      	ldr	r2, [r7, #12]
 8002ed6:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002ed8:	68bb      	ldr	r3, [r7, #8]
 8002eda:	681b      	ldr	r3, [r3, #0]
 8002edc:	685a      	ldr	r2, [r3, #4]
 8002ede:	68bb      	ldr	r3, [r7, #8]
 8002ee0:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 8002ee2:	68bb      	ldr	r3, [r7, #8]
 8002ee4:	685b      	ldr	r3, [r3, #4]
 8002ee6:	68ba      	ldr	r2, [r7, #8]
 8002ee8:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002eea:	68fb      	ldr	r3, [r7, #12]
 8002eec:	68ba      	ldr	r2, [r7, #8]
 8002eee:	605a      	str	r2, [r3, #4]
}
 8002ef0:	bf00      	nop
 8002ef2:	3714      	adds	r7, #20
 8002ef4:	46bd      	mov	sp, r7
 8002ef6:	bc80      	pop	{r7}
 8002ef8:	4770      	bx	lr
 8002efa:	bf00      	nop
 8002efc:	0000      	movs	r0, r0
	...

08002f00 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002f00:	b580      	push	{r7, lr}
 8002f02:	b086      	sub	sp, #24
 8002f04:	af00      	add	r7, sp, #0
 8002f06:	60f8      	str	r0, [r7, #12]
 8002f08:	60b9      	str	r1, [r7, #8]
 8002f0a:	607a      	str	r2, [r7, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 8002f0c:	68fb      	ldr	r3, [r7, #12]
 8002f0e:	681b      	ldr	r3, [r3, #0]
 8002f10:	617b      	str	r3, [r7, #20]
  while (likely(dlp->delta < delta)) {
 8002f12:	e013      	b.n	8002f3c <ch_dlist_insert+0x3c>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002f14:	697a      	ldr	r2, [r7, #20]
 8002f16:	68bb      	ldr	r3, [r7, #8]
 8002f18:	429a      	cmp	r2, r3
 8002f1a:	bf0c      	ite	eq
 8002f1c:	2301      	moveq	r3, #1
 8002f1e:	2300      	movne	r3, #0
 8002f20:	b2db      	uxtb	r3, r3
 8002f22:	2b00      	cmp	r3, #0
 8002f24:	d002      	beq.n	8002f2c <ch_dlist_insert+0x2c>
 8002f26:	4814      	ldr	r0, [pc, #80]	; (8002f78 <ch_dlist_insert+0x78>)
 8002f28:	f7ff fc02 	bl	8002730 <chSysHalt>

    delta -= dlp->delta;
 8002f2c:	697b      	ldr	r3, [r7, #20]
 8002f2e:	689b      	ldr	r3, [r3, #8]
 8002f30:	687a      	ldr	r2, [r7, #4]
 8002f32:	1ad3      	subs	r3, r2, r3
 8002f34:	607b      	str	r3, [r7, #4]
    dlp = dlp->next;
 8002f36:	697b      	ldr	r3, [r7, #20]
 8002f38:	681b      	ldr	r3, [r3, #0]
 8002f3a:	617b      	str	r3, [r7, #20]
  while (likely(dlp->delta < delta)) {
 8002f3c:	697b      	ldr	r3, [r7, #20]
 8002f3e:	689b      	ldr	r3, [r3, #8]
 8002f40:	687a      	ldr	r2, [r7, #4]
 8002f42:	429a      	cmp	r2, r3
 8002f44:	bf8c      	ite	hi
 8002f46:	2301      	movhi	r3, #1
 8002f48:	2300      	movls	r3, #0
 8002f4a:	b2db      	uxtb	r3, r3
 8002f4c:	2b00      	cmp	r3, #0
 8002f4e:	d1e1      	bne.n	8002f14 <ch_dlist_insert+0x14>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 8002f50:	687a      	ldr	r2, [r7, #4]
 8002f52:	68b9      	ldr	r1, [r7, #8]
 8002f54:	6978      	ldr	r0, [r7, #20]
 8002f56:	f7ff ffb3 	bl	8002ec0 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 8002f5a:	697b      	ldr	r3, [r7, #20]
 8002f5c:	689a      	ldr	r2, [r3, #8]
 8002f5e:	687b      	ldr	r3, [r7, #4]
 8002f60:	1ad2      	subs	r2, r2, r3
 8002f62:	697b      	ldr	r3, [r7, #20]
 8002f64:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 8002f66:	68fb      	ldr	r3, [r7, #12]
 8002f68:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002f6c:	609a      	str	r2, [r3, #8]
}
 8002f6e:	bf00      	nop
 8002f70:	3718      	adds	r7, #24
 8002f72:	46bd      	mov	sp, r7
 8002f74:	bd80      	pop	{r7, pc}
 8002f76:	bf00      	nop
 8002f78:	08004f94 	.word	0x08004f94
 8002f7c:	00000000 	.word	0x00000000

08002f80 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 8002f80:	b480      	push	{r7}
 8002f82:	b085      	sub	sp, #20
 8002f84:	af00      	add	r7, sp, #0
 8002f86:	6078      	str	r0, [r7, #4]
  ch_delta_list_t *dlp = dlhp->next;
 8002f88:	687b      	ldr	r3, [r7, #4]
 8002f8a:	681b      	ldr	r3, [r3, #0]
 8002f8c:	60fb      	str	r3, [r7, #12]

  dlhp->next       = dlp->next;
 8002f8e:	68fb      	ldr	r3, [r7, #12]
 8002f90:	681a      	ldr	r2, [r3, #0]
 8002f92:	687b      	ldr	r3, [r7, #4]
 8002f94:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002f96:	687b      	ldr	r3, [r7, #4]
 8002f98:	681b      	ldr	r3, [r3, #0]
 8002f9a:	687a      	ldr	r2, [r7, #4]
 8002f9c:	605a      	str	r2, [r3, #4]

  return dlp;
 8002f9e:	68fb      	ldr	r3, [r7, #12]
}
 8002fa0:	4618      	mov	r0, r3
 8002fa2:	3714      	adds	r7, #20
 8002fa4:	46bd      	mov	sp, r7
 8002fa6:	bc80      	pop	{r7}
 8002fa8:	4770      	bx	lr
 8002faa:	bf00      	nop
 8002fac:	0000      	movs	r0, r0
	...

08002fb0 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002fb0:	b480      	push	{r7}
 8002fb2:	b083      	sub	sp, #12
 8002fb4:	af00      	add	r7, sp, #0
 8002fb6:	6078      	str	r0, [r7, #4]

  dlp->prev->next = dlp->next;
 8002fb8:	687b      	ldr	r3, [r7, #4]
 8002fba:	685b      	ldr	r3, [r3, #4]
 8002fbc:	687a      	ldr	r2, [r7, #4]
 8002fbe:	6812      	ldr	r2, [r2, #0]
 8002fc0:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002fc2:	687b      	ldr	r3, [r7, #4]
 8002fc4:	681b      	ldr	r3, [r3, #0]
 8002fc6:	687a      	ldr	r2, [r7, #4]
 8002fc8:	6852      	ldr	r2, [r2, #4]
 8002fca:	605a      	str	r2, [r3, #4]

  return dlp;
 8002fcc:	687b      	ldr	r3, [r7, #4]
}
 8002fce:	4618      	mov	r0, r3
 8002fd0:	370c      	adds	r7, #12
 8002fd2:	46bd      	mov	sp, r7
 8002fd4:	bc80      	pop	{r7}
 8002fd6:	4770      	bx	lr
	...

08002fe0 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8002fe0:	b580      	push	{r7, lr}
 8002fe2:	b082      	sub	sp, #8
 8002fe4:	af00      	add	r7, sp, #0
 8002fe6:	6078      	str	r0, [r7, #4]
  stStartAlarm(time);
 8002fe8:	6878      	ldr	r0, [r7, #4]
 8002fea:	f7fd fa61 	bl	80004b0 <stStartAlarm>
}
 8002fee:	bf00      	nop
 8002ff0:	3708      	adds	r7, #8
 8002ff2:	46bd      	mov	sp, r7
 8002ff4:	bd80      	pop	{r7, pc}
 8002ff6:	bf00      	nop
	...

08003000 <port_timer_stop_alarm>:
static inline void port_timer_stop_alarm(void) {
 8003000:	b580      	push	{r7, lr}
 8003002:	af00      	add	r7, sp, #0
  stStopAlarm();
 8003004:	f7fd fa6c 	bl	80004e0 <stStopAlarm>
}
 8003008:	bf00      	nop
 800300a:	bd80      	pop	{r7, pc}
 800300c:	0000      	movs	r0, r0
	...

08003010 <port_timer_set_alarm>:
static inline void port_timer_set_alarm(systime_t time) {
 8003010:	b580      	push	{r7, lr}
 8003012:	b082      	sub	sp, #8
 8003014:	af00      	add	r7, sp, #0
 8003016:	6078      	str	r0, [r7, #4]
  stSetAlarm(time);
 8003018:	6878      	ldr	r0, [r7, #4]
 800301a:	f7fd fa69 	bl	80004f0 <stSetAlarm>
}
 800301e:	bf00      	nop
 8003020:	3708      	adds	r7, #8
 8003022:	46bd      	mov	sp, r7
 8003024:	bd80      	pop	{r7, pc}
 8003026:	bf00      	nop
	...

08003030 <port_timer_get_time>:
static inline systime_t port_timer_get_time(void) {
 8003030:	b580      	push	{r7, lr}
 8003032:	af00      	add	r7, sp, #0
  return stGetCounter();
 8003034:	f7fd fa34 	bl	80004a0 <stGetCounter>
 8003038:	4603      	mov	r3, r0
}
 800303a:	4618      	mov	r0, r3
 800303c:	bd80      	pop	{r7, pc}
 800303e:	bf00      	nop

08003040 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8003040:	b580      	push	{r7, lr}
 8003042:	b082      	sub	sp, #8
 8003044:	af00      	add	r7, sp, #0
 8003046:	2330      	movs	r3, #48	; 0x30
 8003048:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800304a:	687b      	ldr	r3, [r7, #4]
 800304c:	f383 8811 	msr	BASEPRI, r3
}
 8003050:	bf00      	nop
}
 8003052:	bf00      	nop
}
 8003054:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003056:	f7ff fc13 	bl	8002880 <__dbg_check_lock_from_isr>
}
 800305a:	bf00      	nop
 800305c:	3708      	adds	r7, #8
 800305e:	46bd      	mov	sp, r7
 8003060:	bd80      	pop	{r7, pc}
 8003062:	bf00      	nop
	...

08003070 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8003070:	b580      	push	{r7, lr}
 8003072:	b082      	sub	sp, #8
 8003074:	af00      	add	r7, sp, #0
  __dbg_check_unlock_from_isr();
 8003076:	f7ff fc2b 	bl	80028d0 <__dbg_check_unlock_from_isr>
 800307a:	2300      	movs	r3, #0
 800307c:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800307e:	687b      	ldr	r3, [r7, #4]
 8003080:	f383 8811 	msr	BASEPRI, r3
}
 8003084:	bf00      	nop
}
 8003086:	bf00      	nop
}
 8003088:	bf00      	nop
}
 800308a:	bf00      	nop
 800308c:	3708      	adds	r7, #8
 800308e:	46bd      	mov	sp, r7
 8003090:	bd80      	pop	{r7, pc}
 8003092:	bf00      	nop
	...

080030a0 <chVTGetSystemTimeX>:
static inline systime_t chVTGetSystemTimeX(void) {
 80030a0:	b580      	push	{r7, lr}
 80030a2:	af00      	add	r7, sp, #0
  return port_timer_get_time();
 80030a4:	f7ff ffc4 	bl	8003030 <port_timer_get_time>
 80030a8:	4603      	mov	r3, r0
}
 80030aa:	4618      	mov	r0, r3
 80030ac:	bd80      	pop	{r7, pc}
 80030ae:	bf00      	nop

080030b0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 80030b0:	b580      	push	{r7, lr}
 80030b2:	b082      	sub	sp, #8
 80030b4:	af00      	add	r7, sp, #0
 80030b6:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 80030b8:	f7ff fcaa 	bl	8002a10 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 80030bc:	687b      	ldr	r3, [r7, #4]
 80030be:	681b      	ldr	r3, [r3, #0]
 80030c0:	2b00      	cmp	r3, #0
 80030c2:	bf14      	ite	ne
 80030c4:	2301      	movne	r3, #1
 80030c6:	2300      	moveq	r3, #0
 80030c8:	b2db      	uxtb	r3, r3
}
 80030ca:	4618      	mov	r0, r3
 80030cc:	3708      	adds	r7, #8
 80030ce:	46bd      	mov	sp, r7
 80030d0:	bd80      	pop	{r7, pc}
 80030d2:	bf00      	nop
	...

080030e0 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 80030e0:	b580      	push	{r7, lr}
 80030e2:	b086      	sub	sp, #24
 80030e4:	af00      	add	r7, sp, #0
 80030e6:	6078      	str	r0, [r7, #4]
 80030e8:	6039      	str	r1, [r7, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 80030ea:	2302      	movs	r3, #2
 80030ec:	617b      	str	r3, [r7, #20]

  if (delay < currdelta) {
 80030ee:	683a      	ldr	r2, [r7, #0]
 80030f0:	697b      	ldr	r3, [r7, #20]
 80030f2:	429a      	cmp	r2, r3
 80030f4:	d201      	bcs.n	80030fa <vt_set_alarm+0x1a>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 80030f6:	697b      	ldr	r3, [r7, #20]
 80030f8:	603b      	str	r3, [r7, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 80030fa:	6839      	ldr	r1, [r7, #0]
 80030fc:	6878      	ldr	r0, [r7, #4]
 80030fe:	f7ff fe6f 	bl	8002de0 <chTimeAddX>
 8003102:	4603      	mov	r3, r0
 8003104:	4618      	mov	r0, r3
 8003106:	f7ff ff83 	bl	8003010 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 800310a:	f7ff ffc9 	bl	80030a0 <chVTGetSystemTimeX>
 800310e:	6138      	str	r0, [r7, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8003110:	6939      	ldr	r1, [r7, #16]
 8003112:	6878      	ldr	r0, [r7, #4]
 8003114:	f7ff fe74 	bl	8002e00 <chTimeDiffX>
 8003118:	60f8      	str	r0, [r7, #12]
    if (likely(nowdelta < delay)) {
 800311a:	68fa      	ldr	r2, [r7, #12]
 800311c:	683b      	ldr	r3, [r7, #0]
 800311e:	429a      	cmp	r2, r3
 8003120:	bf34      	ite	cc
 8003122:	2301      	movcc	r3, #1
 8003124:	2300      	movcs	r3, #0
 8003126:	b2db      	uxtb	r3, r3
 8003128:	2b00      	cmp	r3, #0
 800312a:	d107      	bne.n	800313c <vt_set_alarm+0x5c>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 800312c:	697b      	ldr	r3, [r7, #20]
 800312e:	3301      	adds	r3, #1
 8003130:	617b      	str	r3, [r7, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8003132:	693b      	ldr	r3, [r7, #16]
 8003134:	607b      	str	r3, [r7, #4]
    delay = currdelta;
 8003136:	697b      	ldr	r3, [r7, #20]
 8003138:	603b      	str	r3, [r7, #0]
  while (true) {
 800313a:	e7de      	b.n	80030fa <vt_set_alarm+0x1a>
      break;
 800313c:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 800313e:	697b      	ldr	r3, [r7, #20]
 8003140:	2b02      	cmp	r3, #2
 8003142:	d902      	bls.n	800314a <vt_set_alarm+0x6a>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8003144:	2001      	movs	r0, #1
 8003146:	f7ff fb33 	bl	80027b0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 800314a:	bf00      	nop
 800314c:	3718      	adds	r7, #24
 800314e:	46bd      	mov	sp, r7
 8003150:	bd80      	pop	{r7, pc}
 8003152:	bf00      	nop
	...

08003160 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8003160:	b580      	push	{r7, lr}
 8003162:	b086      	sub	sp, #24
 8003164:	af00      	add	r7, sp, #0
 8003166:	60f8      	str	r0, [r7, #12]
 8003168:	60b9      	str	r1, [r7, #8]
 800316a:	607a      	str	r2, [r7, #4]
 800316c:	603b      	str	r3, [r7, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 800316e:	68fb      	ldr	r3, [r7, #12]
 8003170:	687a      	ldr	r2, [r7, #4]
 8003172:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8003174:	68fb      	ldr	r3, [r7, #12]
 8003176:	68b9      	ldr	r1, [r7, #8]
 8003178:	683a      	ldr	r2, [r7, #0]
 800317a:	4618      	mov	r0, r3
 800317c:	f7ff fe80 	bl	8002e80 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8003180:	2302      	movs	r3, #2
 8003182:	617b      	str	r3, [r7, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8003184:	683a      	ldr	r2, [r7, #0]
 8003186:	697b      	ldr	r3, [r7, #20]
 8003188:	429a      	cmp	r2, r3
 800318a:	d201      	bcs.n	8003190 <vt_insert_first+0x30>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 800318c:	697b      	ldr	r3, [r7, #20]
 800318e:	603b      	str	r3, [r7, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8003190:	68fb      	ldr	r3, [r7, #12]
 8003192:	68db      	ldr	r3, [r3, #12]
 8003194:	6839      	ldr	r1, [r7, #0]
 8003196:	4618      	mov	r0, r3
 8003198:	f7ff fe22 	bl	8002de0 <chTimeAddX>
 800319c:	4603      	mov	r3, r0
 800319e:	4618      	mov	r0, r3
 80031a0:	f7ff ff1e 	bl	8002fe0 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 80031a4:	f7ff ff7c 	bl	80030a0 <chVTGetSystemTimeX>
 80031a8:	6138      	str	r0, [r7, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 80031aa:	6939      	ldr	r1, [r7, #16]
 80031ac:	6878      	ldr	r0, [r7, #4]
 80031ae:	f7ff fe27 	bl	8002e00 <chTimeDiffX>
 80031b2:	4602      	mov	r2, r0
 80031b4:	683b      	ldr	r3, [r7, #0]
 80031b6:	4293      	cmp	r3, r2
 80031b8:	bf8c      	ite	hi
 80031ba:	2301      	movhi	r3, #1
 80031bc:	2300      	movls	r3, #0
 80031be:	b2db      	uxtb	r3, r3
 80031c0:	2b00      	cmp	r3, #0
 80031c2:	d10b      	bne.n	80031dc <vt_insert_first+0x7c>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 80031c4:	697b      	ldr	r3, [r7, #20]
 80031c6:	3301      	adds	r3, #1
 80031c8:	617b      	str	r3, [r7, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 80031ca:	6979      	ldr	r1, [r7, #20]
 80031cc:	6878      	ldr	r0, [r7, #4]
 80031ce:	f7ff fe07 	bl	8002de0 <chTimeAddX>
 80031d2:	4603      	mov	r3, r0
 80031d4:	4618      	mov	r0, r3
 80031d6:	f7ff ff1b 	bl	8003010 <port_timer_set_alarm>
  while (true) {
 80031da:	e7e3      	b.n	80031a4 <vt_insert_first+0x44>
      break;
 80031dc:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 80031de:	697b      	ldr	r3, [r7, #20]
 80031e0:	2b02      	cmp	r3, #2
 80031e2:	d902      	bls.n	80031ea <vt_insert_first+0x8a>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 80031e4:	2001      	movs	r0, #1
 80031e6:	f7ff fae3 	bl	80027b0 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 80031ea:	bf00      	nop
 80031ec:	3718      	adds	r7, #24
 80031ee:	46bd      	mov	sp, r7
 80031f0:	bd80      	pop	{r7, pc}
 80031f2:	bf00      	nop
	...

08003200 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8003200:	b580      	push	{r7, lr}
 8003202:	b088      	sub	sp, #32
 8003204:	af00      	add	r7, sp, #0
 8003206:	60f8      	str	r0, [r7, #12]
 8003208:	60b9      	str	r1, [r7, #8]
 800320a:	607a      	str	r2, [r7, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 800320c:	f7ff ff48 	bl	80030a0 <chVTGetSystemTimeX>
 8003210:	61b8      	str	r0, [r7, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003212:	68fb      	ldr	r3, [r7, #12]
 8003214:	4618      	mov	r0, r3
 8003216:	f7ff fe03 	bl	8002e20 <ch_dlist_isempty>
 800321a:	4603      	mov	r3, r0
 800321c:	2b00      	cmp	r3, #0
 800321e:	d006      	beq.n	800322e <vt_enqueue+0x2e>

      vt_insert_first(vtlp, vtp, now, delay);
 8003220:	687b      	ldr	r3, [r7, #4]
 8003222:	69ba      	ldr	r2, [r7, #24]
 8003224:	68b9      	ldr	r1, [r7, #8]
 8003226:	68f8      	ldr	r0, [r7, #12]
 8003228:	f7ff ff9a 	bl	8003160 <vt_insert_first>

      return;
 800322c:	e020      	b.n	8003270 <vt_enqueue+0x70>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 800322e:	68fb      	ldr	r3, [r7, #12]
 8003230:	68db      	ldr	r3, [r3, #12]
 8003232:	69b9      	ldr	r1, [r7, #24]
 8003234:	4618      	mov	r0, r3
 8003236:	f7ff fde3 	bl	8002e00 <chTimeDiffX>
 800323a:	6178      	str	r0, [r7, #20]
    delta    = nowdelta + delay;
 800323c:	697a      	ldr	r2, [r7, #20]
 800323e:	687b      	ldr	r3, [r7, #4]
 8003240:	4413      	add	r3, r2
 8003242:	61fb      	str	r3, [r7, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8003244:	69fa      	ldr	r2, [r7, #28]
 8003246:	697b      	ldr	r3, [r7, #20]
 8003248:	429a      	cmp	r2, r3
 800324a:	d201      	bcs.n	8003250 <vt_enqueue+0x50>
      delta = delay;
 800324c:	687b      	ldr	r3, [r7, #4]
 800324e:	61fb      	str	r3, [r7, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8003250:	68fb      	ldr	r3, [r7, #12]
 8003252:	681b      	ldr	r3, [r3, #0]
 8003254:	689b      	ldr	r3, [r3, #8]
 8003256:	69fa      	ldr	r2, [r7, #28]
 8003258:	429a      	cmp	r2, r3
 800325a:	d203      	bcs.n	8003264 <vt_enqueue+0x64>

      vt_set_alarm(now, delay);
 800325c:	6879      	ldr	r1, [r7, #4]
 800325e:	69b8      	ldr	r0, [r7, #24]
 8003260:	f7ff ff3e 	bl	80030e0 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003264:	68fb      	ldr	r3, [r7, #12]
 8003266:	68b9      	ldr	r1, [r7, #8]
 8003268:	69fa      	ldr	r2, [r7, #28]
 800326a:	4618      	mov	r0, r3
 800326c:	f7ff fe48 	bl	8002f00 <ch_dlist_insert>
}
 8003270:	3720      	adds	r7, #32
 8003272:	46bd      	mov	sp, r7
 8003274:	bd80      	pop	{r7, pc}
 8003276:	bf00      	nop
	...

08003280 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8003280:	b580      	push	{r7, lr}
 8003282:	b086      	sub	sp, #24
 8003284:	af00      	add	r7, sp, #0
 8003286:	60f8      	str	r0, [r7, #12]
 8003288:	60b9      	str	r1, [r7, #8]
 800328a:	607a      	str	r2, [r7, #4]
 800328c:	603b      	str	r3, [r7, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 800328e:	4b1b      	ldr	r3, [pc, #108]	; (80032fc <chVTDoSetI+0x7c>)
 8003290:	617b      	str	r3, [r7, #20]

  chDbgCheckClassI();
 8003292:	f7ff fbbd 	bl	8002a10 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8003296:	68fb      	ldr	r3, [r7, #12]
 8003298:	2b00      	cmp	r3, #0
 800329a:	bf0c      	ite	eq
 800329c:	2301      	moveq	r3, #1
 800329e:	2300      	movne	r3, #0
 80032a0:	b2db      	uxtb	r3, r3
 80032a2:	2b00      	cmp	r3, #0
 80032a4:	d107      	bne.n	80032b6 <chVTDoSetI+0x36>
 80032a6:	687b      	ldr	r3, [r7, #4]
 80032a8:	2b00      	cmp	r3, #0
 80032aa:	bf0c      	ite	eq
 80032ac:	2301      	moveq	r3, #1
 80032ae:	2300      	movne	r3, #0
 80032b0:	b2db      	uxtb	r3, r3
 80032b2:	2b00      	cmp	r3, #0
 80032b4:	d001      	beq.n	80032ba <chVTDoSetI+0x3a>
 80032b6:	2301      	movs	r3, #1
 80032b8:	e000      	b.n	80032bc <chVTDoSetI+0x3c>
 80032ba:	2300      	movs	r3, #0
 80032bc:	2b00      	cmp	r3, #0
 80032be:	d107      	bne.n	80032d0 <chVTDoSetI+0x50>
 80032c0:	68bb      	ldr	r3, [r7, #8]
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	bf0c      	ite	eq
 80032c6:	2301      	moveq	r3, #1
 80032c8:	2300      	movne	r3, #0
 80032ca:	b2db      	uxtb	r3, r3
 80032cc:	2b00      	cmp	r3, #0
 80032ce:	d002      	beq.n	80032d6 <chVTDoSetI+0x56>
 80032d0:	480b      	ldr	r0, [pc, #44]	; (8003300 <chVTDoSetI+0x80>)
 80032d2:	f7ff fa2d 	bl	8002730 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 80032d6:	68fb      	ldr	r3, [r7, #12]
 80032d8:	683a      	ldr	r2, [r7, #0]
 80032da:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 80032dc:	68fb      	ldr	r3, [r7, #12]
 80032de:	687a      	ldr	r2, [r7, #4]
 80032e0:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 80032e2:	68fb      	ldr	r3, [r7, #12]
 80032e4:	2200      	movs	r2, #0
 80032e6:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 80032e8:	68ba      	ldr	r2, [r7, #8]
 80032ea:	68f9      	ldr	r1, [r7, #12]
 80032ec:	6978      	ldr	r0, [r7, #20]
 80032ee:	f7ff ff87 	bl	8003200 <vt_enqueue>
}
 80032f2:	bf00      	nop
 80032f4:	3718      	adds	r7, #24
 80032f6:	46bd      	mov	sp, r7
 80032f8:	bd80      	pop	{r7, pc}
 80032fa:	bf00      	nop
 80032fc:	20000910 	.word	0x20000910
 8003300:	08004fa4 	.word	0x08004fa4
	...

08003310 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8003310:	b580      	push	{r7, lr}
 8003312:	b086      	sub	sp, #24
 8003314:	af00      	add	r7, sp, #0
 8003316:	6078      	str	r0, [r7, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003318:	4b3a      	ldr	r3, [pc, #232]	; (8003404 <chVTDoResetI+0xf4>)
 800331a:	617b      	str	r3, [r7, #20]

  chDbgCheckClassI();
 800331c:	f7ff fb78 	bl	8002a10 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8003320:	687b      	ldr	r3, [r7, #4]
 8003322:	2b00      	cmp	r3, #0
 8003324:	bf0c      	ite	eq
 8003326:	2301      	moveq	r3, #1
 8003328:	2300      	movne	r3, #0
 800332a:	b2db      	uxtb	r3, r3
 800332c:	2b00      	cmp	r3, #0
 800332e:	d002      	beq.n	8003336 <chVTDoResetI+0x26>
 8003330:	4835      	ldr	r0, [pc, #212]	; (8003408 <chVTDoResetI+0xf8>)
 8003332:	f7ff f9fd 	bl	8002730 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8003336:	6878      	ldr	r0, [r7, #4]
 8003338:	f7ff feba 	bl	80030b0 <chVTIsArmedI>
 800333c:	4603      	mov	r3, r0
 800333e:	f083 0301 	eor.w	r3, r3, #1
 8003342:	b2db      	uxtb	r3, r3
 8003344:	2b00      	cmp	r3, #0
 8003346:	d002      	beq.n	800334e <chVTDoResetI+0x3e>
 8003348:	482f      	ldr	r0, [pc, #188]	; (8003408 <chVTDoResetI+0xf8>)
 800334a:	f7ff f9f1 	bl	8002730 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 800334e:	697b      	ldr	r3, [r7, #20]
 8003350:	687a      	ldr	r2, [r7, #4]
 8003352:	4611      	mov	r1, r2
 8003354:	4618      	mov	r0, r3
 8003356:	f7ff fd7b 	bl	8002e50 <ch_dlist_isfirst>
 800335a:	4603      	mov	r3, r0
 800335c:	f083 0301 	eor.w	r3, r3, #1
 8003360:	b2db      	uxtb	r3, r3
 8003362:	2b00      	cmp	r3, #0
 8003364:	d014      	beq.n	8003390 <chVTDoResetI+0x80>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8003366:	687b      	ldr	r3, [r7, #4]
 8003368:	4618      	mov	r0, r3
 800336a:	f7ff fe21 	bl	8002fb0 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 800336e:	687b      	ldr	r3, [r7, #4]
 8003370:	681b      	ldr	r3, [r3, #0]
 8003372:	6899      	ldr	r1, [r3, #8]
 8003374:	687b      	ldr	r3, [r7, #4]
 8003376:	689a      	ldr	r2, [r3, #8]
 8003378:	687b      	ldr	r3, [r7, #4]
 800337a:	681b      	ldr	r3, [r3, #0]
 800337c:	440a      	add	r2, r1
 800337e:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8003380:	687b      	ldr	r3, [r7, #4]
 8003382:	2200      	movs	r2, #0
 8003384:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8003386:	697b      	ldr	r3, [r7, #20]
 8003388:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800338c:	609a      	str	r2, [r3, #8]

    return;
 800338e:	e035      	b.n	80033fc <chVTDoResetI+0xec>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8003390:	697b      	ldr	r3, [r7, #20]
 8003392:	4618      	mov	r0, r3
 8003394:	f7ff fdf4 	bl	8002f80 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8003398:	687b      	ldr	r3, [r7, #4]
 800339a:	2200      	movs	r2, #0
 800339c:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 800339e:	697b      	ldr	r3, [r7, #20]
 80033a0:	4618      	mov	r0, r3
 80033a2:	f7ff fd3d 	bl	8002e20 <ch_dlist_isempty>
 80033a6:	4603      	mov	r3, r0
 80033a8:	2b00      	cmp	r3, #0
 80033aa:	d002      	beq.n	80033b2 <chVTDoResetI+0xa2>

    port_timer_stop_alarm();
 80033ac:	f7ff fe28 	bl	8003000 <port_timer_stop_alarm>

    return;
 80033b0:	e024      	b.n	80033fc <chVTDoResetI+0xec>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 80033b2:	697b      	ldr	r3, [r7, #20]
 80033b4:	681b      	ldr	r3, [r3, #0]
 80033b6:	6899      	ldr	r1, [r3, #8]
 80033b8:	687b      	ldr	r3, [r7, #4]
 80033ba:	689a      	ldr	r2, [r3, #8]
 80033bc:	697b      	ldr	r3, [r7, #20]
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	440a      	add	r2, r1
 80033c2:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 80033c4:	f7ff fe6c 	bl	80030a0 <chVTGetSystemTimeX>
 80033c8:	6138      	str	r0, [r7, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 80033ca:	697b      	ldr	r3, [r7, #20]
 80033cc:	68db      	ldr	r3, [r3, #12]
 80033ce:	6939      	ldr	r1, [r7, #16]
 80033d0:	4618      	mov	r0, r3
 80033d2:	f7ff fd15 	bl	8002e00 <chTimeDiffX>
 80033d6:	60f8      	str	r0, [r7, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 80033d8:	697b      	ldr	r3, [r7, #20]
 80033da:	681b      	ldr	r3, [r3, #0]
 80033dc:	689b      	ldr	r3, [r3, #8]
 80033de:	68fa      	ldr	r2, [r7, #12]
 80033e0:	429a      	cmp	r2, r3
 80033e2:	d20a      	bcs.n	80033fa <chVTDoResetI+0xea>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 80033e4:	697b      	ldr	r3, [r7, #20]
 80033e6:	681b      	ldr	r3, [r3, #0]
 80033e8:	689a      	ldr	r2, [r3, #8]
 80033ea:	68fb      	ldr	r3, [r7, #12]
 80033ec:	1ad3      	subs	r3, r2, r3
 80033ee:	60bb      	str	r3, [r7, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 80033f0:	68b9      	ldr	r1, [r7, #8]
 80033f2:	6938      	ldr	r0, [r7, #16]
 80033f4:	f7ff fe74 	bl	80030e0 <vt_set_alarm>
 80033f8:	e000      	b.n	80033fc <chVTDoResetI+0xec>
    return;
 80033fa:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80033fc:	3718      	adds	r7, #24
 80033fe:	46bd      	mov	sp, r7
 8003400:	bd80      	pop	{r7, pc}
 8003402:	bf00      	nop
 8003404:	20000910 	.word	0x20000910
 8003408:	08004fb0 	.word	0x08004fb0
 800340c:	00000000 	.word	0x00000000

08003410 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8003410:	b580      	push	{r7, lr}
 8003412:	b088      	sub	sp, #32
 8003414:	af00      	add	r7, sp, #0
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8003416:	4b4f      	ldr	r3, [pc, #316]	; (8003554 <chVTDoTickI+0x144>)
 8003418:	617b      	str	r3, [r7, #20]

  chDbgCheckClassI();
 800341a:	f7ff faf9 	bl	8002a10 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 800341e:	697b      	ldr	r3, [r7, #20]
 8003420:	681b      	ldr	r3, [r3, #0]
 8003422:	613b      	str	r3, [r7, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8003424:	f7ff fe3c 	bl	80030a0 <chVTGetSystemTimeX>
 8003428:	60f8      	str	r0, [r7, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 800342a:	697b      	ldr	r3, [r7, #20]
 800342c:	68db      	ldr	r3, [r3, #12]
 800342e:	68f9      	ldr	r1, [r7, #12]
 8003430:	4618      	mov	r0, r3
 8003432:	f7ff fce5 	bl	8002e00 <chTimeDiffX>
 8003436:	60b8      	str	r0, [r7, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8003438:	693b      	ldr	r3, [r7, #16]
 800343a:	689b      	ldr	r3, [r3, #8]
 800343c:	68ba      	ldr	r2, [r7, #8]
 800343e:	429a      	cmp	r2, r3
 8003440:	d369      	bcc.n	8003516 <chVTDoTickI+0x106>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8003442:	697b      	ldr	r3, [r7, #20]
 8003444:	68da      	ldr	r2, [r3, #12]
 8003446:	693b      	ldr	r3, [r7, #16]
 8003448:	689b      	ldr	r3, [r3, #8]
 800344a:	4619      	mov	r1, r3
 800344c:	4610      	mov	r0, r2
 800344e:	f7ff fcc7 	bl	8002de0 <chTimeAddX>
 8003452:	6078      	str	r0, [r7, #4]
    vtlp->lasttime = lasttime;
 8003454:	697b      	ldr	r3, [r7, #20]
 8003456:	687a      	ldr	r2, [r7, #4]
 8003458:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 800345a:	693b      	ldr	r3, [r7, #16]
 800345c:	4618      	mov	r0, r3
 800345e:	f7ff fda7 	bl	8002fb0 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8003462:	693b      	ldr	r3, [r7, #16]
 8003464:	2200      	movs	r2, #0
 8003466:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8003468:	697b      	ldr	r3, [r7, #20]
 800346a:	4618      	mov	r0, r3
 800346c:	f7ff fcd8 	bl	8002e20 <ch_dlist_isempty>
 8003470:	4603      	mov	r3, r0
 8003472:	2b00      	cmp	r3, #0
 8003474:	d001      	beq.n	800347a <chVTDoTickI+0x6a>
      port_timer_stop_alarm();
 8003476:	f7ff fdc3 	bl	8003000 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 800347a:	f7ff fdf9 	bl	8003070 <chSysUnlockFromISR>

    vtp->func(vtp, vtp->par);
 800347e:	693b      	ldr	r3, [r7, #16]
 8003480:	68db      	ldr	r3, [r3, #12]
 8003482:	693a      	ldr	r2, [r7, #16]
 8003484:	6912      	ldr	r2, [r2, #16]
 8003486:	4611      	mov	r1, r2
 8003488:	6938      	ldr	r0, [r7, #16]
 800348a:	4798      	blx	r3

    chSysLockFromISR();
 800348c:	f7ff fdd8 	bl	8003040 <chSysLockFromISR>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8003490:	693b      	ldr	r3, [r7, #16]
 8003492:	695b      	ldr	r3, [r3, #20]
 8003494:	2b00      	cmp	r3, #0
 8003496:	bf14      	ite	ne
 8003498:	2301      	movne	r3, #1
 800349a:	2300      	moveq	r3, #0
 800349c:	b2db      	uxtb	r3, r3
 800349e:	2b00      	cmp	r3, #0
 80034a0:	d0bd      	beq.n	800341e <chVTDoTickI+0xe>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 80034a2:	f7ff fdfd 	bl	80030a0 <chVTGetSystemTimeX>
 80034a6:	60f8      	str	r0, [r7, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 80034a8:	68f9      	ldr	r1, [r7, #12]
 80034aa:	6878      	ldr	r0, [r7, #4]
 80034ac:	f7ff fca8 	bl	8002e00 <chTimeDiffX>
 80034b0:	60b8      	str	r0, [r7, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 80034b2:	693b      	ldr	r3, [r7, #16]
 80034b4:	695b      	ldr	r3, [r3, #20]
 80034b6:	68ba      	ldr	r2, [r7, #8]
 80034b8:	429a      	cmp	r2, r3
 80034ba:	d908      	bls.n	80034ce <chVTDoTickI+0xbe>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 80034bc:	4826      	ldr	r0, [pc, #152]	; (8003558 <chVTDoTickI+0x148>)
 80034be:	f7ff f937 	bl	8002730 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 80034c2:	2002      	movs	r0, #2
 80034c4:	f7ff f974 	bl	80027b0 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 80034c8:	2300      	movs	r3, #0
 80034ca:	61bb      	str	r3, [r7, #24]
 80034cc:	e004      	b.n	80034d8 <chVTDoTickI+0xc8>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 80034ce:	693b      	ldr	r3, [r7, #16]
 80034d0:	695a      	ldr	r2, [r3, #20]
 80034d2:	68bb      	ldr	r3, [r7, #8]
 80034d4:	1ad3      	subs	r3, r2, r3
 80034d6:	61bb      	str	r3, [r7, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 80034d8:	697b      	ldr	r3, [r7, #20]
 80034da:	4618      	mov	r0, r3
 80034dc:	f7ff fca0 	bl	8002e20 <ch_dlist_isempty>
 80034e0:	4603      	mov	r3, r0
 80034e2:	2b00      	cmp	r3, #0
 80034e4:	d006      	beq.n	80034f4 <chVTDoTickI+0xe4>

        vt_insert_first(vtlp, vtp, now, delay);
 80034e6:	69bb      	ldr	r3, [r7, #24]
 80034e8:	68fa      	ldr	r2, [r7, #12]
 80034ea:	6939      	ldr	r1, [r7, #16]
 80034ec:	6978      	ldr	r0, [r7, #20]
 80034ee:	f7ff fe37 	bl	8003160 <vt_insert_first>

        return;
 80034f2:	e02c      	b.n	800354e <chVTDoTickI+0x13e>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 80034f4:	68ba      	ldr	r2, [r7, #8]
 80034f6:	69bb      	ldr	r3, [r7, #24]
 80034f8:	4413      	add	r3, r2
 80034fa:	61fb      	str	r3, [r7, #28]
      if (delta < nowdelta) {
 80034fc:	69fa      	ldr	r2, [r7, #28]
 80034fe:	68bb      	ldr	r3, [r7, #8]
 8003500:	429a      	cmp	r2, r3
 8003502:	d201      	bcs.n	8003508 <chVTDoTickI+0xf8>
        delta = delay;
 8003504:	69bb      	ldr	r3, [r7, #24]
 8003506:	61fb      	str	r3, [r7, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8003508:	697b      	ldr	r3, [r7, #20]
 800350a:	6939      	ldr	r1, [r7, #16]
 800350c:	69fa      	ldr	r2, [r7, #28]
 800350e:	4618      	mov	r0, r3
 8003510:	f7ff fcf6 	bl	8002f00 <ch_dlist_insert>
  while (true) {
 8003514:	e783      	b.n	800341e <chVTDoTickI+0xe>
      break;
 8003516:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8003518:	697b      	ldr	r3, [r7, #20]
 800351a:	4618      	mov	r0, r3
 800351c:	f7ff fc80 	bl	8002e20 <ch_dlist_isempty>
 8003520:	4603      	mov	r3, r0
 8003522:	2b00      	cmp	r3, #0
 8003524:	d112      	bne.n	800354c <chVTDoTickI+0x13c>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8003526:	697b      	ldr	r3, [r7, #20]
 8003528:	68da      	ldr	r2, [r3, #12]
 800352a:	68bb      	ldr	r3, [r7, #8]
 800352c:	441a      	add	r2, r3
 800352e:	697b      	ldr	r3, [r7, #20]
 8003530:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8003532:	693b      	ldr	r3, [r7, #16]
 8003534:	689a      	ldr	r2, [r3, #8]
 8003536:	68bb      	ldr	r3, [r7, #8]
 8003538:	1ad2      	subs	r2, r2, r3
 800353a:	693b      	ldr	r3, [r7, #16]
 800353c:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 800353e:	693b      	ldr	r3, [r7, #16]
 8003540:	689b      	ldr	r3, [r3, #8]
 8003542:	4619      	mov	r1, r3
 8003544:	68f8      	ldr	r0, [r7, #12]
 8003546:	f7ff fdcb 	bl	80030e0 <vt_set_alarm>
 800354a:	e000      	b.n	800354e <chVTDoTickI+0x13e>
    return;
 800354c:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800354e:	3720      	adds	r7, #32
 8003550:	46bd      	mov	sp, r7
 8003552:	bd80      	pop	{r7, pc}
 8003554:	20000910 	.word	0x20000910
 8003558:	08004fc0 	.word	0x08004fc0
 800355c:	00000000 	.word	0x00000000

08003560 <ch_queue_dequeue>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003560:	b480      	push	{r7}
 8003562:	b083      	sub	sp, #12
 8003564:	af00      	add	r7, sp, #0
 8003566:	6078      	str	r0, [r7, #4]
  p->prev->next = p->next;
 8003568:	687b      	ldr	r3, [r7, #4]
 800356a:	685b      	ldr	r3, [r3, #4]
 800356c:	687a      	ldr	r2, [r7, #4]
 800356e:	6812      	ldr	r2, [r2, #0]
 8003570:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003572:	687b      	ldr	r3, [r7, #4]
 8003574:	681b      	ldr	r3, [r3, #0]
 8003576:	687a      	ldr	r2, [r7, #4]
 8003578:	6852      	ldr	r2, [r2, #4]
 800357a:	605a      	str	r2, [r3, #4]
  return p;
 800357c:	687b      	ldr	r3, [r7, #4]
}
 800357e:	4618      	mov	r0, r3
 8003580:	370c      	adds	r7, #12
 8003582:	46bd      	mov	sp, r7
 8003584:	bc80      	pop	{r7}
 8003586:	4770      	bx	lr
	...

08003590 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8003590:	b480      	push	{r7}
 8003592:	b085      	sub	sp, #20
 8003594:	af00      	add	r7, sp, #0
 8003596:	6078      	str	r0, [r7, #4]
  ch_priority_queue_t *p = pqp->next;
 8003598:	687b      	ldr	r3, [r7, #4]
 800359a:	681b      	ldr	r3, [r3, #0]
 800359c:	60fb      	str	r3, [r7, #12]
  pqp->next       = p->next;
 800359e:	68fb      	ldr	r3, [r7, #12]
 80035a0:	681a      	ldr	r2, [r3, #0]
 80035a2:	687b      	ldr	r3, [r7, #4]
 80035a4:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 80035a6:	687b      	ldr	r3, [r7, #4]
 80035a8:	681b      	ldr	r3, [r3, #0]
 80035aa:	687a      	ldr	r2, [r7, #4]
 80035ac:	605a      	str	r2, [r3, #4]
  return p;
 80035ae:	68fb      	ldr	r3, [r7, #12]
}
 80035b0:	4618      	mov	r0, r3
 80035b2:	3714      	adds	r7, #20
 80035b4:	46bd      	mov	sp, r7
 80035b6:	bc80      	pop	{r7}
 80035b8:	4770      	bx	lr
 80035ba:	bf00      	nop
 80035bc:	0000      	movs	r0, r0
	...

080035c0 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 80035c0:	b480      	push	{r7}
 80035c2:	b083      	sub	sp, #12
 80035c4:	af00      	add	r7, sp, #0
 80035c6:	6078      	str	r0, [r7, #4]
 80035c8:	6039      	str	r1, [r7, #0]
    pqp = pqp->next;
 80035ca:	687b      	ldr	r3, [r7, #4]
 80035cc:	681b      	ldr	r3, [r3, #0]
 80035ce:	607b      	str	r3, [r7, #4]
  } while (unlikely(pqp->prio >= p->prio));
 80035d0:	687b      	ldr	r3, [r7, #4]
 80035d2:	689a      	ldr	r2, [r3, #8]
 80035d4:	683b      	ldr	r3, [r7, #0]
 80035d6:	689b      	ldr	r3, [r3, #8]
 80035d8:	429a      	cmp	r2, r3
 80035da:	bf2c      	ite	cs
 80035dc:	2301      	movcs	r3, #1
 80035de:	2300      	movcc	r3, #0
 80035e0:	b2db      	uxtb	r3, r3
 80035e2:	2b00      	cmp	r3, #0
 80035e4:	d1f1      	bne.n	80035ca <ch_pqueue_insert_behind+0xa>
  p->next       = pqp;
 80035e6:	683b      	ldr	r3, [r7, #0]
 80035e8:	687a      	ldr	r2, [r7, #4]
 80035ea:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 80035ec:	687b      	ldr	r3, [r7, #4]
 80035ee:	685a      	ldr	r2, [r3, #4]
 80035f0:	683b      	ldr	r3, [r7, #0]
 80035f2:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 80035f4:	683b      	ldr	r3, [r7, #0]
 80035f6:	685b      	ldr	r3, [r3, #4]
 80035f8:	683a      	ldr	r2, [r7, #0]
 80035fa:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 80035fc:	687b      	ldr	r3, [r7, #4]
 80035fe:	683a      	ldr	r2, [r7, #0]
 8003600:	605a      	str	r2, [r3, #4]
  return p;
 8003602:	683b      	ldr	r3, [r7, #0]
}
 8003604:	4618      	mov	r0, r3
 8003606:	370c      	adds	r7, #12
 8003608:	46bd      	mov	sp, r7
 800360a:	bc80      	pop	{r7}
 800360c:	4770      	bx	lr
 800360e:	bf00      	nop

08003610 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003610:	b480      	push	{r7}
 8003612:	b083      	sub	sp, #12
 8003614:	af00      	add	r7, sp, #0
 8003616:	6078      	str	r0, [r7, #4]
 8003618:	6039      	str	r1, [r7, #0]
    pqp = pqp->next;
 800361a:	687b      	ldr	r3, [r7, #4]
 800361c:	681b      	ldr	r3, [r3, #0]
 800361e:	607b      	str	r3, [r7, #4]
  } while (unlikely(pqp->prio > p->prio));
 8003620:	687b      	ldr	r3, [r7, #4]
 8003622:	689a      	ldr	r2, [r3, #8]
 8003624:	683b      	ldr	r3, [r7, #0]
 8003626:	689b      	ldr	r3, [r3, #8]
 8003628:	429a      	cmp	r2, r3
 800362a:	bf8c      	ite	hi
 800362c:	2301      	movhi	r3, #1
 800362e:	2300      	movls	r3, #0
 8003630:	b2db      	uxtb	r3, r3
 8003632:	2b00      	cmp	r3, #0
 8003634:	d1f1      	bne.n	800361a <ch_pqueue_insert_ahead+0xa>
  p->next       = pqp;
 8003636:	683b      	ldr	r3, [r7, #0]
 8003638:	687a      	ldr	r2, [r7, #4]
 800363a:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 800363c:	687b      	ldr	r3, [r7, #4]
 800363e:	685a      	ldr	r2, [r3, #4]
 8003640:	683b      	ldr	r3, [r7, #0]
 8003642:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003644:	683b      	ldr	r3, [r7, #0]
 8003646:	685b      	ldr	r3, [r3, #4]
 8003648:	683a      	ldr	r2, [r7, #0]
 800364a:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 800364c:	687b      	ldr	r3, [r7, #4]
 800364e:	683a      	ldr	r2, [r7, #0]
 8003650:	605a      	str	r2, [r3, #4]
  return p;
 8003652:	683b      	ldr	r3, [r7, #0]
}
 8003654:	4618      	mov	r0, r3
 8003656:	370c      	adds	r7, #12
 8003658:	46bd      	mov	sp, r7
 800365a:	bc80      	pop	{r7}
 800365c:	4770      	bx	lr
 800365e:	bf00      	nop

08003660 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8003660:	b580      	push	{r7, lr}
 8003662:	b082      	sub	sp, #8
 8003664:	af00      	add	r7, sp, #0
 8003666:	2330      	movs	r3, #48	; 0x30
 8003668:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800366a:	687b      	ldr	r3, [r7, #4]
 800366c:	f383 8811 	msr	BASEPRI, r3
}
 8003670:	bf00      	nop
}
 8003672:	bf00      	nop
}
 8003674:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003676:	f7ff f903 	bl	8002880 <__dbg_check_lock_from_isr>
}
 800367a:	bf00      	nop
 800367c:	3708      	adds	r7, #8
 800367e:	46bd      	mov	sp, r7
 8003680:	bd80      	pop	{r7, pc}
 8003682:	bf00      	nop
	...

08003690 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8003690:	b580      	push	{r7, lr}
 8003692:	b082      	sub	sp, #8
 8003694:	af00      	add	r7, sp, #0
  __dbg_check_unlock_from_isr();
 8003696:	f7ff f91b 	bl	80028d0 <__dbg_check_unlock_from_isr>
 800369a:	2300      	movs	r3, #0
 800369c:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800369e:	687b      	ldr	r3, [r7, #4]
 80036a0:	f383 8811 	msr	BASEPRI, r3
}
 80036a4:	bf00      	nop
}
 80036a6:	bf00      	nop
}
 80036a8:	bf00      	nop
}
 80036aa:	bf00      	nop
 80036ac:	3708      	adds	r7, #8
 80036ae:	46bd      	mov	sp, r7
 80036b0:	bd80      	pop	{r7, pc}
 80036b2:	bf00      	nop
	...

080036c0 <chVTIsArmedI>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 80036c0:	b580      	push	{r7, lr}
 80036c2:	b082      	sub	sp, #8
 80036c4:	af00      	add	r7, sp, #0
 80036c6:	6078      	str	r0, [r7, #4]
  chDbgCheckClassI();
 80036c8:	f7ff f9a2 	bl	8002a10 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 80036cc:	687b      	ldr	r3, [r7, #4]
 80036ce:	681b      	ldr	r3, [r3, #0]
 80036d0:	2b00      	cmp	r3, #0
 80036d2:	bf14      	ite	ne
 80036d4:	2301      	movne	r3, #1
 80036d6:	2300      	moveq	r3, #0
 80036d8:	b2db      	uxtb	r3, r3
}
 80036da:	4618      	mov	r0, r3
 80036dc:	3708      	adds	r7, #8
 80036de:	46bd      	mov	sp, r7
 80036e0:	bd80      	pop	{r7, pc}
 80036e2:	bf00      	nop
	...

080036f0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80036f0:	b580      	push	{r7, lr}
 80036f2:	b082      	sub	sp, #8
 80036f4:	af00      	add	r7, sp, #0
 80036f6:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 80036f8:	f7ff f98a 	bl	8002a10 <chDbgCheckClassI>

  sp->cnt++;
 80036fc:	687b      	ldr	r3, [r7, #4]
 80036fe:	689b      	ldr	r3, [r3, #8]
 8003700:	1c5a      	adds	r2, r3, #1
 8003702:	687b      	ldr	r3, [r7, #4]
 8003704:	609a      	str	r2, [r3, #8]
}
 8003706:	bf00      	nop
 8003708:	3708      	adds	r7, #8
 800370a:	46bd      	mov	sp, r7
 800370c:	bd80      	pop	{r7, pc}
 800370e:	bf00      	nop

08003710 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 8003710:	b580      	push	{r7, lr}
 8003712:	b082      	sub	sp, #8
 8003714:	af00      	add	r7, sp, #0
 8003716:	6078      	str	r0, [r7, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003718:	687b      	ldr	r3, [r7, #4]
 800371a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800371e:	2b00      	cmp	r3, #0
 8003720:	bf0c      	ite	eq
 8003722:	2301      	moveq	r3, #1
 8003724:	2300      	movne	r3, #0
 8003726:	b2db      	uxtb	r3, r3
 8003728:	2b00      	cmp	r3, #0
 800372a:	d109      	bne.n	8003740 <__sch_ready_behind+0x30>
 800372c:	687b      	ldr	r3, [r7, #4]
 800372e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8003732:	2b0f      	cmp	r3, #15
 8003734:	bf0c      	ite	eq
 8003736:	2301      	moveq	r3, #1
 8003738:	2300      	movne	r3, #0
 800373a:	b2db      	uxtb	r3, r3
 800373c:	2b00      	cmp	r3, #0
 800373e:	d002      	beq.n	8003746 <__sch_ready_behind+0x36>
 8003740:	480c      	ldr	r0, [pc, #48]	; (8003774 <__sch_ready_behind+0x64>)
 8003742:	f7fe fff5 	bl	8002730 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8003746:	687b      	ldr	r3, [r7, #4]
 8003748:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800374a:	4619      	mov	r1, r3
 800374c:	6878      	ldr	r0, [r7, #4]
 800374e:	f7ff fa27 	bl	8002ba0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003752:	687b      	ldr	r3, [r7, #4]
 8003754:	2200      	movs	r2, #0
 8003756:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 800375a:	687b      	ldr	r3, [r7, #4]
 800375c:	699b      	ldr	r3, [r3, #24]
 800375e:	461a      	mov	r2, r3
 8003760:	687b      	ldr	r3, [r7, #4]
 8003762:	4619      	mov	r1, r3
 8003764:	4610      	mov	r0, r2
 8003766:	f7ff ff2b 	bl	80035c0 <ch_pqueue_insert_behind>
 800376a:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 800376c:	4618      	mov	r0, r3
 800376e:	3708      	adds	r7, #8
 8003770:	46bd      	mov	sp, r7
 8003772:	bd80      	pop	{r7, pc}
 8003774:	08004fcc 	.word	0x08004fcc
	...

08003780 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003780:	b580      	push	{r7, lr}
 8003782:	b082      	sub	sp, #8
 8003784:	af00      	add	r7, sp, #0
 8003786:	6078      	str	r0, [r7, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003788:	687b      	ldr	r3, [r7, #4]
 800378a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800378e:	2b00      	cmp	r3, #0
 8003790:	bf0c      	ite	eq
 8003792:	2301      	moveq	r3, #1
 8003794:	2300      	movne	r3, #0
 8003796:	b2db      	uxtb	r3, r3
 8003798:	2b00      	cmp	r3, #0
 800379a:	d109      	bne.n	80037b0 <__sch_ready_ahead+0x30>
 800379c:	687b      	ldr	r3, [r7, #4]
 800379e:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80037a2:	2b0f      	cmp	r3, #15
 80037a4:	bf0c      	ite	eq
 80037a6:	2301      	moveq	r3, #1
 80037a8:	2300      	movne	r3, #0
 80037aa:	b2db      	uxtb	r3, r3
 80037ac:	2b00      	cmp	r3, #0
 80037ae:	d002      	beq.n	80037b6 <__sch_ready_ahead+0x36>
 80037b0:	480c      	ldr	r0, [pc, #48]	; (80037e4 <__sch_ready_ahead+0x64>)
 80037b2:	f7fe ffbd 	bl	8002730 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 80037b6:	687b      	ldr	r3, [r7, #4]
 80037b8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80037ba:	4619      	mov	r1, r3
 80037bc:	6878      	ldr	r0, [r7, #4]
 80037be:	f7ff f9ef 	bl	8002ba0 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 80037c2:	687b      	ldr	r3, [r7, #4]
 80037c4:	2200      	movs	r2, #0
 80037c6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 80037ca:	687b      	ldr	r3, [r7, #4]
 80037cc:	699b      	ldr	r3, [r3, #24]
 80037ce:	461a      	mov	r2, r3
 80037d0:	687b      	ldr	r3, [r7, #4]
 80037d2:	4619      	mov	r1, r3
 80037d4:	4610      	mov	r0, r2
 80037d6:	f7ff ff1b 	bl	8003610 <ch_pqueue_insert_ahead>
 80037da:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 80037dc:	4618      	mov	r0, r3
 80037de:	3708      	adds	r7, #8
 80037e0:	46bd      	mov	sp, r7
 80037e2:	bd80      	pop	{r7, pc}
 80037e4:	08004fe0 	.word	0x08004fe0
	...

080037f0 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 80037f0:	b580      	push	{r7, lr}
 80037f2:	b084      	sub	sp, #16
 80037f4:	af00      	add	r7, sp, #0
 80037f6:	6078      	str	r0, [r7, #4]
 80037f8:	6039      	str	r1, [r7, #0]
  thread_t *tp = threadref(p);
 80037fa:	683b      	ldr	r3, [r7, #0]
 80037fc:	60fb      	str	r3, [r7, #12]

  (void)vtp;

  chSysLockFromISR();
 80037fe:	f7ff ff2f 	bl	8003660 <chSysLockFromISR>
  switch (tp->state) {
 8003802:	68fb      	ldr	r3, [r7, #12]
 8003804:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8003808:	2b0c      	cmp	r3, #12
 800380a:	d82f      	bhi.n	800386c <__sch_wakeup+0x7c>
 800380c:	a201      	add	r2, pc, #4	; (adr r2, 8003814 <__sch_wakeup+0x24>)
 800380e:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8003812:	bf00      	nop
 8003814:	08003849 	.word	0x08003849
 8003818:	0800386d 	.word	0x0800386d
 800381c:	0800386d 	.word	0x0800386d
 8003820:	0800384f 	.word	0x0800384f
 8003824:	08003863 	.word	0x08003863
 8003828:	08003859 	.word	0x08003859
 800382c:	0800386d 	.word	0x0800386d
 8003830:	08003863 	.word	0x08003863
 8003834:	0800386d 	.word	0x0800386d
 8003838:	0800386d 	.word	0x0800386d
 800383c:	0800386d 	.word	0x0800386d
 8003840:	0800386d 	.word	0x0800386d
 8003844:	08003863 	.word	0x08003863
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003848:	f7ff ff22 	bl	8003690 <chSysUnlockFromISR>
    return;
 800384c:	e019      	b.n	8003882 <__sch_wakeup+0x92>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800384e:	68fb      	ldr	r3, [r7, #12]
 8003850:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003852:	2200      	movs	r2, #0
 8003854:	601a      	str	r2, [r3, #0]
    break;
 8003856:	e00a      	b.n	800386e <__sch_wakeup+0x7e>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003858:	68fb      	ldr	r3, [r7, #12]
 800385a:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800385c:	4618      	mov	r0, r3
 800385e:	f7ff ff47 	bl	80036f0 <chSemFastSignalI>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 8003862:	68fb      	ldr	r3, [r7, #12]
 8003864:	4618      	mov	r0, r3
 8003866:	f7ff fe7b 	bl	8003560 <ch_queue_dequeue>
    break;
 800386a:	e000      	b.n	800386e <__sch_wakeup+0x7e>
  default:
    /* Any other state, nothing to do.*/
    break;
 800386c:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 800386e:	68fb      	ldr	r3, [r7, #12]
 8003870:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003874:	629a      	str	r2, [r3, #40]	; 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003876:	68f8      	ldr	r0, [r7, #12]
 8003878:	f7ff ff4a 	bl	8003710 <__sch_ready_behind>
  chSysUnlockFromISR();
 800387c:	f7ff ff08 	bl	8003690 <chSysUnlockFromISR>

  return;
 8003880:	bf00      	nop
}
 8003882:	3710      	adds	r7, #16
 8003884:	46bd      	mov	sp, r7
 8003886:	bd80      	pop	{r7, pc}
	...

08003890 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003890:	b580      	push	{r7, lr}
 8003892:	b082      	sub	sp, #8
 8003894:	af00      	add	r7, sp, #0
 8003896:	6078      	str	r0, [r7, #4]

  chDbgCheckClassI();
 8003898:	f7ff f8ba 	bl	8002a10 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800389c:	687b      	ldr	r3, [r7, #4]
 800389e:	2b00      	cmp	r3, #0
 80038a0:	bf0c      	ite	eq
 80038a2:	2301      	moveq	r3, #1
 80038a4:	2300      	movne	r3, #0
 80038a6:	b2db      	uxtb	r3, r3
 80038a8:	2b00      	cmp	r3, #0
 80038aa:	d002      	beq.n	80038b2 <chSchReadyI+0x22>
 80038ac:	4805      	ldr	r0, [pc, #20]	; (80038c4 <chSchReadyI+0x34>)
 80038ae:	f7fe ff3f 	bl	8002730 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 80038b2:	6878      	ldr	r0, [r7, #4]
 80038b4:	f7ff ff2c 	bl	8003710 <__sch_ready_behind>
 80038b8:	4603      	mov	r3, r0
}
 80038ba:	4618      	mov	r0, r3
 80038bc:	3708      	adds	r7, #8
 80038be:	46bd      	mov	sp, r7
 80038c0:	bd80      	pop	{r7, pc}
 80038c2:	bf00      	nop
 80038c4:	08004ff4 	.word	0x08004ff4
	...

080038d0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80038d0:	b580      	push	{r7, lr}
 80038d2:	b088      	sub	sp, #32
 80038d4:	af00      	add	r7, sp, #0
 80038d6:	4603      	mov	r3, r0
 80038d8:	71fb      	strb	r3, [r7, #7]
  os_instance_t *oip = currcore;
 80038da:	4b26      	ldr	r3, [pc, #152]	; (8003974 <chSchGoSleepS+0xa4>)
 80038dc:	61fb      	str	r3, [r7, #28]
  thread_t *otp = __instance_get_currthread(oip);
 80038de:	69fb      	ldr	r3, [r7, #28]
 80038e0:	68db      	ldr	r3, [r3, #12]
 80038e2:	61bb      	str	r3, [r7, #24]
  thread_t *ntp;

  chDbgCheckClassS();
 80038e4:	f7ff f8bc 	bl	8002a60 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 80038e8:	f7fe ff3a 	bl	8002760 <chSysGetIdleThreadX>
 80038ec:	4602      	mov	r2, r0
 80038ee:	69bb      	ldr	r3, [r7, #24]
 80038f0:	4293      	cmp	r3, r2
 80038f2:	bf0c      	ite	eq
 80038f4:	2301      	moveq	r3, #1
 80038f6:	2300      	movne	r3, #0
 80038f8:	b2db      	uxtb	r3, r3
 80038fa:	2b00      	cmp	r3, #0
 80038fc:	d002      	beq.n	8003904 <chSchGoSleepS+0x34>
 80038fe:	481e      	ldr	r0, [pc, #120]	; (8003978 <chSchGoSleepS+0xa8>)
 8003900:	f7fe ff16 	bl	8002730 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 8003904:	69bb      	ldr	r3, [r7, #24]
 8003906:	699b      	ldr	r3, [r3, #24]
 8003908:	69fa      	ldr	r2, [r7, #28]
 800390a:	429a      	cmp	r2, r3
 800390c:	bf14      	ite	ne
 800390e:	2301      	movne	r3, #1
 8003910:	2300      	moveq	r3, #0
 8003912:	b2db      	uxtb	r3, r3
 8003914:	2b00      	cmp	r3, #0
 8003916:	d002      	beq.n	800391e <chSchGoSleepS+0x4e>
 8003918:	4817      	ldr	r0, [pc, #92]	; (8003978 <chSchGoSleepS+0xa8>)
 800391a:	f7fe ff09 	bl	8002730 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 800391e:	69bb      	ldr	r3, [r7, #24]
 8003920:	79fa      	ldrb	r2, [r7, #7]
 8003922:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003926:	69fb      	ldr	r3, [r7, #28]
 8003928:	4618      	mov	r0, r3
 800392a:	f7ff fe31 	bl	8003590 <ch_pqueue_remove_highest>
 800392e:	6178      	str	r0, [r7, #20]
  ntp->state = CH_STATE_CURRENT;
 8003930:	697b      	ldr	r3, [r7, #20]
 8003932:	2201      	movs	r2, #1
 8003934:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8003938:	69fb      	ldr	r3, [r7, #28]
 800393a:	697a      	ldr	r2, [r7, #20]
 800393c:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800393e:	69b9      	ldr	r1, [r7, #24]
 8003940:	6978      	ldr	r0, [r7, #20]
 8003942:	f7ff f965 	bl	8002c10 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003946:	f3ef 8309 	mrs	r3, PSP
 800394a:	60fb      	str	r3, [r7, #12]
  return(result);
 800394c:	68fb      	ldr	r3, [r7, #12]
 800394e:	613b      	str	r3, [r7, #16]
 8003950:	693b      	ldr	r3, [r7, #16]
 8003952:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003956:	69bb      	ldr	r3, [r7, #24]
 8003958:	6a1b      	ldr	r3, [r3, #32]
 800395a:	429a      	cmp	r2, r3
 800395c:	d202      	bcs.n	8003964 <chSchGoSleepS+0x94>
 800395e:	4807      	ldr	r0, [pc, #28]	; (800397c <chSchGoSleepS+0xac>)
 8003960:	f7fe fee6 	bl	8002730 <chSysHalt>
 8003964:	69b9      	ldr	r1, [r7, #24]
 8003966:	6978      	ldr	r0, [r7, #20]
 8003968:	f7fc fcaa 	bl	80002c0 <__port_switch>
}
 800396c:	bf00      	nop
 800396e:	3720      	adds	r7, #32
 8003970:	46bd      	mov	sp, r7
 8003972:	bd80      	pop	{r7, pc}
 8003974:	20000900 	.word	0x20000900
 8003978:	08005000 	.word	0x08005000
 800397c:	08004af8 	.word	0x08004af8

08003980 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003980:	b580      	push	{r7, lr}
 8003982:	b08a      	sub	sp, #40	; 0x28
 8003984:	af00      	add	r7, sp, #0
 8003986:	4603      	mov	r3, r0
 8003988:	6039      	str	r1, [r7, #0]
 800398a:	71fb      	strb	r3, [r7, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 800398c:	4b15      	ldr	r3, [pc, #84]	; (80039e4 <chSchGoSleepTimeoutS+0x64>)
 800398e:	68db      	ldr	r3, [r3, #12]
 8003990:	627b      	str	r3, [r7, #36]	; 0x24

  chDbgCheckClassS();
 8003992:	f7ff f865 	bl	8002a60 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003996:	683b      	ldr	r3, [r7, #0]
 8003998:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800399c:	d018      	beq.n	80039d0 <chSchGoSleepTimeoutS+0x50>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800399e:	f107 000c 	add.w	r0, r7, #12
 80039a2:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039a4:	4a10      	ldr	r2, [pc, #64]	; (80039e8 <chSchGoSleepTimeoutS+0x68>)
 80039a6:	6839      	ldr	r1, [r7, #0]
 80039a8:	f7ff fc6a 	bl	8003280 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80039ac:	79fb      	ldrb	r3, [r7, #7]
 80039ae:	4618      	mov	r0, r3
 80039b0:	f7ff ff8e 	bl	80038d0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80039b4:	f107 030c 	add.w	r3, r7, #12
 80039b8:	4618      	mov	r0, r3
 80039ba:	f7ff fe81 	bl	80036c0 <chVTIsArmedI>
 80039be:	4603      	mov	r3, r0
 80039c0:	2b00      	cmp	r3, #0
 80039c2:	d009      	beq.n	80039d8 <chSchGoSleepTimeoutS+0x58>
      chVTDoResetI(&vt);
 80039c4:	f107 030c 	add.w	r3, r7, #12
 80039c8:	4618      	mov	r0, r3
 80039ca:	f7ff fca1 	bl	8003310 <chVTDoResetI>
 80039ce:	e003      	b.n	80039d8 <chSchGoSleepTimeoutS+0x58>
    }
  }
  else {
    chSchGoSleepS(newstate);
 80039d0:	79fb      	ldrb	r3, [r7, #7]
 80039d2:	4618      	mov	r0, r3
 80039d4:	f7ff ff7c 	bl	80038d0 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 80039d8:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 80039da:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 80039dc:	4618      	mov	r0, r3
 80039de:	3728      	adds	r7, #40	; 0x28
 80039e0:	46bd      	mov	sp, r7
 80039e2:	bd80      	pop	{r7, pc}
 80039e4:	20000900 	.word	0x20000900
 80039e8:	080037f1 	.word	0x080037f1
 80039ec:	00000000 	.word	0x00000000

080039f0 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80039f0:	b580      	push	{r7, lr}
 80039f2:	b086      	sub	sp, #24
 80039f4:	af00      	add	r7, sp, #0
 80039f6:	6078      	str	r0, [r7, #4]
 80039f8:	6039      	str	r1, [r7, #0]
  os_instance_t *oip = currcore;
 80039fa:	4b2c      	ldr	r3, [pc, #176]	; (8003aac <chSchWakeupS+0xbc>)
 80039fc:	617b      	str	r3, [r7, #20]
  thread_t *otp = __instance_get_currthread(oip);
 80039fe:	697b      	ldr	r3, [r7, #20]
 8003a00:	68db      	ldr	r3, [r3, #12]
 8003a02:	613b      	str	r3, [r7, #16]

  chDbgCheckClassS();
 8003a04:	f7ff f82c 	bl	8002a60 <chDbgCheckClassS>

  chDbgAssert((oip->rlist.pqueue.next == &oip->rlist.pqueue) ||
 8003a08:	697b      	ldr	r3, [r7, #20]
 8003a0a:	681a      	ldr	r2, [r3, #0]
 8003a0c:	697b      	ldr	r3, [r7, #20]
 8003a0e:	429a      	cmp	r2, r3
 8003a10:	bf14      	ite	ne
 8003a12:	2301      	movne	r3, #1
 8003a14:	2300      	moveq	r3, #0
 8003a16:	b2db      	uxtb	r3, r3
 8003a18:	2b00      	cmp	r3, #0
 8003a1a:	d00f      	beq.n	8003a3c <chSchWakeupS+0x4c>
 8003a1c:	697b      	ldr	r3, [r7, #20]
 8003a1e:	68db      	ldr	r3, [r3, #12]
 8003a20:	689a      	ldr	r2, [r3, #8]
 8003a22:	697b      	ldr	r3, [r7, #20]
 8003a24:	681b      	ldr	r3, [r3, #0]
 8003a26:	689b      	ldr	r3, [r3, #8]
 8003a28:	429a      	cmp	r2, r3
 8003a2a:	bf34      	ite	cc
 8003a2c:	2301      	movcc	r3, #1
 8003a2e:	2300      	movcs	r3, #0
 8003a30:	b2db      	uxtb	r3, r3
 8003a32:	2b00      	cmp	r3, #0
 8003a34:	d002      	beq.n	8003a3c <chSchWakeupS+0x4c>
 8003a36:	481e      	ldr	r0, [pc, #120]	; (8003ab0 <chSchWakeupS+0xc0>)
 8003a38:	f7fe fe7a 	bl	8002730 <chSysHalt>
              (oip->rlist.current->hdr.pqueue.prio >= oip->rlist.pqueue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 8003a3c:	687b      	ldr	r3, [r7, #4]
 8003a3e:	683a      	ldr	r2, [r7, #0]
 8003a40:	629a      	str	r2, [r3, #40]	; 0x28
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.
     Note, we are favoring the path where the woken thread has higher
     priority.*/
  if (unlikely(ntp->hdr.pqueue.prio <= otp->hdr.pqueue.prio)) {
 8003a42:	687b      	ldr	r3, [r7, #4]
 8003a44:	689a      	ldr	r2, [r3, #8]
 8003a46:	693b      	ldr	r3, [r7, #16]
 8003a48:	689b      	ldr	r3, [r3, #8]
 8003a4a:	429a      	cmp	r2, r3
 8003a4c:	bf94      	ite	ls
 8003a4e:	2301      	movls	r3, #1
 8003a50:	2300      	movhi	r3, #0
 8003a52:	b2db      	uxtb	r3, r3
 8003a54:	2b00      	cmp	r3, #0
 8003a56:	d003      	beq.n	8003a60 <chSchWakeupS+0x70>
    (void) __sch_ready_behind(ntp);
 8003a58:	6878      	ldr	r0, [r7, #4]
 8003a5a:	f7ff fe59 	bl	8003710 <__sch_ready_behind>
    __instance_set_currthread(oip, ntp);

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8003a5e:	e021      	b.n	8003aa4 <chSchWakeupS+0xb4>
    otp = __sch_ready_ahead(otp);
 8003a60:	6938      	ldr	r0, [r7, #16]
 8003a62:	f7ff fe8d 	bl	8003780 <__sch_ready_ahead>
 8003a66:	6138      	str	r0, [r7, #16]
    ntp->state = CH_STATE_CURRENT;
 8003a68:	687b      	ldr	r3, [r7, #4]
 8003a6a:	2201      	movs	r2, #1
 8003a6c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
    __instance_set_currthread(oip, ntp);
 8003a70:	697b      	ldr	r3, [r7, #20]
 8003a72:	687a      	ldr	r2, [r7, #4]
 8003a74:	60da      	str	r2, [r3, #12]
    chSysSwitch(ntp, otp);
 8003a76:	6939      	ldr	r1, [r7, #16]
 8003a78:	6878      	ldr	r0, [r7, #4]
 8003a7a:	f7ff f8c9 	bl	8002c10 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003a7e:	f3ef 8309 	mrs	r3, PSP
 8003a82:	60bb      	str	r3, [r7, #8]
  return(result);
 8003a84:	68bb      	ldr	r3, [r7, #8]
 8003a86:	60fb      	str	r3, [r7, #12]
 8003a88:	68fb      	ldr	r3, [r7, #12]
 8003a8a:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003a8e:	693b      	ldr	r3, [r7, #16]
 8003a90:	6a1b      	ldr	r3, [r3, #32]
 8003a92:	429a      	cmp	r2, r3
 8003a94:	d202      	bcs.n	8003a9c <chSchWakeupS+0xac>
 8003a96:	4807      	ldr	r0, [pc, #28]	; (8003ab4 <chSchWakeupS+0xc4>)
 8003a98:	f7fe fe4a 	bl	8002730 <chSysHalt>
 8003a9c:	6939      	ldr	r1, [r7, #16]
 8003a9e:	6878      	ldr	r0, [r7, #4]
 8003aa0:	f7fc fc0e 	bl	80002c0 <__port_switch>
}
 8003aa4:	bf00      	nop
 8003aa6:	3718      	adds	r7, #24
 8003aa8:	46bd      	mov	sp, r7
 8003aaa:	bd80      	pop	{r7, pc}
 8003aac:	20000900 	.word	0x20000900
 8003ab0:	08005010 	.word	0x08005010
 8003ab4:	08004af8 	.word	0x08004af8
	...

08003ac0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8003ac0:	b480      	push	{r7}
 8003ac2:	b085      	sub	sp, #20
 8003ac4:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8003ac6:	4b0c      	ldr	r3, [pc, #48]	; (8003af8 <chSchIsPreemptionRequired+0x38>)
 8003ac8:	60fb      	str	r3, [r7, #12]
  thread_t *tp = __instance_get_currthread(oip);
 8003aca:	68fb      	ldr	r3, [r7, #12]
 8003acc:	68db      	ldr	r3, [r3, #12]
 8003ace:	60bb      	str	r3, [r7, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 8003ad0:	68fb      	ldr	r3, [r7, #12]
 8003ad2:	681b      	ldr	r3, [r3, #0]
 8003ad4:	689b      	ldr	r3, [r3, #8]
 8003ad6:	607b      	str	r3, [r7, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 8003ad8:	68bb      	ldr	r3, [r7, #8]
 8003ada:	689b      	ldr	r3, [r3, #8]
 8003adc:	603b      	str	r3, [r7, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 8003ade:	687a      	ldr	r2, [r7, #4]
 8003ae0:	683b      	ldr	r3, [r7, #0]
 8003ae2:	429a      	cmp	r2, r3
 8003ae4:	bf8c      	ite	hi
 8003ae6:	2301      	movhi	r3, #1
 8003ae8:	2300      	movls	r3, #0
 8003aea:	b2db      	uxtb	r3, r3
#endif
}
 8003aec:	4618      	mov	r0, r3
 8003aee:	3714      	adds	r7, #20
 8003af0:	46bd      	mov	sp, r7
 8003af2:	bc80      	pop	{r7}
 8003af4:	4770      	bx	lr
 8003af6:	bf00      	nop
 8003af8:	20000900 	.word	0x20000900
 8003afc:	00000000 	.word	0x00000000

08003b00 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003b00:	b580      	push	{r7, lr}
 8003b02:	b086      	sub	sp, #24
 8003b04:	af00      	add	r7, sp, #0
  os_instance_t *oip = currcore;
 8003b06:	4b18      	ldr	r3, [pc, #96]	; (8003b68 <chSchDoPreemption+0x68>)
 8003b08:	617b      	str	r3, [r7, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8003b0a:	697b      	ldr	r3, [r7, #20]
 8003b0c:	68db      	ldr	r3, [r3, #12]
 8003b0e:	613b      	str	r3, [r7, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 8003b10:	697b      	ldr	r3, [r7, #20]
 8003b12:	4618      	mov	r0, r3
 8003b14:	f7ff fd3c 	bl	8003590 <ch_pqueue_remove_highest>
 8003b18:	60f8      	str	r0, [r7, #12]
  ntp->state = CH_STATE_CURRENT;
 8003b1a:	68fb      	ldr	r3, [r7, #12]
 8003b1c:	2201      	movs	r2, #1
 8003b1e:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8003b22:	697b      	ldr	r3, [r7, #20]
 8003b24:	68fa      	ldr	r2, [r7, #12]
 8003b26:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003b28:	6938      	ldr	r0, [r7, #16]
 8003b2a:	f7ff fe29 	bl	8003780 <__sch_ready_ahead>
 8003b2e:	6138      	str	r0, [r7, #16]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003b30:	6939      	ldr	r1, [r7, #16]
 8003b32:	68f8      	ldr	r0, [r7, #12]
 8003b34:	f7ff f86c 	bl	8002c10 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003b38:	f3ef 8309 	mrs	r3, PSP
 8003b3c:	607b      	str	r3, [r7, #4]
  return(result);
 8003b3e:	687b      	ldr	r3, [r7, #4]
 8003b40:	60bb      	str	r3, [r7, #8]
 8003b42:	68bb      	ldr	r3, [r7, #8]
 8003b44:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003b48:	693b      	ldr	r3, [r7, #16]
 8003b4a:	6a1b      	ldr	r3, [r3, #32]
 8003b4c:	429a      	cmp	r2, r3
 8003b4e:	d202      	bcs.n	8003b56 <chSchDoPreemption+0x56>
 8003b50:	4806      	ldr	r0, [pc, #24]	; (8003b6c <chSchDoPreemption+0x6c>)
 8003b52:	f7fe fded 	bl	8002730 <chSysHalt>
 8003b56:	6939      	ldr	r1, [r7, #16]
 8003b58:	68f8      	ldr	r0, [r7, #12]
 8003b5a:	f7fc fbb1 	bl	80002c0 <__port_switch>
}
 8003b5e:	bf00      	nop
 8003b60:	3718      	adds	r7, #24
 8003b62:	46bd      	mov	sp, r7
 8003b64:	bd80      	pop	{r7, pc}
 8003b66:	bf00      	nop
 8003b68:	20000900 	.word	0x20000900
 8003b6c:	08004af8 	.word	0x08004af8

08003b70 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8003b70:	b480      	push	{r7}
 8003b72:	b083      	sub	sp, #12
 8003b74:	af00      	add	r7, sp, #0
 8003b76:	6078      	str	r0, [r7, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8003b78:	687b      	ldr	r3, [r7, #4]
 8003b7a:	2200      	movs	r2, #0
 8003b7c:	601a      	str	r2, [r3, #0]
}
 8003b7e:	bf00      	nop
 8003b80:	370c      	adds	r7, #12
 8003b82:	46bd      	mov	sp, r7
 8003b84:	bc80      	pop	{r7}
 8003b86:	4770      	bx	lr
	...

08003b90 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8003b90:	b480      	push	{r7}
 8003b92:	b083      	sub	sp, #12
 8003b94:	af00      	add	r7, sp, #0
 8003b96:	6078      	str	r0, [r7, #4]

  sdp->panic_msg = NULL;
 8003b98:	687b      	ldr	r3, [r7, #4]
 8003b9a:	2200      	movs	r2, #0
 8003b9c:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 8003b9e:	687b      	ldr	r3, [r7, #4]
 8003ba0:	2200      	movs	r2, #0
 8003ba2:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8003ba4:	687b      	ldr	r3, [r7, #4]
 8003ba6:	2201      	movs	r2, #1
 8003ba8:	609a      	str	r2, [r3, #8]
#endif
}
 8003baa:	bf00      	nop
 8003bac:	370c      	adds	r7, #12
 8003bae:	46bd      	mov	sp, r7
 8003bb0:	bc80      	pop	{r7}
 8003bb2:	4770      	bx	lr
	...

08003bc0 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003bc0:	b480      	push	{r7}
 8003bc2:	b083      	sub	sp, #12
 8003bc4:	af00      	add	r7, sp, #0
 8003bc6:	6078      	str	r0, [r7, #4]
  qp->next = qp;
 8003bc8:	687b      	ldr	r3, [r7, #4]
 8003bca:	687a      	ldr	r2, [r7, #4]
 8003bcc:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003bce:	687b      	ldr	r3, [r7, #4]
 8003bd0:	687a      	ldr	r2, [r7, #4]
 8003bd2:	605a      	str	r2, [r3, #4]
}
 8003bd4:	bf00      	nop
 8003bd6:	370c      	adds	r7, #12
 8003bd8:	46bd      	mov	sp, r7
 8003bda:	bc80      	pop	{r7}
 8003bdc:	4770      	bx	lr
 8003bde:	bf00      	nop

08003be0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 8003be0:	b480      	push	{r7}
 8003be2:	b083      	sub	sp, #12
 8003be4:	af00      	add	r7, sp, #0
 8003be6:	6078      	str	r0, [r7, #4]
  pqp->next = pqp;
 8003be8:	687b      	ldr	r3, [r7, #4]
 8003bea:	687a      	ldr	r2, [r7, #4]
 8003bec:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 8003bee:	687b      	ldr	r3, [r7, #4]
 8003bf0:	687a      	ldr	r2, [r7, #4]
 8003bf2:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 8003bf4:	687b      	ldr	r3, [r7, #4]
 8003bf6:	2200      	movs	r2, #0
 8003bf8:	609a      	str	r2, [r3, #8]
}
 8003bfa:	bf00      	nop
 8003bfc:	370c      	adds	r7, #12
 8003bfe:	46bd      	mov	sp, r7
 8003c00:	bc80      	pop	{r7}
 8003c02:	4770      	bx	lr
	...

08003c10 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 8003c10:	b480      	push	{r7}
 8003c12:	b083      	sub	sp, #12
 8003c14:	af00      	add	r7, sp, #0
 8003c16:	6078      	str	r0, [r7, #4]
  dlhp->next  = dlhp;
 8003c18:	687b      	ldr	r3, [r7, #4]
 8003c1a:	687a      	ldr	r2, [r7, #4]
 8003c1c:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 8003c1e:	687b      	ldr	r3, [r7, #4]
 8003c20:	687a      	ldr	r2, [r7, #4]
 8003c22:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 8003c24:	687b      	ldr	r3, [r7, #4]
 8003c26:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003c2a:	609a      	str	r2, [r3, #8]
}
 8003c2c:	bf00      	nop
 8003c2e:	370c      	adds	r7, #12
 8003c30:	46bd      	mov	sp, r7
 8003c32:	bc80      	pop	{r7}
 8003c34:	4770      	bx	lr
 8003c36:	bf00      	nop
	...

08003c40 <port_timer_get_time>:
static inline systime_t port_timer_get_time(void) {
 8003c40:	b580      	push	{r7, lr}
 8003c42:	af00      	add	r7, sp, #0
  return stGetCounter();
 8003c44:	f7fc fc2c 	bl	80004a0 <stGetCounter>
 8003c48:	4603      	mov	r3, r0
}
 8003c4a:	4618      	mov	r0, r3
 8003c4c:	bd80      	pop	{r7, pc}
 8003c4e:	bf00      	nop

08003c50 <chVTGetSystemTimeX>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003c50:	b580      	push	{r7, lr}
 8003c52:	af00      	add	r7, sp, #0
  return port_timer_get_time();
 8003c54:	f7ff fff4 	bl	8003c40 <port_timer_get_time>
 8003c58:	4603      	mov	r3, r0
}
 8003c5a:	4618      	mov	r0, r3
 8003c5c:	bd80      	pop	{r7, pc}
 8003c5e:	bf00      	nop

08003c60 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003c60:	b5b0      	push	{r4, r5, r7, lr}
 8003c62:	b082      	sub	sp, #8
 8003c64:	af00      	add	r7, sp, #0
 8003c66:	6078      	str	r0, [r7, #4]

  ch_dlist_init(&vtlp->dlist);
 8003c68:	687b      	ldr	r3, [r7, #4]
 8003c6a:	4618      	mov	r0, r3
 8003c6c:	f7ff ffd0 	bl	8003c10 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 8003c70:	687b      	ldr	r3, [r7, #4]
 8003c72:	2200      	movs	r2, #0
 8003c74:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003c76:	f7ff ffeb 	bl	8003c50 <chVTGetSystemTimeX>
 8003c7a:	4603      	mov	r3, r0
 8003c7c:	2200      	movs	r2, #0
 8003c7e:	461c      	mov	r4, r3
 8003c80:	4615      	mov	r5, r2
 8003c82:	687b      	ldr	r3, [r7, #4]
 8003c84:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003c88:	bf00      	nop
 8003c8a:	3708      	adds	r7, #8
 8003c8c:	46bd      	mov	sp, r7
 8003c8e:	bdb0      	pop	{r4, r5, r7, pc}

08003c90 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003c90:	b580      	push	{r7, lr}
 8003c92:	b082      	sub	sp, #8
 8003c94:	af00      	add	r7, sp, #0
 8003c96:	6078      	str	r0, [r7, #4]

  ch_queue_init(&rp->queue);
 8003c98:	687b      	ldr	r3, [r7, #4]
 8003c9a:	4618      	mov	r0, r3
 8003c9c:	f7ff ff90 	bl	8003bc0 <ch_queue_init>
}
 8003ca0:	bf00      	nop
 8003ca2:	3708      	adds	r7, #8
 8003ca4:	46bd      	mov	sp, r7
 8003ca6:	bd80      	pop	{r7, pc}
	...

08003cb0 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003cb0:	b480      	push	{r7}
 8003cb2:	b083      	sub	sp, #12
 8003cb4:	af00      	add	r7, sp, #0
 8003cb6:	6078      	str	r0, [r7, #4]
}
 8003cb8:	bf00      	nop
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8003cba:	e7fd      	b.n	8003cb8 <__idle_thread+0x8>
 8003cbc:	0000      	movs	r0, r0
	...

08003cc0 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8003cc0:	b580      	push	{r7, lr}
 8003cc2:	b08a      	sub	sp, #40	; 0x28
 8003cc4:	af00      	add	r7, sp, #0
 8003cc6:	6078      	str	r0, [r7, #4]
 8003cc8:	6039      	str	r1, [r7, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8003cca:	2300      	movs	r3, #0
 8003ccc:	627b      	str	r3, [r7, #36]	; 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 8003cce:	4a36      	ldr	r2, [pc, #216]	; (8003da8 <chInstanceObjectInit+0xe8>)
 8003cd0:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003cd2:	009b      	lsls	r3, r3, #2
 8003cd4:	4413      	add	r3, r2
 8003cd6:	685b      	ldr	r3, [r3, #4]
 8003cd8:	2b00      	cmp	r3, #0
 8003cda:	bf14      	ite	ne
 8003cdc:	2301      	movne	r3, #1
 8003cde:	2300      	moveq	r3, #0
 8003ce0:	b2db      	uxtb	r3, r3
 8003ce2:	2b00      	cmp	r3, #0
 8003ce4:	d002      	beq.n	8003cec <chInstanceObjectInit+0x2c>
 8003ce6:	4831      	ldr	r0, [pc, #196]	; (8003dac <chInstanceObjectInit+0xec>)
 8003ce8:	f7fe fd22 	bl	8002730 <chSysHalt>
  ch_system.instances[core_id] = oip;
 8003cec:	4a2e      	ldr	r2, [pc, #184]	; (8003da8 <chInstanceObjectInit+0xe8>)
 8003cee:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 8003cf0:	009b      	lsls	r3, r3, #2
 8003cf2:	4413      	add	r3, r2
 8003cf4:	687a      	ldr	r2, [r7, #4]
 8003cf6:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 8003cf8:	687b      	ldr	r3, [r7, #4]
 8003cfa:	6a7a      	ldr	r2, [r7, #36]	; 0x24
 8003cfc:	631a      	str	r2, [r3, #48]	; 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 8003cfe:	687b      	ldr	r3, [r7, #4]
 8003d00:	683a      	ldr	r2, [r7, #0]
 8003d02:	639a      	str	r2, [r3, #56]	; 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 8003d04:	6878      	ldr	r0, [r7, #4]
 8003d06:	f000 fdc3 	bl	8004890 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 8003d0a:	687b      	ldr	r3, [r7, #4]
 8003d0c:	4618      	mov	r0, r3
 8003d0e:	f7ff ff67 	bl	8003be0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 8003d12:	687b      	ldr	r3, [r7, #4]
 8003d14:	3328      	adds	r3, #40	; 0x28
 8003d16:	4618      	mov	r0, r3
 8003d18:	f7ff ffba 	bl	8003c90 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 8003d1c:	687b      	ldr	r3, [r7, #4]
 8003d1e:	3334      	adds	r3, #52	; 0x34
 8003d20:	4618      	mov	r0, r3
 8003d22:	f7ff ff25 	bl	8003b70 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 8003d26:	687b      	ldr	r3, [r7, #4]
 8003d28:	3310      	adds	r3, #16
 8003d2a:	4618      	mov	r0, r3
 8003d2c:	f7ff ff98 	bl	8003c60 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 8003d30:	687b      	ldr	r3, [r7, #4]
 8003d32:	3384      	adds	r3, #132	; 0x84
 8003d34:	4618      	mov	r0, r3
 8003d36:	f7ff ff2b 	bl	8003b90 <__dbg_object_init>

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 8003d3a:	687b      	ldr	r3, [r7, #4]
 8003d3c:	3390      	adds	r3, #144	; 0x90
 8003d3e:	4618      	mov	r0, r3
 8003d40:	f7fe fefe 	bl	8002b40 <__trace_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003d44:	687b      	ldr	r3, [r7, #4]
 8003d46:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 8003d4a:	2380      	movs	r3, #128	; 0x80
 8003d4c:	4a18      	ldr	r2, [pc, #96]	; (8003db0 <chInstanceObjectInit+0xf0>)
 8003d4e:	6878      	ldr	r0, [r7, #4]
 8003d50:	f000 f926 	bl	8003fa0 <__thd_object_init>
 8003d54:	4602      	mov	r2, r0
 8003d56:	687b      	ldr	r3, [r7, #4]
 8003d58:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8003d5a:	687b      	ldr	r3, [r7, #4]
 8003d5c:	68db      	ldr	r3, [r3, #12]
 8003d5e:	683a      	ldr	r2, [r7, #0]
 8003d60:	6852      	ldr	r2, [r2, #4]
 8003d62:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003d64:	687b      	ldr	r3, [r7, #4]
 8003d66:	68db      	ldr	r3, [r3, #12]
 8003d68:	2201      	movs	r2, #1
 8003d6a:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 8003d6e:	4b11      	ldr	r3, [pc, #68]	; (8003db4 <chInstanceObjectInit+0xf4>)
 8003d70:	60fb      	str	r3, [r7, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003d72:	683b      	ldr	r3, [r7, #0]
 8003d74:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 8003d76:	613b      	str	r3, [r7, #16]
      .wend     = oicp->idlethread_end,
 8003d78:	683b      	ldr	r3, [r7, #0]
 8003d7a:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 8003d7c:	617b      	str	r3, [r7, #20]
 8003d7e:	2301      	movs	r3, #1
 8003d80:	61bb      	str	r3, [r7, #24]
 8003d82:	4b0d      	ldr	r3, [pc, #52]	; (8003db8 <chInstanceObjectInit+0xf8>)
 8003d84:	61fb      	str	r3, [r7, #28]
 8003d86:	2300      	movs	r3, #0
 8003d88:	623b      	str	r3, [r7, #32]
      .funcp    = __idle_thread,
      .arg      = NULL
    };

#if CH_DBG_FILL_THREADS == TRUE
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8003d8a:	693b      	ldr	r3, [r7, #16]
                    (uint8_t *)idle_descriptor.wend);
 8003d8c:	697a      	ldr	r2, [r7, #20]
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8003d8e:	4611      	mov	r1, r2
 8003d90:	4618      	mov	r0, r3
 8003d92:	f000 f945 	bl	8004020 <__thd_stackfill>
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8003d96:	f107 030c 	add.w	r3, r7, #12
 8003d9a:	4618      	mov	r0, r3
 8003d9c:	f000 f9f0 	bl	8004180 <chThdCreateI>
  }
#endif
}
 8003da0:	bf00      	nop
 8003da2:	3728      	adds	r7, #40	; 0x28
 8003da4:	46bd      	mov	sp, r7
 8003da6:	bd80      	pop	{r7, pc}
 8003da8:	200008f4 	.word	0x200008f4
 8003dac:	08005020 	.word	0x08005020
 8003db0:	08005094 	.word	0x08005094
 8003db4:	08004b08 	.word	0x08004b08
 8003db8:	08003cb1 	.word	0x08003cb1
 8003dbc:	00000000 	.word	0x00000000

08003dc0 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003dc0:	b480      	push	{r7}
 8003dc2:	b083      	sub	sp, #12
 8003dc4:	af00      	add	r7, sp, #0
 8003dc6:	6078      	str	r0, [r7, #4]
  lp->next = lp;
 8003dc8:	687b      	ldr	r3, [r7, #4]
 8003dca:	687a      	ldr	r2, [r7, #4]
 8003dcc:	601a      	str	r2, [r3, #0]
}
 8003dce:	bf00      	nop
 8003dd0:	370c      	adds	r7, #12
 8003dd2:	46bd      	mov	sp, r7
 8003dd4:	bc80      	pop	{r7}
 8003dd6:	4770      	bx	lr
	...

08003de0 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8003de0:	b480      	push	{r7}
 8003de2:	b083      	sub	sp, #12
 8003de4:	af00      	add	r7, sp, #0
 8003de6:	6078      	str	r0, [r7, #4]
  return (bool)(lp->next != lp);
 8003de8:	687b      	ldr	r3, [r7, #4]
 8003dea:	681b      	ldr	r3, [r3, #0]
 8003dec:	687a      	ldr	r2, [r7, #4]
 8003dee:	429a      	cmp	r2, r3
 8003df0:	bf14      	ite	ne
 8003df2:	2301      	movne	r3, #1
 8003df4:	2300      	moveq	r3, #0
 8003df6:	b2db      	uxtb	r3, r3
}
 8003df8:	4618      	mov	r0, r3
 8003dfa:	370c      	adds	r7, #12
 8003dfc:	46bd      	mov	sp, r7
 8003dfe:	bc80      	pop	{r7}
 8003e00:	4770      	bx	lr
 8003e02:	bf00      	nop
	...

08003e10 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 8003e10:	b480      	push	{r7}
 8003e12:	b085      	sub	sp, #20
 8003e14:	af00      	add	r7, sp, #0
 8003e16:	6078      	str	r0, [r7, #4]
  ch_list_t *p = lp->next;
 8003e18:	687b      	ldr	r3, [r7, #4]
 8003e1a:	681b      	ldr	r3, [r3, #0]
 8003e1c:	60fb      	str	r3, [r7, #12]
  lp->next = p->next;
 8003e1e:	68fb      	ldr	r3, [r7, #12]
 8003e20:	681a      	ldr	r2, [r3, #0]
 8003e22:	687b      	ldr	r3, [r7, #4]
 8003e24:	601a      	str	r2, [r3, #0]
  return p;
 8003e26:	68fb      	ldr	r3, [r7, #12]
}
 8003e28:	4618      	mov	r0, r3
 8003e2a:	3714      	adds	r7, #20
 8003e2c:	46bd      	mov	sp, r7
 8003e2e:	bc80      	pop	{r7}
 8003e30:	4770      	bx	lr
 8003e32:	bf00      	nop
	...

08003e40 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003e40:	b480      	push	{r7}
 8003e42:	b083      	sub	sp, #12
 8003e44:	af00      	add	r7, sp, #0
 8003e46:	6078      	str	r0, [r7, #4]
  qp->next = qp;
 8003e48:	687b      	ldr	r3, [r7, #4]
 8003e4a:	687a      	ldr	r2, [r7, #4]
 8003e4c:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003e4e:	687b      	ldr	r3, [r7, #4]
 8003e50:	687a      	ldr	r2, [r7, #4]
 8003e52:	605a      	str	r2, [r3, #4]
}
 8003e54:	bf00      	nop
 8003e56:	370c      	adds	r7, #12
 8003e58:	46bd      	mov	sp, r7
 8003e5a:	bc80      	pop	{r7}
 8003e5c:	4770      	bx	lr
 8003e5e:	bf00      	nop

08003e60 <ch_queue_insert>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 8003e60:	b480      	push	{r7}
 8003e62:	b083      	sub	sp, #12
 8003e64:	af00      	add	r7, sp, #0
 8003e66:	6078      	str	r0, [r7, #4]
 8003e68:	6039      	str	r1, [r7, #0]
  p->next       = qp;
 8003e6a:	683b      	ldr	r3, [r7, #0]
 8003e6c:	687a      	ldr	r2, [r7, #4]
 8003e6e:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 8003e70:	687b      	ldr	r3, [r7, #4]
 8003e72:	685a      	ldr	r2, [r3, #4]
 8003e74:	683b      	ldr	r3, [r7, #0]
 8003e76:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003e78:	683b      	ldr	r3, [r7, #0]
 8003e7a:	685b      	ldr	r3, [r3, #4]
 8003e7c:	683a      	ldr	r2, [r7, #0]
 8003e7e:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 8003e80:	687b      	ldr	r3, [r7, #4]
 8003e82:	683a      	ldr	r2, [r7, #0]
 8003e84:	605a      	str	r2, [r3, #4]
}
 8003e86:	bf00      	nop
 8003e88:	370c      	adds	r7, #12
 8003e8a:	46bd      	mov	sp, r7
 8003e8c:	bc80      	pop	{r7}
 8003e8e:	4770      	bx	lr

08003e90 <ch_queue_dequeue>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003e90:	b480      	push	{r7}
 8003e92:	b083      	sub	sp, #12
 8003e94:	af00      	add	r7, sp, #0
 8003e96:	6078      	str	r0, [r7, #4]
  p->prev->next = p->next;
 8003e98:	687b      	ldr	r3, [r7, #4]
 8003e9a:	685b      	ldr	r3, [r3, #4]
 8003e9c:	687a      	ldr	r2, [r7, #4]
 8003e9e:	6812      	ldr	r2, [r2, #0]
 8003ea0:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8003ea2:	687b      	ldr	r3, [r7, #4]
 8003ea4:	681b      	ldr	r3, [r3, #0]
 8003ea6:	687a      	ldr	r2, [r7, #4]
 8003ea8:	6852      	ldr	r2, [r2, #4]
 8003eaa:	605a      	str	r2, [r3, #4]
  return p;
 8003eac:	687b      	ldr	r3, [r7, #4]
}
 8003eae:	4618      	mov	r0, r3
 8003eb0:	370c      	adds	r7, #12
 8003eb2:	46bd      	mov	sp, r7
 8003eb4:	bc80      	pop	{r7}
 8003eb6:	4770      	bx	lr
	...

08003ec0 <chSysLock>:
static inline void chSysLock(void) {
 8003ec0:	b580      	push	{r7, lr}
 8003ec2:	b082      	sub	sp, #8
 8003ec4:	af00      	add	r7, sp, #0
 8003ec6:	2330      	movs	r3, #48	; 0x30
 8003ec8:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003eca:	687b      	ldr	r3, [r7, #4]
 8003ecc:	f383 8811 	msr	BASEPRI, r3
}
 8003ed0:	bf00      	nop
}
 8003ed2:	bf00      	nop
  __dbg_check_lock();
 8003ed4:	f7fe fc84 	bl	80027e0 <__dbg_check_lock>
}
 8003ed8:	bf00      	nop
 8003eda:	3708      	adds	r7, #8
 8003edc:	46bd      	mov	sp, r7
 8003ede:	bd80      	pop	{r7, pc}

08003ee0 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8003ee0:	b580      	push	{r7, lr}
 8003ee2:	b082      	sub	sp, #8
 8003ee4:	af00      	add	r7, sp, #0
  __dbg_check_unlock();
 8003ee6:	f7fe fca3 	bl	8002830 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003eea:	4b12      	ldr	r3, [pc, #72]	; (8003f34 <chSysUnlock+0x54>)
 8003eec:	681b      	ldr	r3, [r3, #0]
 8003eee:	4a11      	ldr	r2, [pc, #68]	; (8003f34 <chSysUnlock+0x54>)
 8003ef0:	4293      	cmp	r3, r2
 8003ef2:	bf14      	ite	ne
 8003ef4:	2301      	movne	r3, #1
 8003ef6:	2300      	moveq	r3, #0
 8003ef8:	b2db      	uxtb	r3, r3
 8003efa:	2b00      	cmp	r3, #0
 8003efc:	d00f      	beq.n	8003f1e <chSysUnlock+0x3e>
 8003efe:	4b0d      	ldr	r3, [pc, #52]	; (8003f34 <chSysUnlock+0x54>)
 8003f00:	68db      	ldr	r3, [r3, #12]
 8003f02:	689a      	ldr	r2, [r3, #8]
 8003f04:	4b0b      	ldr	r3, [pc, #44]	; (8003f34 <chSysUnlock+0x54>)
 8003f06:	681b      	ldr	r3, [r3, #0]
 8003f08:	689b      	ldr	r3, [r3, #8]
 8003f0a:	429a      	cmp	r2, r3
 8003f0c:	bf34      	ite	cc
 8003f0e:	2301      	movcc	r3, #1
 8003f10:	2300      	movcs	r3, #0
 8003f12:	b2db      	uxtb	r3, r3
 8003f14:	2b00      	cmp	r3, #0
 8003f16:	d002      	beq.n	8003f1e <chSysUnlock+0x3e>
 8003f18:	4807      	ldr	r0, [pc, #28]	; (8003f38 <chSysUnlock+0x58>)
 8003f1a:	f7fe fc09 	bl	8002730 <chSysHalt>
 8003f1e:	2300      	movs	r3, #0
 8003f20:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003f22:	687b      	ldr	r3, [r7, #4]
 8003f24:	f383 8811 	msr	BASEPRI, r3
}
 8003f28:	bf00      	nop
}
 8003f2a:	bf00      	nop
}
 8003f2c:	bf00      	nop
 8003f2e:	3708      	adds	r7, #8
 8003f30:	46bd      	mov	sp, r7
 8003f32:	bd80      	pop	{r7, pc}
 8003f34:	20000900 	.word	0x20000900
 8003f38:	08005050 	.word	0x08005050
 8003f3c:	00000000 	.word	0x00000000

08003f40 <chThdGetSelfX>:
 *
 * @return             A pointer to the current thread.
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {
 8003f40:	b480      	push	{r7}
 8003f42:	af00      	add	r7, sp, #0

  return __sch_get_currthread();
 8003f44:	4b02      	ldr	r3, [pc, #8]	; (8003f50 <chThdGetSelfX+0x10>)
 8003f46:	68db      	ldr	r3, [r3, #12]
}
 8003f48:	4618      	mov	r0, r3
 8003f4a:	46bd      	mov	sp, r7
 8003f4c:	bc80      	pop	{r7}
 8003f4e:	4770      	bx	lr
 8003f50:	20000900 	.word	0x20000900
	...

08003f60 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 8003f60:	b580      	push	{r7, lr}
 8003f62:	b082      	sub	sp, #8
 8003f64:	af00      	add	r7, sp, #0
 8003f66:	6078      	str	r0, [r7, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 8003f68:	687b      	ldr	r3, [r7, #4]
 8003f6a:	2b00      	cmp	r3, #0
 8003f6c:	bf0c      	ite	eq
 8003f6e:	2301      	moveq	r3, #1
 8003f70:	2300      	movne	r3, #0
 8003f72:	b2db      	uxtb	r3, r3
 8003f74:	2b00      	cmp	r3, #0
 8003f76:	d002      	beq.n	8003f7e <chThdSleepS+0x1e>
 8003f78:	4805      	ldr	r0, [pc, #20]	; (8003f90 <chThdSleepS+0x30>)
 8003f7a:	f7fe fbd9 	bl	8002730 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 8003f7e:	6879      	ldr	r1, [r7, #4]
 8003f80:	2008      	movs	r0, #8
 8003f82:	f7ff fcfd 	bl	8003980 <chSchGoSleepTimeoutS>
}
 8003f86:	bf00      	nop
 8003f88:	3708      	adds	r7, #8
 8003f8a:	46bd      	mov	sp, r7
 8003f8c:	bd80      	pop	{r7, pc}
 8003f8e:	bf00      	nop
 8003f90:	08005068 	.word	0x08005068
	...

08003fa0 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003fa0:	b580      	push	{r7, lr}
 8003fa2:	b084      	sub	sp, #16
 8003fa4:	af00      	add	r7, sp, #0
 8003fa6:	60f8      	str	r0, [r7, #12]
 8003fa8:	60b9      	str	r1, [r7, #8]
 8003faa:	607a      	str	r2, [r7, #4]
 8003fac:	603b      	str	r3, [r7, #0]

  tp->hdr.pqueue.prio   = prio;
 8003fae:	68bb      	ldr	r3, [r7, #8]
 8003fb0:	683a      	ldr	r2, [r7, #0]
 8003fb2:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003fb4:	68bb      	ldr	r3, [r7, #8]
 8003fb6:	2202      	movs	r2, #2
 8003fb8:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 8003fbc:	68bb      	ldr	r3, [r7, #8]
 8003fbe:	2200      	movs	r2, #0
 8003fc0:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
  tp->owner             = oip;
 8003fc4:	68bb      	ldr	r3, [r7, #8]
 8003fc6:	68fa      	ldr	r2, [r7, #12]
 8003fc8:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003fca:	68bb      	ldr	r3, [r7, #8]
 8003fcc:	683a      	ldr	r2, [r7, #0]
 8003fce:	641a      	str	r2, [r3, #64]	; 0x40
  tp->mtxlist           = NULL;
 8003fd0:	68bb      	ldr	r3, [r7, #8]
 8003fd2:	2200      	movs	r2, #0
 8003fd4:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003fd6:	68bb      	ldr	r3, [r7, #8]
 8003fd8:	2200      	movs	r2, #0
 8003fda:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 8003fdc:	68bb      	ldr	r3, [r7, #8]
 8003fde:	2201      	movs	r2, #1
 8003fe0:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
  tp->name              = name;
 8003fe4:	68bb      	ldr	r3, [r7, #8]
 8003fe6:	687a      	ldr	r2, [r7, #4]
 8003fe8:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003fea:	68fb      	ldr	r3, [r7, #12]
 8003fec:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8003ff0:	68bb      	ldr	r3, [r7, #8]
 8003ff2:	3310      	adds	r3, #16
 8003ff4:	4619      	mov	r1, r3
 8003ff6:	4610      	mov	r0, r2
 8003ff8:	f7ff ff32 	bl	8003e60 <ch_queue_insert>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 8003ffc:	68bb      	ldr	r3, [r7, #8]
 8003ffe:	332c      	adds	r3, #44	; 0x2c
 8004000:	4618      	mov	r0, r3
 8004002:	f7ff fedd 	bl	8003dc0 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8004006:	68bb      	ldr	r3, [r7, #8]
 8004008:	3330      	adds	r3, #48	; 0x30
 800400a:	4618      	mov	r0, r3
 800400c:	f7ff ff18 	bl	8003e40 <ch_queue_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 8004010:	68bb      	ldr	r3, [r7, #8]
}
 8004012:	4618      	mov	r0, r3
 8004014:	3710      	adds	r7, #16
 8004016:	46bd      	mov	sp, r7
 8004018:	bd80      	pop	{r7, pc}
 800401a:	bf00      	nop
 800401c:	0000      	movs	r0, r0
	...

08004020 <__thd_stackfill>:
 * @param[in] startp    first address to fill
 * @param[in] endp      last address to fill +1
 *
 * @notapi
 */
void __thd_stackfill(uint8_t *startp, uint8_t *endp) {
 8004020:	b480      	push	{r7}
 8004022:	b083      	sub	sp, #12
 8004024:	af00      	add	r7, sp, #0
 8004026:	6078      	str	r0, [r7, #4]
 8004028:	6039      	str	r1, [r7, #0]

  do {
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 800402a:	687b      	ldr	r3, [r7, #4]
 800402c:	1c5a      	adds	r2, r3, #1
 800402e:	607a      	str	r2, [r7, #4]
 8004030:	2255      	movs	r2, #85	; 0x55
 8004032:	701a      	strb	r2, [r3, #0]
  } while (likely(startp < endp));
 8004034:	687a      	ldr	r2, [r7, #4]
 8004036:	683b      	ldr	r3, [r7, #0]
 8004038:	429a      	cmp	r2, r3
 800403a:	bf34      	ite	cc
 800403c:	2301      	movcc	r3, #1
 800403e:	2300      	movcs	r3, #0
 8004040:	b2db      	uxtb	r3, r3
 8004042:	2b00      	cmp	r3, #0
 8004044:	d1f1      	bne.n	800402a <__thd_stackfill+0xa>
}
 8004046:	bf00      	nop
 8004048:	bf00      	nop
 800404a:	370c      	adds	r7, #12
 800404c:	46bd      	mov	sp, r7
 800404e:	bc80      	pop	{r7}
 8004050:	4770      	bx	lr
 8004052:	bf00      	nop
	...

08004060 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8004060:	b580      	push	{r7, lr}
 8004062:	b084      	sub	sp, #16
 8004064:	af00      	add	r7, sp, #0
 8004066:	6078      	str	r0, [r7, #4]
  thread_t *tp;

  chDbgCheckClassI();
 8004068:	f7fe fcd2 	bl	8002a10 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 800406c:	687b      	ldr	r3, [r7, #4]
 800406e:	2b00      	cmp	r3, #0
 8004070:	bf0c      	ite	eq
 8004072:	2301      	moveq	r3, #1
 8004074:	2300      	movne	r3, #0
 8004076:	b2db      	uxtb	r3, r3
 8004078:	2b00      	cmp	r3, #0
 800407a:	d002      	beq.n	8004082 <chThdCreateSuspendedI+0x22>
 800407c:	483d      	ldr	r0, [pc, #244]	; (8004174 <chThdCreateSuspendedI+0x114>)
 800407e:	f7fe fb57 	bl	8002730 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 8004082:	687b      	ldr	r3, [r7, #4]
 8004084:	685b      	ldr	r3, [r3, #4]
 8004086:	f003 0307 	and.w	r3, r3, #7
 800408a:	2b00      	cmp	r3, #0
 800408c:	bf14      	ite	ne
 800408e:	2301      	movne	r3, #1
 8004090:	2300      	moveq	r3, #0
 8004092:	b2db      	uxtb	r3, r3
 8004094:	2b00      	cmp	r3, #0
 8004096:	d10a      	bne.n	80040ae <chThdCreateSuspendedI+0x4e>
 8004098:	687b      	ldr	r3, [r7, #4]
 800409a:	689b      	ldr	r3, [r3, #8]
 800409c:	f003 0307 	and.w	r3, r3, #7
 80040a0:	2b00      	cmp	r3, #0
 80040a2:	bf14      	ite	ne
 80040a4:	2301      	movne	r3, #1
 80040a6:	2300      	moveq	r3, #0
 80040a8:	b2db      	uxtb	r3, r3
 80040aa:	2b00      	cmp	r3, #0
 80040ac:	d001      	beq.n	80040b2 <chThdCreateSuspendedI+0x52>
 80040ae:	2301      	movs	r3, #1
 80040b0:	e000      	b.n	80040b4 <chThdCreateSuspendedI+0x54>
 80040b2:	2300      	movs	r3, #0
 80040b4:	2b00      	cmp	r3, #0
 80040b6:	d10a      	bne.n	80040ce <chThdCreateSuspendedI+0x6e>
 80040b8:	687b      	ldr	r3, [r7, #4]
 80040ba:	689a      	ldr	r2, [r3, #8]
 80040bc:	687b      	ldr	r3, [r7, #4]
 80040be:	685b      	ldr	r3, [r3, #4]
 80040c0:	429a      	cmp	r2, r3
 80040c2:	bf94      	ite	ls
 80040c4:	2301      	movls	r3, #1
 80040c6:	2300      	movhi	r3, #0
 80040c8:	b2db      	uxtb	r3, r3
 80040ca:	2b00      	cmp	r3, #0
 80040cc:	d001      	beq.n	80040d2 <chThdCreateSuspendedI+0x72>
 80040ce:	2301      	movs	r3, #1
 80040d0:	e000      	b.n	80040d4 <chThdCreateSuspendedI+0x74>
 80040d2:	2300      	movs	r3, #0
 80040d4:	2b00      	cmp	r3, #0
 80040d6:	d10c      	bne.n	80040f2 <chThdCreateSuspendedI+0x92>
 80040d8:	687b      	ldr	r3, [r7, #4]
 80040da:	689b      	ldr	r3, [r3, #8]
 80040dc:	461a      	mov	r2, r3
 80040de:	687b      	ldr	r3, [r7, #4]
 80040e0:	685b      	ldr	r3, [r3, #4]
 80040e2:	1ad3      	subs	r3, r2, r3
 80040e4:	2bef      	cmp	r3, #239	; 0xef
 80040e6:	bf94      	ite	ls
 80040e8:	2301      	movls	r3, #1
 80040ea:	2300      	movhi	r3, #0
 80040ec:	b2db      	uxtb	r3, r3
 80040ee:	2b00      	cmp	r3, #0
 80040f0:	d002      	beq.n	80040f8 <chThdCreateSuspendedI+0x98>
 80040f2:	4820      	ldr	r0, [pc, #128]	; (8004174 <chThdCreateSuspendedI+0x114>)
 80040f4:	f7fe fb1c 	bl	8002730 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 80040f8:	687b      	ldr	r3, [r7, #4]
 80040fa:	68db      	ldr	r3, [r3, #12]
 80040fc:	2bff      	cmp	r3, #255	; 0xff
 80040fe:	bf8c      	ite	hi
 8004100:	2301      	movhi	r3, #1
 8004102:	2300      	movls	r3, #0
 8004104:	b2db      	uxtb	r3, r3
 8004106:	2b00      	cmp	r3, #0
 8004108:	d108      	bne.n	800411c <chThdCreateSuspendedI+0xbc>
 800410a:	687b      	ldr	r3, [r7, #4]
 800410c:	691b      	ldr	r3, [r3, #16]
 800410e:	2b00      	cmp	r3, #0
 8004110:	bf0c      	ite	eq
 8004112:	2301      	moveq	r3, #1
 8004114:	2300      	movne	r3, #0
 8004116:	b2db      	uxtb	r3, r3
 8004118:	2b00      	cmp	r3, #0
 800411a:	d002      	beq.n	8004122 <chThdCreateSuspendedI+0xc2>
 800411c:	4815      	ldr	r0, [pc, #84]	; (8004174 <chThdCreateSuspendedI+0x114>)
 800411e:	f7fe fb07 	bl	8002730 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8004122:	687b      	ldr	r3, [r7, #4]
 8004124:	689b      	ldr	r3, [r3, #8]
 8004126:	3b48      	subs	r3, #72	; 0x48
 8004128:	60fb      	str	r3, [r7, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 800412a:	687b      	ldr	r3, [r7, #4]
 800412c:	685a      	ldr	r2, [r3, #4]
 800412e:	68fb      	ldr	r3, [r7, #12]
 8004130:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8004132:	68fb      	ldr	r3, [r7, #12]
 8004134:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8004138:	68fb      	ldr	r3, [r7, #12]
 800413a:	60da      	str	r2, [r3, #12]
 800413c:	687b      	ldr	r3, [r7, #4]
 800413e:	691a      	ldr	r2, [r3, #16]
 8004140:	68fb      	ldr	r3, [r7, #12]
 8004142:	68db      	ldr	r3, [r3, #12]
 8004144:	601a      	str	r2, [r3, #0]
 8004146:	687b      	ldr	r3, [r7, #4]
 8004148:	695a      	ldr	r2, [r3, #20]
 800414a:	68fb      	ldr	r3, [r7, #12]
 800414c:	68db      	ldr	r3, [r3, #12]
 800414e:	605a      	str	r2, [r3, #4]
 8004150:	68fb      	ldr	r3, [r7, #12]
 8004152:	68db      	ldr	r3, [r3, #12]
 8004154:	4a08      	ldr	r2, [pc, #32]	; (8004178 <chThdCreateSuspendedI+0x118>)
 8004156:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 8004158:	687b      	ldr	r3, [r7, #4]
 800415a:	681a      	ldr	r2, [r3, #0]
 800415c:	687b      	ldr	r3, [r7, #4]
 800415e:	68db      	ldr	r3, [r3, #12]
 8004160:	68f9      	ldr	r1, [r7, #12]
 8004162:	4806      	ldr	r0, [pc, #24]	; (800417c <chThdCreateSuspendedI+0x11c>)
 8004164:	f7ff ff1c 	bl	8003fa0 <__thd_object_init>
 8004168:	4603      	mov	r3, r0
}
 800416a:	4618      	mov	r0, r3
 800416c:	3710      	adds	r7, #16
 800416e:	46bd      	mov	sp, r7
 8004170:	bd80      	pop	{r7, pc}
 8004172:	bf00      	nop
 8004174:	08005038 	.word	0x08005038
 8004178:	080002d1 	.word	0x080002d1
 800417c:	20000900 	.word	0x20000900

08004180 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 8004180:	b580      	push	{r7, lr}
 8004182:	b082      	sub	sp, #8
 8004184:	af00      	add	r7, sp, #0
 8004186:	6078      	str	r0, [r7, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 8004188:	6878      	ldr	r0, [r7, #4]
 800418a:	f7ff ff69 	bl	8004060 <chThdCreateSuspendedI>
 800418e:	4603      	mov	r3, r0
 8004190:	4618      	mov	r0, r3
 8004192:	f7ff fb7d 	bl	8003890 <chSchReadyI>
 8004196:	4603      	mov	r3, r0
}
 8004198:	4618      	mov	r0, r3
 800419a:	3708      	adds	r7, #8
 800419c:	46bd      	mov	sp, r7
 800419e:	bd80      	pop	{r7, pc}

080041a0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80041a0:	b580      	push	{r7, lr}
 80041a2:	b082      	sub	sp, #8
 80041a4:	af00      	add	r7, sp, #0
 80041a6:	6078      	str	r0, [r7, #4]

  chSysLock();
 80041a8:	f7ff fe8a 	bl	8003ec0 <chSysLock>
  chThdExitS(msg);
 80041ac:	6878      	ldr	r0, [r7, #4]
 80041ae:	f000 f807 	bl	80041c0 <chThdExitS>
  /* The thread never returns here.*/
}
 80041b2:	bf00      	nop
 80041b4:	3708      	adds	r7, #8
 80041b6:	46bd      	mov	sp, r7
 80041b8:	bd80      	pop	{r7, pc}
 80041ba:	bf00      	nop
 80041bc:	0000      	movs	r0, r0
	...

080041c0 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 80041c0:	b580      	push	{r7, lr}
 80041c2:	b084      	sub	sp, #16
 80041c4:	af00      	add	r7, sp, #0
 80041c6:	6078      	str	r0, [r7, #4]
  thread_t *currtp = chThdGetSelfX();
 80041c8:	f7ff feba 	bl	8003f40 <chThdGetSelfX>
 80041cc:	60f8      	str	r0, [r7, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 80041ce:	68fb      	ldr	r3, [r7, #12]
 80041d0:	687a      	ldr	r2, [r7, #4]
 80041d2:	629a      	str	r2, [r3, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80041d4:	e008      	b.n	80041e8 <chThdExitS+0x28>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 80041d6:	68fb      	ldr	r3, [r7, #12]
 80041d8:	332c      	adds	r3, #44	; 0x2c
 80041da:	4618      	mov	r0, r3
 80041dc:	f7ff fe18 	bl	8003e10 <ch_list_unlink>
 80041e0:	4603      	mov	r3, r0
 80041e2:	4618      	mov	r0, r3
 80041e4:	f7ff fb54 	bl	8003890 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 80041e8:	68fb      	ldr	r3, [r7, #12]
 80041ea:	332c      	adds	r3, #44	; 0x2c
 80041ec:	4618      	mov	r0, r3
 80041ee:	f7ff fdf7 	bl	8003de0 <ch_list_notempty>
 80041f2:	4603      	mov	r3, r0
 80041f4:	2b00      	cmp	r3, #0
 80041f6:	d1ee      	bne.n	80041d6 <chThdExitS+0x16>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 80041f8:	68fb      	ldr	r3, [r7, #12]
 80041fa:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 80041fe:	2b00      	cmp	r3, #0
 8004200:	bf0c      	ite	eq
 8004202:	2301      	moveq	r3, #1
 8004204:	2300      	movne	r3, #0
 8004206:	b2db      	uxtb	r3, r3
 8004208:	2b00      	cmp	r3, #0
 800420a:	d010      	beq.n	800422e <chThdExitS+0x6e>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 800420c:	68fb      	ldr	r3, [r7, #12]
 800420e:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8004212:	f003 0303 	and.w	r3, r3, #3
 8004216:	2b00      	cmp	r3, #0
 8004218:	bf0c      	ite	eq
 800421a:	2301      	moveq	r3, #1
 800421c:	2300      	movne	r3, #0
 800421e:	b2db      	uxtb	r3, r3
 8004220:	2b00      	cmp	r3, #0
 8004222:	d004      	beq.n	800422e <chThdExitS+0x6e>
      REG_REMOVE(currtp);
 8004224:	68fb      	ldr	r3, [r7, #12]
 8004226:	3310      	adds	r3, #16
 8004228:	4618      	mov	r0, r3
 800422a:	f7ff fe31 	bl	8003e90 <ch_queue_dequeue>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800422e:	200f      	movs	r0, #15
 8004230:	f7ff fb4e 	bl	80038d0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8004234:	4803      	ldr	r0, [pc, #12]	; (8004244 <chThdExitS+0x84>)
 8004236:	f7fe fa7b 	bl	8002730 <chSysHalt>
}
 800423a:	bf00      	nop
 800423c:	3710      	adds	r7, #16
 800423e:	46bd      	mov	sp, r7
 8004240:	bd80      	pop	{r7, pc}
 8004242:	bf00      	nop
 8004244:	0800505c 	.word	0x0800505c
	...

08004250 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8004250:	b580      	push	{r7, lr}
 8004252:	b082      	sub	sp, #8
 8004254:	af00      	add	r7, sp, #0
 8004256:	6078      	str	r0, [r7, #4]

  chSysLock();
 8004258:	f7ff fe32 	bl	8003ec0 <chSysLock>
  chThdSleepS(time);
 800425c:	6878      	ldr	r0, [r7, #4]
 800425e:	f7ff fe7f 	bl	8003f60 <chThdSleepS>
  chSysUnlock();
 8004262:	f7ff fe3d 	bl	8003ee0 <chSysUnlock>
}
 8004266:	bf00      	nop
 8004268:	3708      	adds	r7, #8
 800426a:	46bd      	mov	sp, r7
 800426c:	bd80      	pop	{r7, pc}
 800426e:	bf00      	nop

08004270 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 8004270:	b580      	push	{r7, lr}
 8004272:	b084      	sub	sp, #16
 8004274:	af00      	add	r7, sp, #0
 8004276:	6078      	str	r0, [r7, #4]
 8004278:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 800427a:	687b      	ldr	r3, [r7, #4]
 800427c:	681b      	ldr	r3, [r3, #0]
 800427e:	2b00      	cmp	r3, #0
 8004280:	d018      	beq.n	80042b4 <chThdResumeI+0x44>
    thread_t *tp = *trp;
 8004282:	687b      	ldr	r3, [r7, #4]
 8004284:	681b      	ldr	r3, [r3, #0]
 8004286:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 8004288:	68fb      	ldr	r3, [r7, #12]
 800428a:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800428e:	2b03      	cmp	r3, #3
 8004290:	bf14      	ite	ne
 8004292:	2301      	movne	r3, #1
 8004294:	2300      	moveq	r3, #0
 8004296:	b2db      	uxtb	r3, r3
 8004298:	2b00      	cmp	r3, #0
 800429a:	d002      	beq.n	80042a2 <chThdResumeI+0x32>
 800429c:	4807      	ldr	r0, [pc, #28]	; (80042bc <chThdResumeI+0x4c>)
 800429e:	f7fe fa47 	bl	8002730 <chSysHalt>

    *trp = NULL;
 80042a2:	687b      	ldr	r3, [r7, #4]
 80042a4:	2200      	movs	r2, #0
 80042a6:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
 80042a8:	68fb      	ldr	r3, [r7, #12]
 80042aa:	683a      	ldr	r2, [r7, #0]
 80042ac:	629a      	str	r2, [r3, #40]	; 0x28
    (void) chSchReadyI(tp);
 80042ae:	68f8      	ldr	r0, [r7, #12]
 80042b0:	f7ff faee 	bl	8003890 <chSchReadyI>
  }
}
 80042b4:	bf00      	nop
 80042b6:	3710      	adds	r7, #16
 80042b8:	46bd      	mov	sp, r7
 80042ba:	bd80      	pop	{r7, pc}
 80042bc:	08005074 	.word	0x08005074

080042c0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80042c0:	b580      	push	{r7, lr}
 80042c2:	b084      	sub	sp, #16
 80042c4:	af00      	add	r7, sp, #0
 80042c6:	6078      	str	r0, [r7, #4]
 80042c8:	6039      	str	r1, [r7, #0]

  if (*trp != NULL) {
 80042ca:	687b      	ldr	r3, [r7, #4]
 80042cc:	681b      	ldr	r3, [r3, #0]
 80042ce:	2b00      	cmp	r3, #0
 80042d0:	d016      	beq.n	8004300 <chThdResumeS+0x40>
    thread_t *tp = *trp;
 80042d2:	687b      	ldr	r3, [r7, #4]
 80042d4:	681b      	ldr	r3, [r3, #0]
 80042d6:	60fb      	str	r3, [r7, #12]

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");
 80042d8:	68fb      	ldr	r3, [r7, #12]
 80042da:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80042de:	2b03      	cmp	r3, #3
 80042e0:	bf14      	ite	ne
 80042e2:	2301      	movne	r3, #1
 80042e4:	2300      	moveq	r3, #0
 80042e6:	b2db      	uxtb	r3, r3
 80042e8:	2b00      	cmp	r3, #0
 80042ea:	d002      	beq.n	80042f2 <chThdResumeS+0x32>
 80042ec:	4806      	ldr	r0, [pc, #24]	; (8004308 <chThdResumeS+0x48>)
 80042ee:	f7fe fa1f 	bl	8002730 <chSysHalt>

    *trp = NULL;
 80042f2:	687b      	ldr	r3, [r7, #4]
 80042f4:	2200      	movs	r2, #0
 80042f6:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 80042f8:	6839      	ldr	r1, [r7, #0]
 80042fa:	68f8      	ldr	r0, [r7, #12]
 80042fc:	f7ff fb78 	bl	80039f0 <chSchWakeupS>
  }
}
 8004300:	bf00      	nop
 8004302:	3710      	adds	r7, #16
 8004304:	46bd      	mov	sp, r7
 8004306:	bd80      	pop	{r7, pc}
 8004308:	08005084 	.word	0x08005084
 800430c:	00000000 	.word	0x00000000

08004310 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8004310:	e92d 03b0 	stmdb	sp!, {r4, r5, r7, r8, r9}
 8004314:	b085      	sub	sp, #20
 8004316:	af00      	add	r7, sp, #0
 8004318:	60f8      	str	r0, [r7, #12]
 800431a:	60b9      	str	r1, [r7, #8]
 800431c:	607a      	str	r2, [r7, #4]

  tmp->n++;
 800431e:	68fb      	ldr	r3, [r7, #12]
 8004320:	68db      	ldr	r3, [r3, #12]
 8004322:	1c5a      	adds	r2, r3, #1
 8004324:	68fb      	ldr	r3, [r7, #12]
 8004326:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8004328:	68fb      	ldr	r3, [r7, #12]
 800432a:	689b      	ldr	r3, [r3, #8]
 800432c:	68ba      	ldr	r2, [r7, #8]
 800432e:	1ad2      	subs	r2, r2, r3
 8004330:	687b      	ldr	r3, [r7, #4]
 8004332:	1ad2      	subs	r2, r2, r3
 8004334:	68fb      	ldr	r3, [r7, #12]
 8004336:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8004338:	68fb      	ldr	r3, [r7, #12]
 800433a:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 800433e:	68f9      	ldr	r1, [r7, #12]
 8004340:	6889      	ldr	r1, [r1, #8]
 8004342:	2000      	movs	r0, #0
 8004344:	460c      	mov	r4, r1
 8004346:	4605      	mov	r5, r0
 8004348:	eb12 0804 	adds.w	r8, r2, r4
 800434c:	eb43 0905 	adc.w	r9, r3, r5
 8004350:	68fb      	ldr	r3, [r7, #12]
 8004352:	e9c3 8904 	strd	r8, r9, [r3, #16]
  if (tmp->last > tmp->worst) {
 8004356:	68fb      	ldr	r3, [r7, #12]
 8004358:	689a      	ldr	r2, [r3, #8]
 800435a:	68fb      	ldr	r3, [r7, #12]
 800435c:	685b      	ldr	r3, [r3, #4]
 800435e:	429a      	cmp	r2, r3
 8004360:	d903      	bls.n	800436a <tm_stop+0x5a>
    tmp->worst = tmp->last;
 8004362:	68fb      	ldr	r3, [r7, #12]
 8004364:	689a      	ldr	r2, [r3, #8]
 8004366:	68fb      	ldr	r3, [r7, #12]
 8004368:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 800436a:	68fb      	ldr	r3, [r7, #12]
 800436c:	689a      	ldr	r2, [r3, #8]
 800436e:	68fb      	ldr	r3, [r7, #12]
 8004370:	681b      	ldr	r3, [r3, #0]
 8004372:	429a      	cmp	r2, r3
 8004374:	d203      	bcs.n	800437e <tm_stop+0x6e>
    tmp->best = tmp->last;
 8004376:	68fb      	ldr	r3, [r7, #12]
 8004378:	689a      	ldr	r2, [r3, #8]
 800437a:	68fb      	ldr	r3, [r7, #12]
 800437c:	601a      	str	r2, [r3, #0]
  }
}
 800437e:	bf00      	nop
 8004380:	3714      	adds	r7, #20
 8004382:	46bd      	mov	sp, r7
 8004384:	e8bd 03b0 	ldmia.w	sp!, {r4, r5, r7, r8, r9}
 8004388:	4770      	bx	lr
 800438a:	bf00      	nop
 800438c:	0000      	movs	r0, r0
	...

08004390 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8004390:	b480      	push	{r7}
 8004392:	b083      	sub	sp, #12
 8004394:	af00      	add	r7, sp, #0
 8004396:	6078      	str	r0, [r7, #4]

  tmp->best       = (rtcnt_t)-1;
 8004398:	687b      	ldr	r3, [r7, #4]
 800439a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800439e:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80043a0:	687b      	ldr	r3, [r7, #4]
 80043a2:	2200      	movs	r2, #0
 80043a4:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80043a6:	687b      	ldr	r3, [r7, #4]
 80043a8:	2200      	movs	r2, #0
 80043aa:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80043ac:	687b      	ldr	r3, [r7, #4]
 80043ae:	2200      	movs	r2, #0
 80043b0:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80043b2:	6879      	ldr	r1, [r7, #4]
 80043b4:	f04f 0200 	mov.w	r2, #0
 80043b8:	f04f 0300 	mov.w	r3, #0
 80043bc:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80043c0:	bf00      	nop
 80043c2:	370c      	adds	r7, #12
 80043c4:	46bd      	mov	sp, r7
 80043c6:	bc80      	pop	{r7}
 80043c8:	4770      	bx	lr
 80043ca:	bf00      	nop
 80043cc:	0000      	movs	r0, r0
	...

080043d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80043d0:	b480      	push	{r7}
 80043d2:	b083      	sub	sp, #12
 80043d4:	af00      	add	r7, sp, #0
 80043d6:	6078      	str	r0, [r7, #4]
  return DWT->CYCCNT;
 80043d8:	4b04      	ldr	r3, [pc, #16]	; (80043ec <chTMStartMeasurementX+0x1c>)
 80043da:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80043dc:	687b      	ldr	r3, [r7, #4]
 80043de:	609a      	str	r2, [r3, #8]
}
 80043e0:	bf00      	nop
 80043e2:	370c      	adds	r7, #12
 80043e4:	46bd      	mov	sp, r7
 80043e6:	bc80      	pop	{r7}
 80043e8:	4770      	bx	lr
 80043ea:	bf00      	nop
 80043ec:	e0001000 	.word	0xe0001000

080043f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80043f0:	b580      	push	{r7, lr}
 80043f2:	b082      	sub	sp, #8
 80043f4:	af00      	add	r7, sp, #0
 80043f6:	6078      	str	r0, [r7, #4]
 80043f8:	4b05      	ldr	r3, [pc, #20]	; (8004410 <chTMStopMeasurementX+0x20>)
 80043fa:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 80043fc:	4a05      	ldr	r2, [pc, #20]	; (8004414 <chTMStopMeasurementX+0x24>)
 80043fe:	6892      	ldr	r2, [r2, #8]
 8004400:	4619      	mov	r1, r3
 8004402:	6878      	ldr	r0, [r7, #4]
 8004404:	f7ff ff84 	bl	8004310 <tm_stop>
}
 8004408:	bf00      	nop
 800440a:	3708      	adds	r7, #8
 800440c:	46bd      	mov	sp, r7
 800440e:	bd80      	pop	{r7, pc}
 8004410:	e0001000 	.word	0xe0001000
 8004414:	200008f4 	.word	0x200008f4
	...

08004420 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8004420:	b480      	push	{r7}
 8004422:	b083      	sub	sp, #12
 8004424:	af00      	add	r7, sp, #0
 8004426:	6078      	str	r0, [r7, #4]
  qp->next = qp;
 8004428:	687b      	ldr	r3, [r7, #4]
 800442a:	687a      	ldr	r2, [r7, #4]
 800442c:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 800442e:	687b      	ldr	r3, [r7, #4]
 8004430:	687a      	ldr	r2, [r7, #4]
 8004432:	605a      	str	r2, [r3, #4]
}
 8004434:	bf00      	nop
 8004436:	370c      	adds	r7, #12
 8004438:	46bd      	mov	sp, r7
 800443a:	bc80      	pop	{r7}
 800443c:	4770      	bx	lr
 800443e:	bf00      	nop

08004440 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8004440:	b580      	push	{r7, lr}
 8004442:	b082      	sub	sp, #8
 8004444:	af00      	add	r7, sp, #0
 8004446:	6078      	str	r0, [r7, #4]

  chDbgCheck(mp != NULL);
 8004448:	687b      	ldr	r3, [r7, #4]
 800444a:	2b00      	cmp	r3, #0
 800444c:	bf0c      	ite	eq
 800444e:	2301      	moveq	r3, #1
 8004450:	2300      	movne	r3, #0
 8004452:	b2db      	uxtb	r3, r3
 8004454:	2b00      	cmp	r3, #0
 8004456:	d002      	beq.n	800445e <chMtxObjectInit+0x1e>
 8004458:	4806      	ldr	r0, [pc, #24]	; (8004474 <chMtxObjectInit+0x34>)
 800445a:	f7fe f969 	bl	8002730 <chSysHalt>

  ch_queue_init(&mp->queue);
 800445e:	687b      	ldr	r3, [r7, #4]
 8004460:	4618      	mov	r0, r3
 8004462:	f7ff ffdd 	bl	8004420 <ch_queue_init>
  mp->owner = NULL;
 8004466:	687b      	ldr	r3, [r7, #4]
 8004468:	2200      	movs	r2, #0
 800446a:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 800446c:	bf00      	nop
 800446e:	3708      	adds	r7, #8
 8004470:	46bd      	mov	sp, r7
 8004472:	bd80      	pop	{r7, pc}
 8004474:	080050c0 	.word	0x080050c0
	...

08004480 <chSysLock>:
static inline void chSysLock(void) {
 8004480:	b580      	push	{r7, lr}
 8004482:	b082      	sub	sp, #8
 8004484:	af00      	add	r7, sp, #0
 8004486:	2330      	movs	r3, #48	; 0x30
 8004488:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800448a:	687b      	ldr	r3, [r7, #4]
 800448c:	f383 8811 	msr	BASEPRI, r3
}
 8004490:	bf00      	nop
}
 8004492:	bf00      	nop
  __dbg_check_lock();
 8004494:	f7fe f9a4 	bl	80027e0 <__dbg_check_lock>
}
 8004498:	bf00      	nop
 800449a:	3708      	adds	r7, #8
 800449c:	46bd      	mov	sp, r7
 800449e:	bd80      	pop	{r7, pc}

080044a0 <chSysUnlock>:
static inline void chSysUnlock(void) {
 80044a0:	b580      	push	{r7, lr}
 80044a2:	b082      	sub	sp, #8
 80044a4:	af00      	add	r7, sp, #0
  __dbg_check_unlock();
 80044a6:	f7fe f9c3 	bl	8002830 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 80044aa:	4b12      	ldr	r3, [pc, #72]	; (80044f4 <chSysUnlock+0x54>)
 80044ac:	681b      	ldr	r3, [r3, #0]
 80044ae:	4a11      	ldr	r2, [pc, #68]	; (80044f4 <chSysUnlock+0x54>)
 80044b0:	4293      	cmp	r3, r2
 80044b2:	bf14      	ite	ne
 80044b4:	2301      	movne	r3, #1
 80044b6:	2300      	moveq	r3, #0
 80044b8:	b2db      	uxtb	r3, r3
 80044ba:	2b00      	cmp	r3, #0
 80044bc:	d00f      	beq.n	80044de <chSysUnlock+0x3e>
 80044be:	4b0d      	ldr	r3, [pc, #52]	; (80044f4 <chSysUnlock+0x54>)
 80044c0:	68db      	ldr	r3, [r3, #12]
 80044c2:	689a      	ldr	r2, [r3, #8]
 80044c4:	4b0b      	ldr	r3, [pc, #44]	; (80044f4 <chSysUnlock+0x54>)
 80044c6:	681b      	ldr	r3, [r3, #0]
 80044c8:	689b      	ldr	r3, [r3, #8]
 80044ca:	429a      	cmp	r2, r3
 80044cc:	bf34      	ite	cc
 80044ce:	2301      	movcc	r3, #1
 80044d0:	2300      	movcs	r3, #0
 80044d2:	b2db      	uxtb	r3, r3
 80044d4:	2b00      	cmp	r3, #0
 80044d6:	d002      	beq.n	80044de <chSysUnlock+0x3e>
 80044d8:	4807      	ldr	r0, [pc, #28]	; (80044f8 <chSysUnlock+0x58>)
 80044da:	f7fe f929 	bl	8002730 <chSysHalt>
 80044de:	2300      	movs	r3, #0
 80044e0:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80044e2:	687b      	ldr	r3, [r7, #4]
 80044e4:	f383 8811 	msr	BASEPRI, r3
}
 80044e8:	bf00      	nop
}
 80044ea:	bf00      	nop
}
 80044ec:	bf00      	nop
 80044ee:	3708      	adds	r7, #8
 80044f0:	46bd      	mov	sp, r7
 80044f2:	bd80      	pop	{r7, pc}
 80044f4:	20000900 	.word	0x20000900
 80044f8:	080050e4 	.word	0x080050e4
 80044fc:	00000000 	.word	0x00000000

08004500 <__core_init>:
/**
 * @brief   Low level memory manager initialization.
 *
 * @notapi
 */
void __core_init(void) {
 8004500:	b480      	push	{r7}
 8004502:	af00      	add	r7, sp, #0
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8004504:	4b04      	ldr	r3, [pc, #16]	; (8004518 <__core_init+0x18>)
 8004506:	4a05      	ldr	r2, [pc, #20]	; (800451c <__core_init+0x1c>)
 8004508:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 800450a:	4b03      	ldr	r3, [pc, #12]	; (8004518 <__core_init+0x18>)
 800450c:	4a04      	ldr	r2, [pc, #16]	; (8004520 <__core_init+0x20>)
 800450e:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8004510:	bf00      	nop
 8004512:	46bd      	mov	sp, r7
 8004514:	bc80      	pop	{r7}
 8004516:	4770      	bx	lr
 8004518:	200012c8 	.word	0x200012c8
 800451c:	20001340 	.word	0x20001340
 8004520:	20020000 	.word	0x20020000
	...

08004530 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8004530:	b580      	push	{r7, lr}
 8004532:	b086      	sub	sp, #24
 8004534:	af00      	add	r7, sp, #0
 8004536:	60f8      	str	r0, [r7, #12]
 8004538:	60b9      	str	r1, [r7, #8]
 800453a:	607a      	str	r2, [r7, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 800453c:	f7fe fa68 	bl	8002a10 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8004540:	68bb      	ldr	r3, [r7, #8]
 8004542:	2b00      	cmp	r3, #0
 8004544:	bf0c      	ite	eq
 8004546:	2301      	moveq	r3, #1
 8004548:	2300      	movne	r3, #0
 800454a:	b2db      	uxtb	r3, r3
 800454c:	2b00      	cmp	r3, #0
 800454e:	d10a      	bne.n	8004566 <chCoreAllocFromTopI+0x36>
 8004550:	68bb      	ldr	r3, [r7, #8]
 8004552:	1e5a      	subs	r2, r3, #1
 8004554:	68bb      	ldr	r3, [r7, #8]
 8004556:	4013      	ands	r3, r2
 8004558:	2b00      	cmp	r3, #0
 800455a:	bf14      	ite	ne
 800455c:	2301      	movne	r3, #1
 800455e:	2300      	moveq	r3, #0
 8004560:	b2db      	uxtb	r3, r3
 8004562:	2b00      	cmp	r3, #0
 8004564:	d002      	beq.n	800456c <chCoreAllocFromTopI+0x3c>
 8004566:	4813      	ldr	r0, [pc, #76]	; (80045b4 <chCoreAllocFromTopI+0x84>)
 8004568:	f7fe f8e2 	bl	8002730 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 800456c:	4b12      	ldr	r3, [pc, #72]	; (80045b8 <chCoreAllocFromTopI+0x88>)
 800456e:	685a      	ldr	r2, [r3, #4]
 8004570:	68fb      	ldr	r3, [r7, #12]
 8004572:	425b      	negs	r3, r3
 8004574:	4413      	add	r3, r2
 8004576:	461a      	mov	r2, r3
 8004578:	68bb      	ldr	r3, [r7, #8]
 800457a:	425b      	negs	r3, r3
 800457c:	4013      	ands	r3, r2
 800457e:	617b      	str	r3, [r7, #20]
  prev = p - offset;
 8004580:	687b      	ldr	r3, [r7, #4]
 8004582:	425b      	negs	r3, r3
 8004584:	697a      	ldr	r2, [r7, #20]
 8004586:	4413      	add	r3, r2
 8004588:	613b      	str	r3, [r7, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 800458a:	4b0b      	ldr	r3, [pc, #44]	; (80045b8 <chCoreAllocFromTopI+0x88>)
 800458c:	681b      	ldr	r3, [r3, #0]
 800458e:	693a      	ldr	r2, [r7, #16]
 8004590:	429a      	cmp	r2, r3
 8004592:	d304      	bcc.n	800459e <chCoreAllocFromTopI+0x6e>
 8004594:	4b08      	ldr	r3, [pc, #32]	; (80045b8 <chCoreAllocFromTopI+0x88>)
 8004596:	685b      	ldr	r3, [r3, #4]
 8004598:	693a      	ldr	r2, [r7, #16]
 800459a:	429a      	cmp	r2, r3
 800459c:	d901      	bls.n	80045a2 <chCoreAllocFromTopI+0x72>
    return NULL;
 800459e:	2300      	movs	r3, #0
 80045a0:	e003      	b.n	80045aa <chCoreAllocFromTopI+0x7a>
  }

  ch_memcore.topmem = prev;
 80045a2:	4a05      	ldr	r2, [pc, #20]	; (80045b8 <chCoreAllocFromTopI+0x88>)
 80045a4:	693b      	ldr	r3, [r7, #16]
 80045a6:	6053      	str	r3, [r2, #4]

  return p;
 80045a8:	697b      	ldr	r3, [r7, #20]
}
 80045aa:	4618      	mov	r0, r3
 80045ac:	3718      	adds	r7, #24
 80045ae:	46bd      	mov	sp, r7
 80045b0:	bd80      	pop	{r7, pc}
 80045b2:	bf00      	nop
 80045b4:	080050d0 	.word	0x080050d0
 80045b8:	200012c8 	.word	0x200012c8
 80045bc:	00000000 	.word	0x00000000

080045c0 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 80045c0:	b580      	push	{r7, lr}
 80045c2:	b086      	sub	sp, #24
 80045c4:	af00      	add	r7, sp, #0
 80045c6:	60f8      	str	r0, [r7, #12]
 80045c8:	60b9      	str	r1, [r7, #8]
 80045ca:	607a      	str	r2, [r7, #4]
  void *p;

  chSysLock();
 80045cc:	f7ff ff58 	bl	8004480 <chSysLock>
  p = chCoreAllocFromTopI(size, align, offset);
 80045d0:	687a      	ldr	r2, [r7, #4]
 80045d2:	68b9      	ldr	r1, [r7, #8]
 80045d4:	68f8      	ldr	r0, [r7, #12]
 80045d6:	f7ff ffab 	bl	8004530 <chCoreAllocFromTopI>
 80045da:	6178      	str	r0, [r7, #20]
  chSysUnlock();
 80045dc:	f7ff ff60 	bl	80044a0 <chSysUnlock>

  return p;
 80045e0:	697b      	ldr	r3, [r7, #20]
}
 80045e2:	4618      	mov	r0, r3
 80045e4:	3718      	adds	r7, #24
 80045e6:	46bd      	mov	sp, r7
 80045e8:	bd80      	pop	{r7, pc}
 80045ea:	bf00      	nop
 80045ec:	0000      	movs	r0, r0
	...

080045f0 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 80045f0:	b580      	push	{r7, lr}
 80045f2:	af00      	add	r7, sp, #0

  default_heap.provider = chCoreAllocAlignedWithOffset;
 80045f4:	4b06      	ldr	r3, [pc, #24]	; (8004610 <__heap_init+0x20>)
 80045f6:	4a07      	ldr	r2, [pc, #28]	; (8004614 <__heap_init+0x24>)
 80045f8:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 80045fa:	4b05      	ldr	r3, [pc, #20]	; (8004610 <__heap_init+0x20>)
 80045fc:	2200      	movs	r2, #0
 80045fe:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8004600:	4b03      	ldr	r3, [pc, #12]	; (8004610 <__heap_init+0x20>)
 8004602:	2200      	movs	r2, #0
 8004604:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8004606:	4804      	ldr	r0, [pc, #16]	; (8004618 <__heap_init+0x28>)
 8004608:	f7ff ff1a 	bl	8004440 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 800460c:	bf00      	nop
 800460e:	bd80      	pop	{r7, pc}
 8004610:	200012d0 	.word	0x200012d0
 8004614:	080045c1 	.word	0x080045c1
 8004618:	200012dc 	.word	0x200012dc
 800461c:	00000000 	.word	0x00000000

08004620 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8004620:	b580      	push	{r7, lr}
 8004622:	b084      	sub	sp, #16
 8004624:	af00      	add	r7, sp, #0
 8004626:	60f8      	str	r0, [r7, #12]
 8004628:	60b9      	str	r1, [r7, #8]
 800462a:	607a      	str	r2, [r7, #4]
 800462c:	603b      	str	r3, [r7, #0]

  chDbgCheck((mp != NULL) &&
 800462e:	68fb      	ldr	r3, [r7, #12]
 8004630:	2b00      	cmp	r3, #0
 8004632:	bf0c      	ite	eq
 8004634:	2301      	moveq	r3, #1
 8004636:	2300      	movne	r3, #0
 8004638:	b2db      	uxtb	r3, r3
 800463a:	2b00      	cmp	r3, #0
 800463c:	d107      	bne.n	800464e <chPoolObjectInitAligned+0x2e>
 800463e:	68bb      	ldr	r3, [r7, #8]
 8004640:	2b03      	cmp	r3, #3
 8004642:	bf94      	ite	ls
 8004644:	2301      	movls	r3, #1
 8004646:	2300      	movhi	r3, #0
 8004648:	b2db      	uxtb	r3, r3
 800464a:	2b00      	cmp	r3, #0
 800464c:	d001      	beq.n	8004652 <chPoolObjectInitAligned+0x32>
 800464e:	2301      	movs	r3, #1
 8004650:	e000      	b.n	8004654 <chPoolObjectInitAligned+0x34>
 8004652:	2300      	movs	r3, #0
 8004654:	2b00      	cmp	r3, #0
 8004656:	d107      	bne.n	8004668 <chPoolObjectInitAligned+0x48>
 8004658:	687b      	ldr	r3, [r7, #4]
 800465a:	2b03      	cmp	r3, #3
 800465c:	bf94      	ite	ls
 800465e:	2301      	movls	r3, #1
 8004660:	2300      	movhi	r3, #0
 8004662:	b2db      	uxtb	r3, r3
 8004664:	2b00      	cmp	r3, #0
 8004666:	d001      	beq.n	800466c <chPoolObjectInitAligned+0x4c>
 8004668:	2301      	movs	r3, #1
 800466a:	e000      	b.n	800466e <chPoolObjectInitAligned+0x4e>
 800466c:	2300      	movs	r3, #0
 800466e:	2b00      	cmp	r3, #0
 8004670:	d117      	bne.n	80046a2 <chPoolObjectInitAligned+0x82>
 8004672:	687b      	ldr	r3, [r7, #4]
 8004674:	2b00      	cmp	r3, #0
 8004676:	bf0c      	ite	eq
 8004678:	2301      	moveq	r3, #1
 800467a:	2300      	movne	r3, #0
 800467c:	b2db      	uxtb	r3, r3
 800467e:	2b00      	cmp	r3, #0
 8004680:	d10a      	bne.n	8004698 <chPoolObjectInitAligned+0x78>
 8004682:	687b      	ldr	r3, [r7, #4]
 8004684:	1e5a      	subs	r2, r3, #1
 8004686:	687b      	ldr	r3, [r7, #4]
 8004688:	4013      	ands	r3, r2
 800468a:	2b00      	cmp	r3, #0
 800468c:	bf14      	ite	ne
 800468e:	2301      	movne	r3, #1
 8004690:	2300      	moveq	r3, #0
 8004692:	b2db      	uxtb	r3, r3
 8004694:	2b00      	cmp	r3, #0
 8004696:	d001      	beq.n	800469c <chPoolObjectInitAligned+0x7c>
 8004698:	2301      	movs	r3, #1
 800469a:	e000      	b.n	800469e <chPoolObjectInitAligned+0x7e>
 800469c:	2300      	movs	r3, #0
 800469e:	2b00      	cmp	r3, #0
 80046a0:	d002      	beq.n	80046a8 <chPoolObjectInitAligned+0x88>
 80046a2:	4809      	ldr	r0, [pc, #36]	; (80046c8 <chPoolObjectInitAligned+0xa8>)
 80046a4:	f7fe f844 	bl	8002730 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 80046a8:	68fb      	ldr	r3, [r7, #12]
 80046aa:	2200      	movs	r2, #0
 80046ac:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 80046ae:	68fb      	ldr	r3, [r7, #12]
 80046b0:	68ba      	ldr	r2, [r7, #8]
 80046b2:	605a      	str	r2, [r3, #4]
  mp->align = align;
 80046b4:	68fb      	ldr	r3, [r7, #12]
 80046b6:	687a      	ldr	r2, [r7, #4]
 80046b8:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 80046ba:	68fb      	ldr	r3, [r7, #12]
 80046bc:	683a      	ldr	r2, [r7, #0]
 80046be:	60da      	str	r2, [r3, #12]
}
 80046c0:	bf00      	nop
 80046c2:	3710      	adds	r7, #16
 80046c4:	46bd      	mov	sp, r7
 80046c6:	bd80      	pop	{r7, pc}
 80046c8:	080050f0 	.word	0x080050f0
 80046cc:	00000000 	.word	0x00000000

080046d0 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 80046d0:	b580      	push	{r7, lr}
 80046d2:	b082      	sub	sp, #8
 80046d4:	af00      	add	r7, sp, #0
 80046d6:	6078      	str	r0, [r7, #4]
 80046d8:	6039      	str	r1, [r7, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 80046da:	2200      	movs	r2, #0
 80046dc:	6839      	ldr	r1, [r7, #0]
 80046de:	6878      	ldr	r0, [r7, #4]
 80046e0:	f7ff ff26 	bl	8004530 <chCoreAllocFromTopI>
 80046e4:	4603      	mov	r3, r0
}
 80046e6:	4618      	mov	r0, r3
 80046e8:	3708      	adds	r7, #8
 80046ea:	46bd      	mov	sp, r7
 80046ec:	bd80      	pop	{r7, pc}
 80046ee:	bf00      	nop

080046f0 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 80046f0:	b580      	push	{r7, lr}
 80046f2:	b084      	sub	sp, #16
 80046f4:	af00      	add	r7, sp, #0
 80046f6:	60f8      	str	r0, [r7, #12]
 80046f8:	60b9      	str	r1, [r7, #8]
 80046fa:	607a      	str	r2, [r7, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 80046fc:	687b      	ldr	r3, [r7, #4]
 80046fe:	2204      	movs	r2, #4
 8004700:	68b9      	ldr	r1, [r7, #8]
 8004702:	68f8      	ldr	r0, [r7, #12]
 8004704:	f7ff ff8c 	bl	8004620 <chPoolObjectInitAligned>
}
 8004708:	bf00      	nop
 800470a:	3710      	adds	r7, #16
 800470c:	46bd      	mov	sp, r7
 800470e:	bd80      	pop	{r7, pc}

08004710 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8004710:	b480      	push	{r7}
 8004712:	b083      	sub	sp, #12
 8004714:	af00      	add	r7, sp, #0
 8004716:	6078      	str	r0, [r7, #4]

  dlp->next = (dyn_element_t *)dlp;
 8004718:	687b      	ldr	r3, [r7, #4]
 800471a:	687a      	ldr	r2, [r7, #4]
 800471c:	601a      	str	r2, [r3, #0]
}
 800471e:	bf00      	nop
 8004720:	370c      	adds	r7, #12
 8004722:	46bd      	mov	sp, r7
 8004724:	bc80      	pop	{r7}
 8004726:	4770      	bx	lr
	...

08004730 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8004730:	b580      	push	{r7, lr}
 8004732:	af00      	add	r7, sp, #0

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8004734:	4810      	ldr	r0, [pc, #64]	; (8004778 <__factory_init+0x48>)
 8004736:	f7ff fe83 	bl	8004440 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 800473a:	4810      	ldr	r0, [pc, #64]	; (800477c <__factory_init+0x4c>)
 800473c:	f7ff ffe8 	bl	8004710 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8004740:	4a0f      	ldr	r2, [pc, #60]	; (8004780 <__factory_init+0x50>)
 8004742:	2114      	movs	r1, #20
 8004744:	480f      	ldr	r0, [pc, #60]	; (8004784 <__factory_init+0x54>)
 8004746:	f7ff ffd3 	bl	80046f0 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 800474a:	480f      	ldr	r0, [pc, #60]	; (8004788 <__factory_init+0x58>)
 800474c:	f7ff ffe0 	bl	8004710 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8004750:	480e      	ldr	r0, [pc, #56]	; (800478c <__factory_init+0x5c>)
 8004752:	f7ff ffdd 	bl	8004710 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8004756:	4a0a      	ldr	r2, [pc, #40]	; (8004780 <__factory_init+0x50>)
 8004758:	211c      	movs	r1, #28
 800475a:	480d      	ldr	r0, [pc, #52]	; (8004790 <__factory_init+0x60>)
 800475c:	f7ff ffc8 	bl	80046f0 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8004760:	480c      	ldr	r0, [pc, #48]	; (8004794 <__factory_init+0x64>)
 8004762:	f7ff ffd5 	bl	8004710 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8004766:	480c      	ldr	r0, [pc, #48]	; (8004798 <__factory_init+0x68>)
 8004768:	f7ff ffd2 	bl	8004710 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 800476c:	480b      	ldr	r0, [pc, #44]	; (800479c <__factory_init+0x6c>)
 800476e:	f7ff ffcf 	bl	8004710 <dyn_list_init>
#endif
}
 8004772:	bf00      	nop
 8004774:	bd80      	pop	{r7, pc}
 8004776:	bf00      	nop
 8004778:	200012ec 	.word	0x200012ec
 800477c:	200012fc 	.word	0x200012fc
 8004780:	080046d1 	.word	0x080046d1
 8004784:	20001300 	.word	0x20001300
 8004788:	20001310 	.word	0x20001310
 800478c:	20001314 	.word	0x20001314
 8004790:	20001318 	.word	0x20001318
 8004794:	20001328 	.word	0x20001328
 8004798:	2000132c 	.word	0x2000132c
 800479c:	20001330 	.word	0x20001330

080047a0 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80047a0:	b480      	push	{r7}
 80047a2:	b085      	sub	sp, #20
 80047a4:	af00      	add	r7, sp, #0
 80047a6:	6078      	str	r0, [r7, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80047a8:	687b      	ldr	r3, [r7, #4]
 80047aa:	f003 0307 	and.w	r3, r3, #7
 80047ae:	60fb      	str	r3, [r7, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80047b0:	4b0c      	ldr	r3, [pc, #48]	; (80047e4 <__NVIC_SetPriorityGrouping+0x44>)
 80047b2:	68db      	ldr	r3, [r3, #12]
 80047b4:	60bb      	str	r3, [r7, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 80047b6:	68ba      	ldr	r2, [r7, #8]
 80047b8:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80047bc:	4013      	ands	r3, r2
 80047be:	60bb      	str	r3, [r7, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 80047c0:	68fb      	ldr	r3, [r7, #12]
 80047c2:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80047c4:	68bb      	ldr	r3, [r7, #8]
 80047c6:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 80047c8:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80047cc:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80047d0:	60bb      	str	r3, [r7, #8]
  SCB->AIRCR =  reg_value;
 80047d2:	4a04      	ldr	r2, [pc, #16]	; (80047e4 <__NVIC_SetPriorityGrouping+0x44>)
 80047d4:	68bb      	ldr	r3, [r7, #8]
 80047d6:	60d3      	str	r3, [r2, #12]
}
 80047d8:	bf00      	nop
 80047da:	3714      	adds	r7, #20
 80047dc:	46bd      	mov	sp, r7
 80047de:	bc80      	pop	{r7}
 80047e0:	4770      	bx	lr
 80047e2:	bf00      	nop
 80047e4:	e000ed00 	.word	0xe000ed00
	...

080047f0 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 80047f0:	b480      	push	{r7}
 80047f2:	b083      	sub	sp, #12
 80047f4:	af00      	add	r7, sp, #0
 80047f6:	4603      	mov	r3, r0
 80047f8:	6039      	str	r1, [r7, #0]
 80047fa:	71fb      	strb	r3, [r7, #7]
  if ((int32_t)(IRQn) >= 0)
 80047fc:	f997 3007 	ldrsb.w	r3, [r7, #7]
 8004800:	2b00      	cmp	r3, #0
 8004802:	db0a      	blt.n	800481a <__NVIC_SetPriority+0x2a>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8004804:	683b      	ldr	r3, [r7, #0]
 8004806:	b2da      	uxtb	r2, r3
 8004808:	490c      	ldr	r1, [pc, #48]	; (800483c <__NVIC_SetPriority+0x4c>)
 800480a:	f997 3007 	ldrsb.w	r3, [r7, #7]
 800480e:	0112      	lsls	r2, r2, #4
 8004810:	b2d2      	uxtb	r2, r2
 8004812:	440b      	add	r3, r1
 8004814:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8004818:	e00a      	b.n	8004830 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800481a:	683b      	ldr	r3, [r7, #0]
 800481c:	b2da      	uxtb	r2, r3
 800481e:	4908      	ldr	r1, [pc, #32]	; (8004840 <__NVIC_SetPriority+0x50>)
 8004820:	79fb      	ldrb	r3, [r7, #7]
 8004822:	f003 030f 	and.w	r3, r3, #15
 8004826:	3b04      	subs	r3, #4
 8004828:	0112      	lsls	r2, r2, #4
 800482a:	b2d2      	uxtb	r2, r2
 800482c:	440b      	add	r3, r1
 800482e:	761a      	strb	r2, [r3, #24]
}
 8004830:	bf00      	nop
 8004832:	370c      	adds	r7, #12
 8004834:	46bd      	mov	sp, r7
 8004836:	bc80      	pop	{r7}
 8004838:	4770      	bx	lr
 800483a:	bf00      	nop
 800483c:	e000e100 	.word	0xe000e100
 8004840:	e000ed00 	.word	0xe000ed00
	...

08004850 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8004850:	b480      	push	{r7}
 8004852:	b085      	sub	sp, #20
 8004854:	af00      	add	r7, sp, #0
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004856:	f3ef 8309 	mrs	r3, PSP
 800485a:	603b      	str	r3, [r7, #0]
  return(result);
 800485c:	683b      	ldr	r3, [r7, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 800485e:	60fb      	str	r3, [r7, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8004860:	68fb      	ldr	r3, [r7, #12]
 8004862:	3320      	adds	r3, #32
 8004864:	60fb      	str	r3, [r7, #12]
 8004866:	68fb      	ldr	r3, [r7, #12]
 8004868:	607b      	str	r3, [r7, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 800486a:	687b      	ldr	r3, [r7, #4]
 800486c:	f383 8809 	msr	PSP, r3
}
 8004870:	bf00      	nop
 8004872:	2300      	movs	r3, #0
 8004874:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004876:	68bb      	ldr	r3, [r7, #8]
 8004878:	f383 8811 	msr	BASEPRI, r3
}
 800487c:	bf00      	nop
 800487e:	bf00      	nop
}
 8004880:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8004882:	bf00      	nop
 8004884:	3714      	adds	r7, #20
 8004886:	46bd      	mov	sp, r7
 8004888:	bc80      	pop	{r7}
 800488a:	4770      	bx	lr
 800488c:	0000      	movs	r0, r0
	...

08004890 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8004890:	b580      	push	{r7, lr}
 8004892:	b084      	sub	sp, #16
 8004894:	af00      	add	r7, sp, #0
 8004896:	6078      	str	r0, [r7, #4]
 8004898:	2330      	movs	r3, #48	; 0x30
 800489a:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800489c:	68fb      	ldr	r3, [r7, #12]
 800489e:	f383 8811 	msr	BASEPRI, r3
}
 80048a2:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 80048a4:	b662      	cpsie	i
}
 80048a6:	bf00      	nop
}
 80048a8:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 80048aa:	2003      	movs	r0, #3
 80048ac:	f7ff ff78 	bl	80047a0 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80048b0:	4b0c      	ldr	r3, [pc, #48]	; (80048e4 <port_init+0x54>)
 80048b2:	68db      	ldr	r3, [r3, #12]
 80048b4:	4a0b      	ldr	r2, [pc, #44]	; (80048e4 <port_init+0x54>)
 80048b6:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80048ba:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80048bc:	4b0a      	ldr	r3, [pc, #40]	; (80048e8 <port_init+0x58>)
 80048be:	681b      	ldr	r3, [r3, #0]
 80048c0:	4a09      	ldr	r2, [pc, #36]	; (80048e8 <port_init+0x58>)
 80048c2:	f043 0301 	orr.w	r3, r3, #1
 80048c6:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 80048c8:	2102      	movs	r1, #2
 80048ca:	f06f 0004 	mvn.w	r0, #4
 80048ce:	f7ff ff8f 	bl	80047f0 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 80048d2:	2103      	movs	r1, #3
 80048d4:	f06f 0001 	mvn.w	r0, #1
 80048d8:	f7ff ff8a 	bl	80047f0 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 80048dc:	bf00      	nop
 80048de:	3710      	adds	r7, #16
 80048e0:	46bd      	mov	sp, r7
 80048e2:	bd80      	pop	{r7, pc}
 80048e4:	e000edf0 	.word	0xe000edf0
 80048e8:	e0001000 	.word	0xe0001000
 80048ec:	00000000 	.word	0x00000000

080048f0 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 80048f0:	b580      	push	{r7, lr}
 80048f2:	b086      	sub	sp, #24
 80048f4:	af00      	add	r7, sp, #0
 80048f6:	2330      	movs	r3, #48	; 0x30
 80048f8:	60fb      	str	r3, [r7, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80048fa:	68fb      	ldr	r3, [r7, #12]
 80048fc:	f383 8811 	msr	BASEPRI, r3
}
 8004900:	bf00      	nop
}
 8004902:	bf00      	nop
}
 8004904:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004906:	4b19      	ldr	r3, [pc, #100]	; (800496c <__port_irq_epilogue+0x7c>)
 8004908:	685b      	ldr	r3, [r3, #4]
 800490a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800490e:	2b00      	cmp	r3, #0
 8004910:	d020      	beq.n	8004954 <__port_irq_epilogue+0x64>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004912:	f3ef 8309 	mrs	r3, PSP
 8004916:	607b      	str	r3, [r7, #4]
  return(result);
 8004918:	687b      	ldr	r3, [r7, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 800491a:	617b      	str	r3, [r7, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800491c:	697b      	ldr	r3, [r7, #20]
 800491e:	3b20      	subs	r3, #32
 8004920:	617b      	str	r3, [r7, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004922:	697b      	ldr	r3, [r7, #20]
 8004924:	613b      	str	r3, [r7, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004926:	693b      	ldr	r3, [r7, #16]
 8004928:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800492c:	61da      	str	r2, [r3, #28]
 800492e:	697b      	ldr	r3, [r7, #20]
 8004930:	60bb      	str	r3, [r7, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004932:	68bb      	ldr	r3, [r7, #8]
 8004934:	f383 8809 	msr	PSP, r3
}
 8004938:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 800493a:	f7ff f8c1 	bl	8003ac0 <chSchIsPreemptionRequired>
 800493e:	4603      	mov	r3, r0
 8004940:	2b00      	cmp	r3, #0
 8004942:	d003      	beq.n	800494c <__port_irq_epilogue+0x5c>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 8004944:	4a0a      	ldr	r2, [pc, #40]	; (8004970 <__port_irq_epilogue+0x80>)
 8004946:	693b      	ldr	r3, [r7, #16]
 8004948:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 800494a:	e00b      	b.n	8004964 <__port_irq_epilogue+0x74>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 800494c:	4a09      	ldr	r2, [pc, #36]	; (8004974 <__port_irq_epilogue+0x84>)
 800494e:	693b      	ldr	r3, [r7, #16]
 8004950:	619a      	str	r2, [r3, #24]
    return;
 8004952:	e007      	b.n	8004964 <__port_irq_epilogue+0x74>
 8004954:	2300      	movs	r3, #0
 8004956:	603b      	str	r3, [r7, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004958:	683b      	ldr	r3, [r7, #0]
 800495a:	f383 8811 	msr	BASEPRI, r3
}
 800495e:	bf00      	nop
}
 8004960:	bf00      	nop
}
 8004962:	bf00      	nop
  }
  port_unlock_from_isr();
}
 8004964:	3718      	adds	r7, #24
 8004966:	46bd      	mov	sp, r7
 8004968:	bd80      	pop	{r7, pc}
 800496a:	bf00      	nop
 800496c:	e000ed00 	.word	0xe000ed00
 8004970:	080002e7 	.word	0x080002e7
 8004974:	080002f2 	.word	0x080002f2
	...

08004980 <end_cb1>:

/*
 * DAC streaming callback.
 */
size_t nx = 0, ny = 0, nz = 0;
static void end_cb1(DACDriver *dacp) {
 8004980:	b480      	push	{r7}
 8004982:	b083      	sub	sp, #12
 8004984:	af00      	add	r7, sp, #0
 8004986:	6078      	str	r0, [r7, #4]

  nz++;
 8004988:	4b15      	ldr	r3, [pc, #84]	; (80049e0 <end_cb1+0x60>)
 800498a:	681b      	ldr	r3, [r3, #0]
 800498c:	3301      	adds	r3, #1
 800498e:	4a14      	ldr	r2, [pc, #80]	; (80049e0 <end_cb1+0x60>)
 8004990:	6013      	str	r3, [r2, #0]
  if (dacIsBufferComplete(dacp)) {
 8004992:	687b      	ldr	r3, [r7, #4]
 8004994:	781b      	ldrb	r3, [r3, #0]
 8004996:	2b04      	cmp	r3, #4
 8004998:	d105      	bne.n	80049a6 <end_cb1+0x26>
    nx += DAC_BUFFER_SIZE / 2;
 800499a:	4b12      	ldr	r3, [pc, #72]	; (80049e4 <end_cb1+0x64>)
 800499c:	681b      	ldr	r3, [r3, #0]
 800499e:	33b4      	adds	r3, #180	; 0xb4
 80049a0:	4a10      	ldr	r2, [pc, #64]	; (80049e4 <end_cb1+0x64>)
 80049a2:	6013      	str	r3, [r2, #0]
 80049a4:	e004      	b.n	80049b0 <end_cb1+0x30>
  }
  else {
    ny += DAC_BUFFER_SIZE / 2;
 80049a6:	4b10      	ldr	r3, [pc, #64]	; (80049e8 <end_cb1+0x68>)
 80049a8:	681b      	ldr	r3, [r3, #0]
 80049aa:	33b4      	adds	r3, #180	; 0xb4
 80049ac:	4a0e      	ldr	r2, [pc, #56]	; (80049e8 <end_cb1+0x68>)
 80049ae:	6013      	str	r3, [r2, #0]
  }

  if ((nz % 1000) == 0) {
 80049b0:	4b0b      	ldr	r3, [pc, #44]	; (80049e0 <end_cb1+0x60>)
 80049b2:	681a      	ldr	r2, [r3, #0]
 80049b4:	4b0d      	ldr	r3, [pc, #52]	; (80049ec <end_cb1+0x6c>)
 80049b6:	fba3 1302 	umull	r1, r3, r3, r2
 80049ba:	099b      	lsrs	r3, r3, #6
 80049bc:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80049c0:	fb01 f303 	mul.w	r3, r1, r3
 80049c4:	1ad3      	subs	r3, r2, r3
 80049c6:	2b00      	cmp	r3, #0
 80049c8:	d105      	bne.n	80049d6 <end_cb1+0x56>
    palTogglePad(GPIOD, GPIOD_LED3);
 80049ca:	4b09      	ldr	r3, [pc, #36]	; (80049f0 <end_cb1+0x70>)
 80049cc:	695b      	ldr	r3, [r3, #20]
 80049ce:	4a08      	ldr	r2, [pc, #32]	; (80049f0 <end_cb1+0x70>)
 80049d0:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 80049d4:	6153      	str	r3, [r2, #20]
  }
}
 80049d6:	bf00      	nop
 80049d8:	370c      	adds	r7, #12
 80049da:	46bd      	mov	sp, r7
 80049dc:	bc80      	pop	{r7}
 80049de:	4770      	bx	lr
 80049e0:	2000133c 	.word	0x2000133c
 80049e4:	20001334 	.word	0x20001334
 80049e8:	20001338 	.word	0x20001338
 80049ec:	10624dd3 	.word	0x10624dd3
 80049f0:	40020c00 	.word	0x40020c00
	...

08004a00 <error_cb1>:

/*
 * DAC error callback.
 */
static void error_cb1(DACDriver *dacp, dacerror_t err) {
 8004a00:	b580      	push	{r7, lr}
 8004a02:	b082      	sub	sp, #8
 8004a04:	af00      	add	r7, sp, #0
 8004a06:	6078      	str	r0, [r7, #4]
 8004a08:	460b      	mov	r3, r1
 8004a0a:	70fb      	strb	r3, [r7, #3]

  (void)dacp;
  (void)err;

  chSysHalt("DAC failure");
 8004a0c:	4803      	ldr	r0, [pc, #12]	; (8004a1c <error_cb1+0x1c>)
 8004a0e:	f7fd fe8f 	bl	8002730 <chSysHalt>
}
 8004a12:	bf00      	nop
 8004a14:	3708      	adds	r7, #8
 8004a16:	46bd      	mov	sp, r7
 8004a18:	bd80      	pop	{r7, pc}
 8004a1a:	bf00      	nop
 8004a1c:	08004b10 	.word	0x08004b10

08004a20 <main>:
};

/*
 * Application entry point.
 */
int main(void) {
 8004a20:	b580      	push	{r7, lr}
 8004a22:	af00      	add	r7, sp, #0
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004a24:	f7fb fcc4 	bl	80003b0 <halInit>
  chSysInit();
 8004a28:	f7fd fe52 	bl	80026d0 <chSysInit>

  /*
   * Starting DAC1 driver, setting up the output pin as analog as suggested
   * by the Reference Manual.
   */
  palSetPadMode(GPIOA, 4, PAL_MODE_INPUT_ANALOG);
 8004a2c:	2203      	movs	r2, #3
 8004a2e:	2110      	movs	r1, #16
 8004a30:	4813      	ldr	r0, [pc, #76]	; (8004a80 <main+0x60>)
 8004a32:	f7fd fabd 	bl	8001fb0 <_pal_lld_setgroupmode>
  dacStart(&DACD1, &dac1cfg1);
 8004a36:	4913      	ldr	r1, [pc, #76]	; (8004a84 <main+0x64>)
 8004a38:	4813      	ldr	r0, [pc, #76]	; (8004a88 <main+0x68>)
 8004a3a:	f7fb fe09 	bl	8000650 <dacStart>

  /*
   * Starting GPT6 driver, it is used for triggering the DAC.
   */
  gptStart(&GPTD6, &gpt6cfg1);
 8004a3e:	4913      	ldr	r1, [pc, #76]	; (8004a8c <main+0x6c>)
 8004a40:	4813      	ldr	r0, [pc, #76]	; (8004a90 <main+0x70>)
 8004a42:	f7fb ff95 	bl	8000970 <gptStart>

  /*
   * Starting a continuous conversion.
   */
  dacStartConversion(&DACD1, &dacgrpcfg1,
 8004a46:	f44f 73b4 	mov.w	r3, #360	; 0x168
 8004a4a:	4a12      	ldr	r2, [pc, #72]	; (8004a94 <main+0x74>)
 8004a4c:	4912      	ldr	r1, [pc, #72]	; (8004a98 <main+0x78>)
 8004a4e:	480e      	ldr	r0, [pc, #56]	; (8004a88 <main+0x68>)
 8004a50:	f7fb fe46 	bl	80006e0 <dacStartConversion>
                     (dacsample_t *)dac_buffer, DAC_BUFFER_SIZE);
  gptStartContinuous(&GPTD6, 2U);
 8004a54:	2102      	movs	r1, #2
 8004a56:	480e      	ldr	r0, [pc, #56]	; (8004a90 <main+0x70>)
 8004a58:	f7fb ffda 	bl	8000a10 <gptStartContinuous>
  /*
   * Normal main() thread activity, if the button is pressed then the DAC
   * transfer is stopped.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON)) {
 8004a5c:	4b08      	ldr	r3, [pc, #32]	; (8004a80 <main+0x60>)
 8004a5e:	691b      	ldr	r3, [r3, #16]
 8004a60:	f003 0301 	and.w	r3, r3, #1
 8004a64:	2b00      	cmp	r3, #0
 8004a66:	d005      	beq.n	8004a74 <main+0x54>
      gptStopTimer(&GPTD6);
 8004a68:	4809      	ldr	r0, [pc, #36]	; (8004a90 <main+0x70>)
 8004a6a:	f7fc f819 	bl	8000aa0 <gptStopTimer>
      dacStopConversion(&DACD1);
 8004a6e:	4806      	ldr	r0, [pc, #24]	; (8004a88 <main+0x68>)
 8004a70:	f7fb fece 	bl	8000810 <dacStopConversion>
    }
    chThdSleepMilliseconds(500);
 8004a74:	f241 3088 	movw	r0, #5000	; 0x1388
 8004a78:	f7ff fbea 	bl	8004250 <chThdSleep>
    if (palReadPad(GPIOA, GPIOA_BUTTON)) {
 8004a7c:	e7ee      	b.n	8004a5c <main+0x3c>
 8004a7e:	bf00      	nop
 8004a80:	40020000 	.word	0x40020000
 8004a84:	080053d8 	.word	0x080053d8
 8004a88:	20000800 	.word	0x20000800
 8004a8c:	080053f0 	.word	0x080053f0
 8004a90:	200008e4 	.word	0x200008e4
 8004a94:	08005108 	.word	0x08005108
 8004a98:	080053e0 	.word	0x080053e0
