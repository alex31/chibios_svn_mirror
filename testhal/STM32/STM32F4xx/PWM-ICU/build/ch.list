
build/ch.elf:     file format elf32-littlearm


Disassembly of section .vectors:

08000000 <__vectors_base__>:
 8000000:	20000400 	.word	0x20000400
 8000004:	080002b9 	.word	0x080002b9
 8000008:	080002bb 	.word	0x080002bb
 800000c:	080002bb 	.word	0x080002bb
 8000010:	080002bb 	.word	0x080002bb
 8000014:	080002bb 	.word	0x080002bb
 8000018:	080002bb 	.word	0x080002bb
 800001c:	080002bb 	.word	0x080002bb
 8000020:	080002bb 	.word	0x080002bb
 8000024:	080002bb 	.word	0x080002bb
 8000028:	080002bb 	.word	0x080002bb
 800002c:	08003fb1 	.word	0x08003fb1
 8000030:	080002bb 	.word	0x080002bb
 8000034:	080002bb 	.word	0x080002bb
 8000038:	080002bb 	.word	0x080002bb
 800003c:	080002bb 	.word	0x080002bb
 8000040:	080002bb 	.word	0x080002bb
 8000044:	080002bb 	.word	0x080002bb
 8000048:	080002bb 	.word	0x080002bb
 800004c:	080002bb 	.word	0x080002bb
 8000050:	080002bb 	.word	0x080002bb
 8000054:	080002bb 	.word	0x080002bb
 8000058:	080002bb 	.word	0x080002bb
 800005c:	080002bb 	.word	0x080002bb
 8000060:	080002bb 	.word	0x080002bb
 8000064:	080002bb 	.word	0x080002bb
 8000068:	080002bb 	.word	0x080002bb
 800006c:	080002bb 	.word	0x080002bb
 8000070:	080002bb 	.word	0x080002bb
 8000074:	080002bb 	.word	0x080002bb
 8000078:	080002bb 	.word	0x080002bb
 800007c:	080002bb 	.word	0x080002bb
 8000080:	080002bb 	.word	0x080002bb
 8000084:	080002bb 	.word	0x080002bb
 8000088:	080002bb 	.word	0x080002bb
 800008c:	080002bb 	.word	0x080002bb
 8000090:	080002bb 	.word	0x080002bb
 8000094:	080002bb 	.word	0x080002bb
 8000098:	080002bb 	.word	0x080002bb
 800009c:	080002bb 	.word	0x080002bb
 80000a0:	08000f01 	.word	0x08000f01
 80000a4:	08000f31 	.word	0x08000f31
 80000a8:	08000f61 	.word	0x08000f61
 80000ac:	08000f91 	.word	0x08000f91
 80000b0:	08000fd1 	.word	0x08000fd1
 80000b4:	08001011 	.word	0x08001011
 80000b8:	080002bb 	.word	0x080002bb
 80000bc:	080002bb 	.word	0x080002bb
 80000c0:	080002bb 	.word	0x080002bb
 80000c4:	080002bb 	.word	0x080002bb
 80000c8:	080002bb 	.word	0x080002bb
 80000cc:	080002bb 	.word	0x080002bb
 80000d0:	080002bb 	.word	0x080002bb
 80000d4:	080002bb 	.word	0x080002bb
 80000d8:	080002bb 	.word	0x080002bb
 80000dc:	080002bb 	.word	0x080002bb
 80000e0:	080002bb 	.word	0x080002bb
 80000e4:	080002bb 	.word	0x080002bb
 80000e8:	080002bb 	.word	0x080002bb
 80000ec:	080002bb 	.word	0x080002bb
 80000f0:	080002bb 	.word	0x080002bb
 80000f4:	080002bb 	.word	0x080002bb
 80000f8:	080002bb 	.word	0x080002bb
 80000fc:	080002bb 	.word	0x080002bb
 8000100:	080002bb 	.word	0x080002bb
 8000104:	080002bb 	.word	0x080002bb
 8000108:	080002bb 	.word	0x080002bb
 800010c:	080002bb 	.word	0x080002bb
 8000110:	080002bb 	.word	0x080002bb
 8000114:	080002bb 	.word	0x080002bb
 8000118:	080002bb 	.word	0x080002bb
 800011c:	080002bb 	.word	0x080002bb
 8000120:	080002bb 	.word	0x080002bb
 8000124:	080002bb 	.word	0x080002bb
 8000128:	080002bb 	.word	0x080002bb
 800012c:	080002bb 	.word	0x080002bb
 8000130:	080002bb 	.word	0x080002bb
 8000134:	080002bb 	.word	0x080002bb
 8000138:	080002bb 	.word	0x080002bb
 800013c:	080002bb 	.word	0x080002bb
 8000140:	080002bb 	.word	0x080002bb
 8000144:	080002bb 	.word	0x080002bb
 8000148:	080002bb 	.word	0x080002bb
 800014c:	080002bb 	.word	0x080002bb
 8000150:	080002bb 	.word	0x080002bb
 8000154:	080002bb 	.word	0x080002bb
 8000158:	080002bb 	.word	0x080002bb
 800015c:	080002bb 	.word	0x080002bb
 8000160:	080002bb 	.word	0x080002bb
 8000164:	080002bb 	.word	0x080002bb
 8000168:	080002bb 	.word	0x080002bb
 800016c:	080002bb 	.word	0x080002bb
 8000170:	080002bb 	.word	0x080002bb
 8000174:	080002bb 	.word	0x080002bb
 8000178:	080002bb 	.word	0x080002bb
 800017c:	080002bb 	.word	0x080002bb
 8000180:	080002bb 	.word	0x080002bb
 8000184:	080002bb 	.word	0x080002bb
 8000188:	080002bb 	.word	0x080002bb
 800018c:	080002bb 	.word	0x080002bb
 8000190:	080002bb 	.word	0x080002bb
 8000194:	080002bb 	.word	0x080002bb
 8000198:	080002bb 	.word	0x080002bb
 800019c:	080002bb 	.word	0x080002bb
 80001a0:	080002bb 	.word	0x080002bb
 80001a4:	080002bb 	.word	0x080002bb
 80001a8:	080002bb 	.word	0x080002bb
 80001ac:	080002bb 	.word	0x080002bb
 80001b0:	080002bb 	.word	0x080002bb
 80001b4:	080002bb 	.word	0x080002bb
 80001b8:	080002bb 	.word	0x080002bb
 80001bc:	080002bb 	.word	0x080002bb
 80001c0:	080002bb 	.word	0x080002bb
 80001c4:	080002bb 	.word	0x080002bb
 80001c8:	080002bb 	.word	0x080002bb
 80001cc:	080002bb 	.word	0x080002bb
 80001d0:	080002bb 	.word	0x080002bb
 80001d4:	080002bb 	.word	0x080002bb
 80001d8:	080002bb 	.word	0x080002bb
 80001dc:	080002bb 	.word	0x080002bb

Disassembly of section .text:

080001e0 <_crt0_entry>:
                .align  2
                .thumb_func
                .global _crt0_entry
_crt0_entry:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 80001e0:	b672      	cpsid	i

#if CRT0_FORCE_MSP_INIT == TRUE
                /* MSP stack pointers initialization.*/
                ldr     r0, =__main_stack_end__
 80001e2:	4826      	ldr	r0, [pc, #152]	; (800027c <endfiniloop+0x6>)
                msr     MSP, r0
 80001e4:	f380 8808 	msr	MSP, r0
#endif

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 80001e8:	4825      	ldr	r0, [pc, #148]	; (8000280 <endfiniloop+0xa>)
                msr     PSP, r0
 80001ea:	f380 8809 	msr	PSP, r0

#if CRT0_VTOR_INIT == TRUE
                /* Initial VTOR position enforced.*/
                ldr     r0, =_vectors
 80001ee:	4825      	ldr	r0, [pc, #148]	; (8000284 <endfiniloop+0xe>)
                ldr     r1, =SCB_VTOR
 80001f0:	4925      	ldr	r1, [pc, #148]	; (8000288 <endfiniloop+0x12>)
                str     r0, [r1]
 80001f2:	6008      	str	r0, [r1, #0]

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 80001f4:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 80001f6:	f380 8814 	msr	CONTROL, r0
                isb
 80001fa:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __cpu_init
 80001fe:	f000 f87f 	bl	8000300 <__cpu_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000202:	f001 ff55 	bl	80020b0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 8000206:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800020a:	4920      	ldr	r1, [pc, #128]	; (800028c <endfiniloop+0x16>)
                ldr     r2, =__main_stack_end__
 800020c:	4a1b      	ldr	r2, [pc, #108]	; (800027c <endfiniloop+0x6>)

0800020e <msloop>:
msloop:
                cmp     r1, r2
 800020e:	4291      	cmp	r1, r2
                itt     lo
 8000210:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000212:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000216:	e7fa      	bcc.n	800020e <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 8000218:	491d      	ldr	r1, [pc, #116]	; (8000290 <endfiniloop+0x1a>)
                ldr     r2, =__process_stack_end__
 800021a:	4a19      	ldr	r2, [pc, #100]	; (8000280 <endfiniloop+0xa>)

0800021c <psloop>:
psloop:
                cmp     r1, r2
 800021c:	4291      	cmp	r1, r2
                itt     lo
 800021e:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000220:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000224:	e7fa      	bcc.n	800021c <psloop>

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                ldr     r1, =__textdata_base__
 8000226:	491b      	ldr	r1, [pc, #108]	; (8000294 <endfiniloop+0x1e>)
                ldr     r2, =__data_base__
 8000228:	4a1b      	ldr	r2, [pc, #108]	; (8000298 <endfiniloop+0x22>)
                ldr     r3, =__data_end__
 800022a:	4b1c      	ldr	r3, [pc, #112]	; (800029c <endfiniloop+0x26>)

0800022c <dloop>:
dloop:
                cmp     r2, r3
 800022c:	429a      	cmp	r2, r3
                ittt    lo
 800022e:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000230:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 8000234:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 8000238:	e7f8      	bcc.n	800022c <dloop>

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the BSS
                   size is a multiple of 4 so the linker file must ensure
                   this.*/
                movs    r0, #0
 800023a:	2000      	movs	r0, #0
                ldr     r1, =__bss_base__
 800023c:	4918      	ldr	r1, [pc, #96]	; (80002a0 <endfiniloop+0x2a>)
                ldr     r2, =__bss_end__
 800023e:	4a19      	ldr	r2, [pc, #100]	; (80002a4 <endfiniloop+0x2e>)

08000240 <bloop>:
bloop:
                cmp     r1, r2
 8000240:	4291      	cmp	r1, r2
                itt     lo
 8000242:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000244:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000248:	e7fa      	bcc.n	8000240 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 800024a:	f000 f871 	bl	8000330 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 800024e:	f000 f85f 	bl	8000310 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_base__
 8000252:	4c15      	ldr	r4, [pc, #84]	; (80002a8 <endfiniloop+0x32>)
                ldr     r5, =__init_array_end__
 8000254:	4d15      	ldr	r5, [pc, #84]	; (80002ac <endfiniloop+0x36>)

08000256 <initloop>:
initloop:
                cmp     r4, r5
 8000256:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000258:	da03      	bge.n	8000262 <endinitloop>
                ldr     r1, [r4], #4
 800025a:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800025e:	4788      	blx	r1
                b       initloop
 8000260:	e7f9      	b.n	8000256 <initloop>

08000262 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000262:	f003 ff8d 	bl	8004180 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_base__
 8000266:	4c12      	ldr	r4, [pc, #72]	; (80002b0 <endfiniloop+0x3a>)
                ldr     r5, =__fini_array_end__
 8000268:	4d12      	ldr	r5, [pc, #72]	; (80002b4 <endfiniloop+0x3e>)

0800026a <finiloop>:
finiloop:
                cmp     r4, r5
 800026a:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800026c:	da03      	bge.n	8000276 <endfiniloop>
                ldr     r1, [r4], #4
 800026e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000272:	4788      	blx	r1
                b       finiloop
 8000274:	e7f9      	b.n	800026a <finiloop>

08000276 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000276:	f000 b853 	b.w	8000320 <__default_exit>
 800027a:	0000      	.short	0x0000
                ldr     r0, =__main_stack_end__
 800027c:	20000400 	.word	0x20000400
                ldr     r0, =__process_stack_end__
 8000280:	20000800 	.word	0x20000800
                ldr     r0, =_vectors
 8000284:	08000000 	.word	0x08000000
                ldr     r1, =SCB_VTOR
 8000288:	e000ed08 	.word	0xe000ed08
                ldr     r1, =__main_stack_base__
 800028c:	20000000 	.word	0x20000000
                ldr     r1, =__process_stack_base__
 8000290:	20000400 	.word	0x20000400
                ldr     r1, =__textdata_base__
 8000294:	08004788 	.word	0x08004788
                ldr     r2, =__data_base__
 8000298:	20000800 	.word	0x20000800
                ldr     r3, =__data_end__
 800029c:	20000858 	.word	0x20000858
                ldr     r1, =__bss_base__
 80002a0:	20000858 	.word	0x20000858
                ldr     r2, =__bss_end__
 80002a4:	200012dc 	.word	0x200012dc
                ldr     r4, =__init_array_base__
 80002a8:	080001e0 	.word	0x080001e0
                ldr     r5, =__init_array_end__
 80002ac:	080001e0 	.word	0x080001e0
                ldr     r4, =__fini_array_base__
 80002b0:	080001e0 	.word	0x080001e0
                ldr     r5, =__fini_array_end__
 80002b4:	080001e0 	.word	0x080001e0

080002b8 <Reset_Handler>:

        .align      2
        .thumb_func
        .weak       Reset_Handler
Reset_Handler:
         b          _crt0_entry
 80002b8:	e792      	b.n	80001e0 <_crt0_entry>

080002ba <BusFault_Handler>:
        .thumb_func
Vector3F8:
        .thumb_func
Vector3FC:
#endif
        bl          _unhandled_exception
 80002ba:	f000 f800 	bl	80002be <_unhandled_exception>

080002be <_unhandled_exception>:

        .thumb_func
        .weak       _unhandled_exception
_unhandled_exception:
.stay:
        b           .stay
 80002be:	e7fe      	b.n	80002be <_unhandled_exception>

080002c0 <__port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  __port_switch
__port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if PORT_SWITCHED_REGIONS_NUMBER == 4
                push    {r4, r5, r6, r7, r8, r9, r10, r11}
#endif
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002c4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002c8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ca:	469d      	mov	sp, r3

#if CORTEX_USE_FPU
                /* Restoring FPU context.*/
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002cc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002d0 <__port_thread_start>:
__port_thread_start:
#if CH_DBG_ENABLE_STACK_CHECK && PORT_ENABLE_GUARD_PAGES
                bl      __port_set_region
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002d0:	f002 f80e 	bl	80022f0 <__dbg_check_unlock>
                bl      __stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002d4:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002d6:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002da:	4628      	mov	r0, r5
                blx     r4
 80002dc:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002de:	2000      	movs	r0, #0
                bl      chThdExit
 80002e0:	f003 fb86 	bl	80039f0 <chThdExit>

080002e4 <.zombies>:
.zombies:       b       .zombies
 80002e4:	e7fe      	b.n	80002e4 <.zombies>

080002e6 <__port_switch_from_isr>:
__port_switch_from_isr:
#if CH_DBG_STATISTICS
                bl      __stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_lock
 80002e6:	f001 ffdb 	bl	80022a0 <__dbg_check_lock>
#endif
                bl      chSchDoPreemption
 80002ea:	f003 f889 	bl	8003400 <chSchDoPreemption>
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      __dbg_check_unlock
 80002ee:	f001 ffff 	bl	80022f0 <__dbg_check_unlock>

080002f2 <__port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 80002f2:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 80002f4:	e7fe      	b.n	80002f4 <__port_exit_from_isr+0x2>
	...

08000300 <__cpu_init>:

#if CORTEX_MODEL == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000300:	bf00      	nop
 8000302:	4770      	bx	lr
	...

08000310 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000310:	bf00      	nop
 8000312:	4770      	bx	lr
	...

08000320 <__default_exit>:
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
 8000320:	e7fe      	b.n	8000320 <__default_exit>
 8000322:	bf00      	nop
	...

08000330 <__init_ram_areas>:
#endif

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000330:	b084      	sub	sp, #16
#if CRT0_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000332:	4b17      	ldr	r3, [pc, #92]	; (8000390 <__init_ram_areas+0x60>)
 8000334:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000336:	9b03      	ldr	r3, [sp, #12]
 8000338:	681b      	ldr	r3, [r3, #0]
 800033a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800033c:	9b03      	ldr	r3, [sp, #12]
 800033e:	685b      	ldr	r3, [r3, #4]
 8000340:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000342:	e009      	b.n	8000358 <__init_ram_areas+0x28>
      *p = *tp;
 8000344:	9b02      	ldr	r3, [sp, #8]
 8000346:	681a      	ldr	r2, [r3, #0]
 8000348:	9b01      	ldr	r3, [sp, #4]
 800034a:	601a      	str	r2, [r3, #0]
      p++;
 800034c:	9b01      	ldr	r3, [sp, #4]
 800034e:	3304      	adds	r3, #4
 8000350:	9301      	str	r3, [sp, #4]
      tp++;
 8000352:	9b02      	ldr	r3, [sp, #8]
 8000354:	3304      	adds	r3, #4
 8000356:	9302      	str	r3, [sp, #8]
    while (p < rap->clear_area) {
 8000358:	9b03      	ldr	r3, [sp, #12]
 800035a:	689b      	ldr	r3, [r3, #8]
 800035c:	9a01      	ldr	r2, [sp, #4]
 800035e:	429a      	cmp	r2, r3
 8000360:	d3f0      	bcc.n	8000344 <__init_ram_areas+0x14>
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000362:	e005      	b.n	8000370 <__init_ram_areas+0x40>
      *p = 0;
 8000364:	9b01      	ldr	r3, [sp, #4]
 8000366:	2200      	movs	r2, #0
 8000368:	601a      	str	r2, [r3, #0]
      p++;
 800036a:	9b01      	ldr	r3, [sp, #4]
 800036c:	3304      	adds	r3, #4
 800036e:	9301      	str	r3, [sp, #4]
    while (p < rap->no_init_area) {
 8000370:	9b03      	ldr	r3, [sp, #12]
 8000372:	68db      	ldr	r3, [r3, #12]
 8000374:	9a01      	ldr	r2, [sp, #4]
 8000376:	429a      	cmp	r2, r3
 8000378:	d3f4      	bcc.n	8000364 <__init_ram_areas+0x34>
    }
    rap++;
 800037a:	9b03      	ldr	r3, [sp, #12]
 800037c:	3310      	adds	r3, #16
 800037e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT0_AREAS_NUMBER]);
 8000380:	9b03      	ldr	r3, [sp, #12]
 8000382:	4a04      	ldr	r2, [pc, #16]	; (8000394 <__init_ram_areas+0x64>)
 8000384:	4293      	cmp	r3, r2
 8000386:	d3d6      	bcc.n	8000336 <__init_ram_areas+0x6>
#endif
}
 8000388:	bf00      	nop
 800038a:	bf00      	nop
 800038c:	b004      	add	sp, #16
 800038e:	4770      	bx	lr
 8000390:	08004320 	.word	0x08004320
 8000394:	080043a0 	.word	0x080043a0
	...

080003a0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 80003a0:	bf00      	nop
 80003a2:	4770      	bx	lr
	...

080003b0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 80003b0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 80003b2:	f7ff fff5 	bl	80003a0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 80003b6:	f000 fed3 	bl	8001160 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
#if defined(PAL_NEW_INIT)
  palInit();
 80003ba:	f000 ffc9 	bl	8001350 <_pal_lld_init>
#endif
#if (HAL_USE_I2S == TRUE) || defined(__DOXYGEN__)
  i2sInit();
#endif
#if (HAL_USE_ICU == TRUE) || defined(__DOXYGEN__)
  icuInit();
 80003be:	f000 f8f7 	bl	80005b0 <icuInit>
#endif
#if (HAL_USE_MAC == TRUE) || defined(__DOXYGEN__)
  macInit();
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
 80003c2:	f000 fa8d 	bl	80008e0 <pwmInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 80003c6:	f001 fe7b 	bl	80020c0 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 80003ca:	f000 f851 	bl	8000470 <stInit>
#endif
}
 80003ce:	bf00      	nop
 80003d0:	bd08      	pop	{r3, pc}
 80003d2:	bf00      	nop
	...

080003e0 <st_lld_get_counter>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80003e0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80003e4:	6a5b      	ldr	r3, [r3, #36]	; 0x24
}
 80003e6:	4618      	mov	r0, r3
 80003e8:	4770      	bx	lr
 80003ea:	bf00      	nop
 80003ec:	0000      	movs	r0, r0
	...

080003f0 <st_lld_start_alarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t abstime) {
 80003f0:	b082      	sub	sp, #8
 80003f2:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 80003f4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80003f8:	9b01      	ldr	r3, [sp, #4]
 80003fa:	6353      	str	r3, [r2, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80003fc:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000400:	2200      	movs	r2, #0
 8000402:	611a      	str	r2, [r3, #16]
#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8000404:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000408:	2202      	movs	r2, #2
 800040a:	60da      	str	r2, [r3, #12]
#else
  STM32_ST_TIM->DIER  |= STM32_TIM_DIER_CC1IE;
#endif
}
 800040c:	bf00      	nop
 800040e:	b002      	add	sp, #8
 8000410:	4770      	bx	lr
 8000412:	bf00      	nop
	...

08000420 <st_lld_stop_alarm>:
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

#if ST_LLD_NUM_ALARMS == 1
  STM32_ST_TIM->DIER = 0U;
 8000420:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000424:	2200      	movs	r2, #0
 8000426:	60da      	str	r2, [r3, #12]
#else
 STM32_ST_TIM->DIER &= ~STM32_TIM_DIER_CC1IE;
#endif
}
 8000428:	bf00      	nop
 800042a:	4770      	bx	lr
 800042c:	0000      	movs	r0, r0
	...

08000430 <st_lld_set_alarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t abstime) {
 8000430:	b082      	sub	sp, #8
 8000432:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)abstime;
 8000434:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8000438:	9b01      	ldr	r3, [sp, #4]
 800043a:	6353      	str	r3, [r2, #52]	; 0x34
}
 800043c:	bf00      	nop
 800043e:	b002      	add	sp, #8
 8000440:	4770      	bx	lr
 8000442:	bf00      	nop
	...

08000450 <st_lld_is_alarm_active>:
 *
 * @notapi
 */
static inline bool st_lld_is_alarm_active(void) {

  return (bool)((STM32_ST_TIM->DIER & STM32_TIM_DIER_CC1IE) != 0);
 8000450:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8000454:	68db      	ldr	r3, [r3, #12]
 8000456:	f003 0302 	and.w	r3, r3, #2
 800045a:	2b00      	cmp	r3, #0
 800045c:	bf14      	ite	ne
 800045e:	2301      	movne	r3, #1
 8000460:	2300      	moveq	r3, #0
 8000462:	b2db      	uxtb	r3, r3
}
 8000464:	4618      	mov	r0, r3
 8000466:	4770      	bx	lr
	...

08000470 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8000470:	b508      	push	{r3, lr}

  for (i = 0U; i < (unsigned)ST_LLD_NUM_ALARMS; i++) {
    st_callbacks[i] = NULL;
  }
#endif
  st_lld_init();
 8000472:	f001 f865 	bl	8001540 <st_lld_init>
}
 8000476:	bf00      	nop
 8000478:	bd08      	pop	{r3, pc}
 800047a:	bf00      	nop
 800047c:	0000      	movs	r0, r0
	...

08000480 <stGetCounter>:
 *
 * @return              The counter value.
 *
 * @api
 */
systime_t stGetCounter(void) {
 8000480:	b508      	push	{r3, lr}

  return st_lld_get_counter();
 8000482:	f7ff ffad 	bl	80003e0 <st_lld_get_counter>
 8000486:	4603      	mov	r3, r0
}
 8000488:	4618      	mov	r0, r3
 800048a:	bd08      	pop	{r3, pc}
 800048c:	0000      	movs	r0, r0
	...

08000490 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8000490:	b500      	push	{lr}
 8000492:	b083      	sub	sp, #12
 8000494:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");
 8000496:	f000 f833 	bl	8000500 <stIsAlarmActive>
 800049a:	4603      	mov	r3, r0
 800049c:	2b00      	cmp	r3, #0
 800049e:	d002      	beq.n	80004a6 <stStartAlarm+0x16>
 80004a0:	4804      	ldr	r0, [pc, #16]	; (80004b4 <stStartAlarm+0x24>)
 80004a2:	f001 fead 	bl	8002200 <chSysHalt>

  st_lld_start_alarm(abstime);
 80004a6:	9801      	ldr	r0, [sp, #4]
 80004a8:	f7ff ffa2 	bl	80003f0 <st_lld_start_alarm>
}
 80004ac:	bf00      	nop
 80004ae:	b003      	add	sp, #12
 80004b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80004b4:	080043a0 	.word	0x080043a0
	...

080004c0 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 80004c0:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 80004c2:	f7ff ffad 	bl	8000420 <st_lld_stop_alarm>
}
 80004c6:	bf00      	nop
 80004c8:	bd08      	pop	{r3, pc}
 80004ca:	bf00      	nop
 80004cc:	0000      	movs	r0, r0
	...

080004d0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 80004d0:	b500      	push	{lr}
 80004d2:	b083      	sub	sp, #12
 80004d4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");
 80004d6:	f000 f813 	bl	8000500 <stIsAlarmActive>
 80004da:	4603      	mov	r3, r0
 80004dc:	f083 0301 	eor.w	r3, r3, #1
 80004e0:	b2db      	uxtb	r3, r3
 80004e2:	2b00      	cmp	r3, #0
 80004e4:	d002      	beq.n	80004ec <stSetAlarm+0x1c>
 80004e6:	4805      	ldr	r0, [pc, #20]	; (80004fc <stSetAlarm+0x2c>)
 80004e8:	f001 fe8a 	bl	8002200 <chSysHalt>

  st_lld_set_alarm(abstime);
 80004ec:	9801      	ldr	r0, [sp, #4]
 80004ee:	f7ff ff9f 	bl	8000430 <st_lld_set_alarm>
}
 80004f2:	bf00      	nop
 80004f4:	b003      	add	sp, #12
 80004f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80004fa:	bf00      	nop
 80004fc:	080043b0 	.word	0x080043b0

08000500 <stIsAlarmActive>:
 * @retval false        if the alarm is not active.
 * @retval true         is the alarm is active
 *
 * @api
 */
bool stIsAlarmActive(void) {
 8000500:	b508      	push	{r3, lr}

  return st_lld_is_alarm_active();
 8000502:	f7ff ffa5 	bl	8000450 <st_lld_is_alarm_active>
 8000506:	4603      	mov	r3, r0
}
 8000508:	4618      	mov	r0, r3
 800050a:	bd08      	pop	{r3, pc}
 800050c:	0000      	movs	r0, r0
	...

08000510 <chSysLock>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to disabling interrupts.
 *
 * @special
 */
static inline void chSysLock(void) {
 8000510:	b500      	push	{lr}
 8000512:	b083      	sub	sp, #12
 8000514:	2330      	movs	r3, #48	; 0x30
 8000516:	9301      	str	r3, [sp, #4]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__STATIC_FORCEINLINE void __set_BASEPRI(uint32_t basePri)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000518:	9b01      	ldr	r3, [sp, #4]
 800051a:	f383 8811 	msr	BASEPRI, r3
}
 800051e:	bf00      	nop
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000520:	bf00      	nop

  port_lock();
  __stats_start_measure_crit_thd();
  __dbg_check_lock();
 8000522:	f001 febd 	bl	80022a0 <__dbg_check_lock>
}
 8000526:	bf00      	nop
 8000528:	b003      	add	sp, #12
 800052a:	f85d fb04 	ldr.w	pc, [sp], #4
 800052e:	bf00      	nop

08000530 <chSysUnlock>:
 * @note    The exact behavior of this function is port-dependent and could
 *          not be limited to enabling interrupts.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8000530:	b500      	push	{lr}
 8000532:	b083      	sub	sp, #12

  __dbg_check_unlock();
 8000534:	f001 fedc 	bl	80022f0 <__dbg_check_unlock>

  /* The following condition can be triggered by the use of i-class functions
     in a critical section not followed by a chSchRescheduleS(), this means
     that the current thread has a lower priority than the next thread in
     the ready list.*/
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000538:	4b12      	ldr	r3, [pc, #72]	; (8000584 <chSysUnlock+0x54>)
 800053a:	681b      	ldr	r3, [r3, #0]
 800053c:	4a11      	ldr	r2, [pc, #68]	; (8000584 <chSysUnlock+0x54>)
 800053e:	4293      	cmp	r3, r2
 8000540:	bf14      	ite	ne
 8000542:	2301      	movne	r3, #1
 8000544:	2300      	moveq	r3, #0
 8000546:	b2db      	uxtb	r3, r3
 8000548:	2b00      	cmp	r3, #0
 800054a:	d00f      	beq.n	800056c <chSysUnlock+0x3c>
 800054c:	4b0d      	ldr	r3, [pc, #52]	; (8000584 <chSysUnlock+0x54>)
 800054e:	68db      	ldr	r3, [r3, #12]
 8000550:	689a      	ldr	r2, [r3, #8]
 8000552:	4b0c      	ldr	r3, [pc, #48]	; (8000584 <chSysUnlock+0x54>)
 8000554:	681b      	ldr	r3, [r3, #0]
 8000556:	689b      	ldr	r3, [r3, #8]
 8000558:	429a      	cmp	r2, r3
 800055a:	bf34      	ite	cc
 800055c:	2301      	movcc	r3, #1
 800055e:	2300      	movcs	r3, #0
 8000560:	b2db      	uxtb	r3, r3
 8000562:	2b00      	cmp	r3, #0
 8000564:	d002      	beq.n	800056c <chSysUnlock+0x3c>
 8000566:	4808      	ldr	r0, [pc, #32]	; (8000588 <chSysUnlock+0x58>)
 8000568:	f001 fe4a 	bl	8002200 <chSysHalt>
 800056c:	2300      	movs	r3, #0
 800056e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000570:	9b01      	ldr	r3, [sp, #4]
 8000572:	f383 8811 	msr	BASEPRI, r3
}
 8000576:	bf00      	nop
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000578:	bf00      	nop
              (currcore->rlist.current->hdr.pqueue.prio >= currcore->rlist.pqueue.next->prio),
              "priority order violation");

  port_unlock();
}
 800057a:	bf00      	nop
 800057c:	b003      	add	sp, #12
 800057e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000582:	bf00      	nop
 8000584:	200008a0 	.word	0x200008a0
 8000588:	080043c8 	.word	0x080043c8
 800058c:	00000000 	.word	0x00000000

08000590 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8000590:	b508      	push	{r3, lr}

  chSysLock();
 8000592:	f7ff ffbd 	bl	8000510 <chSysLock>
}
 8000596:	bf00      	nop
 8000598:	bd08      	pop	{r3, pc}
 800059a:	bf00      	nop
 800059c:	0000      	movs	r0, r0
	...

080005a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80005a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80005a2:	f7ff ffc5 	bl	8000530 <chSysUnlock>
}
 80005a6:	bf00      	nop
 80005a8:	bd08      	pop	{r3, pc}
 80005aa:	bf00      	nop
 80005ac:	0000      	movs	r0, r0
	...

080005b0 <icuInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void icuInit(void) {
 80005b0:	b508      	push	{r3, lr}

  icu_lld_init();
 80005b2:	f001 f82d 	bl	8001610 <icu_lld_init>
}
 80005b6:	bf00      	nop
 80005b8:	bd08      	pop	{r3, pc}
 80005ba:	bf00      	nop
 80005bc:	0000      	movs	r0, r0
	...

080005c0 <icuObjectInit>:
 *
 * @param[out] icup     pointer to the @p ICUDriver object
 *
 * @init
 */
void icuObjectInit(ICUDriver *icup) {
 80005c0:	b082      	sub	sp, #8
 80005c2:	9001      	str	r0, [sp, #4]

  icup->state  = ICU_STOP;
 80005c4:	9b01      	ldr	r3, [sp, #4]
 80005c6:	2201      	movs	r2, #1
 80005c8:	701a      	strb	r2, [r3, #0]
  icup->config = NULL;
 80005ca:	9b01      	ldr	r3, [sp, #4]
 80005cc:	2200      	movs	r2, #0
 80005ce:	605a      	str	r2, [r3, #4]
}
 80005d0:	bf00      	nop
 80005d2:	b002      	add	sp, #8
 80005d4:	4770      	bx	lr
 80005d6:	bf00      	nop
	...

080005e0 <icuStart>:
 * @param[in] config    pointer to the @p ICUConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t icuStart(ICUDriver *icup, const ICUConfig *config) {
 80005e0:	b500      	push	{lr}
 80005e2:	b085      	sub	sp, #20
 80005e4:	9001      	str	r0, [sp, #4]
 80005e6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((icup != NULL) && (config != NULL));
 80005e8:	9b01      	ldr	r3, [sp, #4]
 80005ea:	2b00      	cmp	r3, #0
 80005ec:	bf0c      	ite	eq
 80005ee:	2301      	moveq	r3, #1
 80005f0:	2300      	movne	r3, #0
 80005f2:	b2db      	uxtb	r3, r3
 80005f4:	2b00      	cmp	r3, #0
 80005f6:	d107      	bne.n	8000608 <icuStart+0x28>
 80005f8:	9b00      	ldr	r3, [sp, #0]
 80005fa:	2b00      	cmp	r3, #0
 80005fc:	bf0c      	ite	eq
 80005fe:	2301      	moveq	r3, #1
 8000600:	2300      	movne	r3, #0
 8000602:	b2db      	uxtb	r3, r3
 8000604:	2b00      	cmp	r3, #0
 8000606:	d002      	beq.n	800060e <icuStart+0x2e>
 8000608:	4819      	ldr	r0, [pc, #100]	; (8000670 <icuStart+0x90>)
 800060a:	f001 fdf9 	bl	8002200 <chSysHalt>

  osalSysLock();
 800060e:	f7ff ffbf 	bl	8000590 <osalSysLock>
  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 8000612:	9b01      	ldr	r3, [sp, #4]
 8000614:	781b      	ldrb	r3, [r3, #0]
 8000616:	2b01      	cmp	r3, #1
 8000618:	bf14      	ite	ne
 800061a:	2301      	movne	r3, #1
 800061c:	2300      	moveq	r3, #0
 800061e:	b2db      	uxtb	r3, r3
 8000620:	2b00      	cmp	r3, #0
 8000622:	d00b      	beq.n	800063c <icuStart+0x5c>
 8000624:	9b01      	ldr	r3, [sp, #4]
 8000626:	781b      	ldrb	r3, [r3, #0]
 8000628:	2b02      	cmp	r3, #2
 800062a:	bf14      	ite	ne
 800062c:	2301      	movne	r3, #1
 800062e:	2300      	moveq	r3, #0
 8000630:	b2db      	uxtb	r3, r3
 8000632:	2b00      	cmp	r3, #0
 8000634:	d002      	beq.n	800063c <icuStart+0x5c>
 8000636:	480e      	ldr	r0, [pc, #56]	; (8000670 <icuStart+0x90>)
 8000638:	f001 fde2 	bl	8002200 <chSysHalt>
                "invalid state");

  icup->config = config;
 800063c:	9b01      	ldr	r3, [sp, #4]
 800063e:	9a00      	ldr	r2, [sp, #0]
 8000640:	605a      	str	r2, [r3, #4]

#if defined(ICU_LLD_ENHANCED_API)
  msg = icu_lld_start(icup);
#else
  icu_lld_start(icup);
 8000642:	9801      	ldr	r0, [sp, #4]
 8000644:	f000 fff4 	bl	8001630 <icu_lld_start>
  msg = HAL_RET_SUCCESS;
 8000648:	2300      	movs	r3, #0
 800064a:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800064c:	9b03      	ldr	r3, [sp, #12]
 800064e:	2b00      	cmp	r3, #0
 8000650:	d103      	bne.n	800065a <icuStart+0x7a>
    icup->state = ICU_READY;
 8000652:	9b01      	ldr	r3, [sp, #4]
 8000654:	2202      	movs	r2, #2
 8000656:	701a      	strb	r2, [r3, #0]
 8000658:	e002      	b.n	8000660 <icuStart+0x80>
  }
  else {
    icup->state = ICU_STOP;
 800065a:	9b01      	ldr	r3, [sp, #4]
 800065c:	2201      	movs	r2, #1
 800065e:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 8000660:	f7ff ff9e 	bl	80005a0 <osalSysUnlock>

  return msg;
 8000664:	9b03      	ldr	r3, [sp, #12]
}
 8000666:	4618      	mov	r0, r3
 8000668:	b005      	add	sp, #20
 800066a:	f85d fb04 	ldr.w	pc, [sp], #4
 800066e:	bf00      	nop
 8000670:	080043bc 	.word	0x080043bc
	...

08000680 <icuStop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStop(ICUDriver *icup) {
 8000680:	b500      	push	{lr}
 8000682:	b083      	sub	sp, #12
 8000684:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 8000686:	9b01      	ldr	r3, [sp, #4]
 8000688:	2b00      	cmp	r3, #0
 800068a:	bf0c      	ite	eq
 800068c:	2301      	moveq	r3, #1
 800068e:	2300      	movne	r3, #0
 8000690:	b2db      	uxtb	r3, r3
 8000692:	2b00      	cmp	r3, #0
 8000694:	d002      	beq.n	800069c <icuStop+0x1c>
 8000696:	4814      	ldr	r0, [pc, #80]	; (80006e8 <icuStop+0x68>)
 8000698:	f001 fdb2 	bl	8002200 <chSysHalt>

  osalSysLock();
 800069c:	f7ff ff78 	bl	8000590 <osalSysLock>

  osalDbgAssert((icup->state == ICU_STOP) || (icup->state == ICU_READY),
 80006a0:	9b01      	ldr	r3, [sp, #4]
 80006a2:	781b      	ldrb	r3, [r3, #0]
 80006a4:	2b01      	cmp	r3, #1
 80006a6:	bf14      	ite	ne
 80006a8:	2301      	movne	r3, #1
 80006aa:	2300      	moveq	r3, #0
 80006ac:	b2db      	uxtb	r3, r3
 80006ae:	2b00      	cmp	r3, #0
 80006b0:	d00b      	beq.n	80006ca <icuStop+0x4a>
 80006b2:	9b01      	ldr	r3, [sp, #4]
 80006b4:	781b      	ldrb	r3, [r3, #0]
 80006b6:	2b02      	cmp	r3, #2
 80006b8:	bf14      	ite	ne
 80006ba:	2301      	movne	r3, #1
 80006bc:	2300      	moveq	r3, #0
 80006be:	b2db      	uxtb	r3, r3
 80006c0:	2b00      	cmp	r3, #0
 80006c2:	d002      	beq.n	80006ca <icuStop+0x4a>
 80006c4:	4808      	ldr	r0, [pc, #32]	; (80006e8 <icuStop+0x68>)
 80006c6:	f001 fd9b 	bl	8002200 <chSysHalt>
                "invalid state");

  icu_lld_stop(icup);
 80006ca:	9801      	ldr	r0, [sp, #4]
 80006cc:	f001 f8a8 	bl	8001820 <icu_lld_stop>
  icup->config = NULL;
 80006d0:	9b01      	ldr	r3, [sp, #4]
 80006d2:	2200      	movs	r2, #0
 80006d4:	605a      	str	r2, [r3, #4]
  icup->state  = ICU_STOP;
 80006d6:	9b01      	ldr	r3, [sp, #4]
 80006d8:	2201      	movs	r2, #1
 80006da:	701a      	strb	r2, [r3, #0]

  osalSysUnlock();
 80006dc:	f7ff ff60 	bl	80005a0 <osalSysUnlock>
}
 80006e0:	bf00      	nop
 80006e2:	b003      	add	sp, #12
 80006e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80006e8:	080043d4 	.word	0x080043d4
 80006ec:	00000000 	.word	0x00000000

080006f0 <icuStartCapture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStartCapture(ICUDriver *icup) {
 80006f0:	b500      	push	{lr}
 80006f2:	b083      	sub	sp, #12
 80006f4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 80006f6:	9b01      	ldr	r3, [sp, #4]
 80006f8:	2b00      	cmp	r3, #0
 80006fa:	bf0c      	ite	eq
 80006fc:	2301      	moveq	r3, #1
 80006fe:	2300      	movne	r3, #0
 8000700:	b2db      	uxtb	r3, r3
 8000702:	2b00      	cmp	r3, #0
 8000704:	d002      	beq.n	800070c <icuStartCapture+0x1c>
 8000706:	480e      	ldr	r0, [pc, #56]	; (8000740 <icuStartCapture+0x50>)
 8000708:	f001 fd7a 	bl	8002200 <chSysHalt>

  osalSysLock();
 800070c:	f7ff ff40 	bl	8000590 <osalSysLock>
  osalDbgAssert(icup->state == ICU_READY, "invalid state");
 8000710:	9b01      	ldr	r3, [sp, #4]
 8000712:	781b      	ldrb	r3, [r3, #0]
 8000714:	2b02      	cmp	r3, #2
 8000716:	bf14      	ite	ne
 8000718:	2301      	movne	r3, #1
 800071a:	2300      	moveq	r3, #0
 800071c:	b2db      	uxtb	r3, r3
 800071e:	2b00      	cmp	r3, #0
 8000720:	d002      	beq.n	8000728 <icuStartCapture+0x38>
 8000722:	4807      	ldr	r0, [pc, #28]	; (8000740 <icuStartCapture+0x50>)
 8000724:	f001 fd6c 	bl	8002200 <chSysHalt>
  icuStartCaptureI(icup);
 8000728:	9801      	ldr	r0, [sp, #4]
 800072a:	f001 f8a9 	bl	8001880 <icu_lld_start_capture>
 800072e:	9b01      	ldr	r3, [sp, #4]
 8000730:	2203      	movs	r2, #3
 8000732:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8000734:	f7ff ff34 	bl	80005a0 <osalSysUnlock>
}
 8000738:	bf00      	nop
 800073a:	b003      	add	sp, #12
 800073c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000740:	080043dc 	.word	0x080043dc
	...

08000750 <icuStopCapture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuStopCapture(ICUDriver *icup) {
 8000750:	b500      	push	{lr}
 8000752:	b083      	sub	sp, #12
 8000754:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 8000756:	9b01      	ldr	r3, [sp, #4]
 8000758:	2b00      	cmp	r3, #0
 800075a:	bf0c      	ite	eq
 800075c:	2301      	moveq	r3, #1
 800075e:	2300      	movne	r3, #0
 8000760:	b2db      	uxtb	r3, r3
 8000762:	2b00      	cmp	r3, #0
 8000764:	d002      	beq.n	800076c <icuStopCapture+0x1c>
 8000766:	481a      	ldr	r0, [pc, #104]	; (80007d0 <icuStopCapture+0x80>)
 8000768:	f001 fd4a 	bl	8002200 <chSysHalt>

  osalSysLock();
 800076c:	f7ff ff10 	bl	8000590 <osalSysLock>
  osalDbgAssert((icup->state == ICU_READY) || (icup->state == ICU_WAITING) ||
 8000770:	9b01      	ldr	r3, [sp, #4]
 8000772:	781b      	ldrb	r3, [r3, #0]
 8000774:	2b02      	cmp	r3, #2
 8000776:	bf14      	ite	ne
 8000778:	2301      	movne	r3, #1
 800077a:	2300      	moveq	r3, #0
 800077c:	b2db      	uxtb	r3, r3
 800077e:	2b00      	cmp	r3, #0
 8000780:	d00a      	beq.n	8000798 <icuStopCapture+0x48>
 8000782:	9b01      	ldr	r3, [sp, #4]
 8000784:	781b      	ldrb	r3, [r3, #0]
 8000786:	2b03      	cmp	r3, #3
 8000788:	bf14      	ite	ne
 800078a:	2301      	movne	r3, #1
 800078c:	2300      	moveq	r3, #0
 800078e:	b2db      	uxtb	r3, r3
 8000790:	2b00      	cmp	r3, #0
 8000792:	d001      	beq.n	8000798 <icuStopCapture+0x48>
 8000794:	2301      	movs	r3, #1
 8000796:	e000      	b.n	800079a <icuStopCapture+0x4a>
 8000798:	2300      	movs	r3, #0
 800079a:	2b00      	cmp	r3, #0
 800079c:	d00b      	beq.n	80007b6 <icuStopCapture+0x66>
 800079e:	9b01      	ldr	r3, [sp, #4]
 80007a0:	781b      	ldrb	r3, [r3, #0]
 80007a2:	2b04      	cmp	r3, #4
 80007a4:	bf14      	ite	ne
 80007a6:	2301      	movne	r3, #1
 80007a8:	2300      	moveq	r3, #0
 80007aa:	b2db      	uxtb	r3, r3
 80007ac:	2b00      	cmp	r3, #0
 80007ae:	d002      	beq.n	80007b6 <icuStopCapture+0x66>
 80007b0:	4807      	ldr	r0, [pc, #28]	; (80007d0 <icuStopCapture+0x80>)
 80007b2:	f001 fd25 	bl	8002200 <chSysHalt>
                (icup->state == ICU_ACTIVE),
                "invalid state");
  icuStopCaptureI(icup);
 80007b6:	9801      	ldr	r0, [sp, #4]
 80007b8:	f001 f87a 	bl	80018b0 <icu_lld_stop_capture>
 80007bc:	9b01      	ldr	r3, [sp, #4]
 80007be:	2202      	movs	r2, #2
 80007c0:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80007c2:	f7ff feed 	bl	80005a0 <osalSysUnlock>
}
 80007c6:	bf00      	nop
 80007c8:	b003      	add	sp, #12
 80007ca:	f85d fb04 	ldr.w	pc, [sp], #4
 80007ce:	bf00      	nop
 80007d0:	080043ec 	.word	0x080043ec
	...

080007e0 <icuEnableNotifications>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @api
 */
void icuEnableNotifications(ICUDriver *icup) {
 80007e0:	b500      	push	{lr}
 80007e2:	b083      	sub	sp, #12
 80007e4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(icup != NULL);
 80007e6:	9b01      	ldr	r3, [sp, #4]
 80007e8:	2b00      	cmp	r3, #0
 80007ea:	bf0c      	ite	eq
 80007ec:	2301      	moveq	r3, #1
 80007ee:	2300      	movne	r3, #0
 80007f0:	b2db      	uxtb	r3, r3
 80007f2:	2b00      	cmp	r3, #0
 80007f4:	d002      	beq.n	80007fc <icuEnableNotifications+0x1c>
 80007f6:	4811      	ldr	r0, [pc, #68]	; (800083c <icuEnableNotifications+0x5c>)
 80007f8:	f001 fd02 	bl	8002200 <chSysHalt>

  osalSysLock();
 80007fc:	f7ff fec8 	bl	8000590 <osalSysLock>
  osalDbgAssert((icup->state == ICU_WAITING) || (icup->state == ICU_ACTIVE),
 8000800:	9b01      	ldr	r3, [sp, #4]
 8000802:	781b      	ldrb	r3, [r3, #0]
 8000804:	2b03      	cmp	r3, #3
 8000806:	bf14      	ite	ne
 8000808:	2301      	movne	r3, #1
 800080a:	2300      	moveq	r3, #0
 800080c:	b2db      	uxtb	r3, r3
 800080e:	2b00      	cmp	r3, #0
 8000810:	d00b      	beq.n	800082a <icuEnableNotifications+0x4a>
 8000812:	9b01      	ldr	r3, [sp, #4]
 8000814:	781b      	ldrb	r3, [r3, #0]
 8000816:	2b04      	cmp	r3, #4
 8000818:	bf14      	ite	ne
 800081a:	2301      	movne	r3, #1
 800081c:	2300      	moveq	r3, #0
 800081e:	b2db      	uxtb	r3, r3
 8000820:	2b00      	cmp	r3, #0
 8000822:	d002      	beq.n	800082a <icuEnableNotifications+0x4a>
 8000824:	4805      	ldr	r0, [pc, #20]	; (800083c <icuEnableNotifications+0x5c>)
 8000826:	f001 fceb 	bl	8002200 <chSysHalt>
                "invalid state");
  icuEnableNotificationsI(icup);
 800082a:	9801      	ldr	r0, [sp, #4]
 800082c:	f001 f858 	bl	80018e0 <icu_lld_enable_notifications>
  osalSysUnlock();
 8000830:	f7ff feb6 	bl	80005a0 <osalSysUnlock>
}
 8000834:	bf00      	nop
 8000836:	b003      	add	sp, #12
 8000838:	f85d fb04 	ldr.w	pc, [sp], #4
 800083c:	080043fc 	.word	0x080043fc

08000840 <chSysLock>:
static inline void chSysLock(void) {
 8000840:	b500      	push	{lr}
 8000842:	b083      	sub	sp, #12
 8000844:	2330      	movs	r3, #48	; 0x30
 8000846:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8000848:	9b01      	ldr	r3, [sp, #4]
 800084a:	f383 8811 	msr	BASEPRI, r3
}
 800084e:	bf00      	nop
}
 8000850:	bf00      	nop
  __dbg_check_lock();
 8000852:	f001 fd25 	bl	80022a0 <__dbg_check_lock>
}
 8000856:	bf00      	nop
 8000858:	b003      	add	sp, #12
 800085a:	f85d fb04 	ldr.w	pc, [sp], #4
 800085e:	bf00      	nop

08000860 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8000860:	b500      	push	{lr}
 8000862:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8000864:	f001 fd44 	bl	80022f0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8000868:	4b12      	ldr	r3, [pc, #72]	; (80008b4 <chSysUnlock+0x54>)
 800086a:	681b      	ldr	r3, [r3, #0]
 800086c:	4a11      	ldr	r2, [pc, #68]	; (80008b4 <chSysUnlock+0x54>)
 800086e:	4293      	cmp	r3, r2
 8000870:	bf14      	ite	ne
 8000872:	2301      	movne	r3, #1
 8000874:	2300      	moveq	r3, #0
 8000876:	b2db      	uxtb	r3, r3
 8000878:	2b00      	cmp	r3, #0
 800087a:	d00f      	beq.n	800089c <chSysUnlock+0x3c>
 800087c:	4b0d      	ldr	r3, [pc, #52]	; (80008b4 <chSysUnlock+0x54>)
 800087e:	68db      	ldr	r3, [r3, #12]
 8000880:	689a      	ldr	r2, [r3, #8]
 8000882:	4b0c      	ldr	r3, [pc, #48]	; (80008b4 <chSysUnlock+0x54>)
 8000884:	681b      	ldr	r3, [r3, #0]
 8000886:	689b      	ldr	r3, [r3, #8]
 8000888:	429a      	cmp	r2, r3
 800088a:	bf34      	ite	cc
 800088c:	2301      	movcc	r3, #1
 800088e:	2300      	movcs	r3, #0
 8000890:	b2db      	uxtb	r3, r3
 8000892:	2b00      	cmp	r3, #0
 8000894:	d002      	beq.n	800089c <chSysUnlock+0x3c>
 8000896:	4808      	ldr	r0, [pc, #32]	; (80008b8 <chSysUnlock+0x58>)
 8000898:	f001 fcb2 	bl	8002200 <chSysHalt>
 800089c:	2300      	movs	r3, #0
 800089e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80008a0:	9b01      	ldr	r3, [sp, #4]
 80008a2:	f383 8811 	msr	BASEPRI, r3
}
 80008a6:	bf00      	nop
}
 80008a8:	bf00      	nop
}
 80008aa:	bf00      	nop
 80008ac:	b003      	add	sp, #12
 80008ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b2:	bf00      	nop
 80008b4:	200008a0 	.word	0x200008a0
 80008b8:	08004420 	.word	0x08004420
 80008bc:	00000000 	.word	0x00000000

080008c0 <osalSysLock>:
static inline void osalSysLock(void) {
 80008c0:	b508      	push	{r3, lr}
  chSysLock();
 80008c2:	f7ff ffbd 	bl	8000840 <chSysLock>
}
 80008c6:	bf00      	nop
 80008c8:	bd08      	pop	{r3, pc}
 80008ca:	bf00      	nop
 80008cc:	0000      	movs	r0, r0
	...

080008d0 <osalSysUnlock>:
static inline void osalSysUnlock(void) {
 80008d0:	b508      	push	{r3, lr}
  chSysUnlock();
 80008d2:	f7ff ffc5 	bl	8000860 <chSysUnlock>
}
 80008d6:	bf00      	nop
 80008d8:	bd08      	pop	{r3, pc}
 80008da:	bf00      	nop
 80008dc:	0000      	movs	r0, r0
	...

080008e0 <pwmInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void pwmInit(void) {
 80008e0:	b508      	push	{r3, lr}

  pwm_lld_init();
 80008e2:	f001 f8bd 	bl	8001a60 <pwm_lld_init>
}
 80008e6:	bf00      	nop
 80008e8:	bd08      	pop	{r3, pc}
 80008ea:	bf00      	nop
 80008ec:	0000      	movs	r0, r0
	...

080008f0 <pwmObjectInit>:
 *
 * @param[out] pwmp     pointer to a @p PWMDriver object
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {
 80008f0:	b082      	sub	sp, #8
 80008f2:	9001      	str	r0, [sp, #4]

  pwmp->state    = PWM_STOP;
 80008f4:	9b01      	ldr	r3, [sp, #4]
 80008f6:	2201      	movs	r2, #1
 80008f8:	701a      	strb	r2, [r3, #0]
  pwmp->config   = NULL;
 80008fa:	9b01      	ldr	r3, [sp, #4]
 80008fc:	2200      	movs	r2, #0
 80008fe:	605a      	str	r2, [r3, #4]
  pwmp->enabled  = 0;
 8000900:	9b01      	ldr	r3, [sp, #4]
 8000902:	2200      	movs	r2, #0
 8000904:	60da      	str	r2, [r3, #12]
  pwmp->channels = 0;
 8000906:	9b01      	ldr	r3, [sp, #4]
 8000908:	2200      	movs	r2, #0
 800090a:	741a      	strb	r2, [r3, #16]
#if defined(PWM_DRIVER_EXT_INIT_HOOK)
  PWM_DRIVER_EXT_INIT_HOOK(pwmp);
#endif
}
 800090c:	bf00      	nop
 800090e:	b002      	add	sp, #8
 8000910:	4770      	bx	lr
 8000912:	bf00      	nop
	...

08000920 <pwmStart>:
 * @param[in] config    pointer to a @p PWMConfig object
 * @return              The operation status.
 *
 * @api
 */
msg_t pwmStart(PWMDriver *pwmp, const PWMConfig *config) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
 8000926:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalDbgCheck((pwmp != NULL) && (config != NULL));
 8000928:	9b01      	ldr	r3, [sp, #4]
 800092a:	2b00      	cmp	r3, #0
 800092c:	bf0c      	ite	eq
 800092e:	2301      	moveq	r3, #1
 8000930:	2300      	movne	r3, #0
 8000932:	b2db      	uxtb	r3, r3
 8000934:	2b00      	cmp	r3, #0
 8000936:	d107      	bne.n	8000948 <pwmStart+0x28>
 8000938:	9b00      	ldr	r3, [sp, #0]
 800093a:	2b00      	cmp	r3, #0
 800093c:	bf0c      	ite	eq
 800093e:	2301      	moveq	r3, #1
 8000940:	2300      	movne	r3, #0
 8000942:	b2db      	uxtb	r3, r3
 8000944:	2b00      	cmp	r3, #0
 8000946:	d002      	beq.n	800094e <pwmStart+0x2e>
 8000948:	481c      	ldr	r0, [pc, #112]	; (80009bc <pwmStart+0x9c>)
 800094a:	f001 fc59 	bl	8002200 <chSysHalt>

  osalSysLock();
 800094e:	f7ff ffb7 	bl	80008c0 <osalSysLock>
  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 8000952:	9b01      	ldr	r3, [sp, #4]
 8000954:	781b      	ldrb	r3, [r3, #0]
 8000956:	2b01      	cmp	r3, #1
 8000958:	bf14      	ite	ne
 800095a:	2301      	movne	r3, #1
 800095c:	2300      	moveq	r3, #0
 800095e:	b2db      	uxtb	r3, r3
 8000960:	2b00      	cmp	r3, #0
 8000962:	d00b      	beq.n	800097c <pwmStart+0x5c>
 8000964:	9b01      	ldr	r3, [sp, #4]
 8000966:	781b      	ldrb	r3, [r3, #0]
 8000968:	2b02      	cmp	r3, #2
 800096a:	bf14      	ite	ne
 800096c:	2301      	movne	r3, #1
 800096e:	2300      	moveq	r3, #0
 8000970:	b2db      	uxtb	r3, r3
 8000972:	2b00      	cmp	r3, #0
 8000974:	d002      	beq.n	800097c <pwmStart+0x5c>
 8000976:	4811      	ldr	r0, [pc, #68]	; (80009bc <pwmStart+0x9c>)
 8000978:	f001 fc42 	bl	8002200 <chSysHalt>
                "invalid state");

  pwmp->config = config;
 800097c:	9b01      	ldr	r3, [sp, #4]
 800097e:	9a00      	ldr	r2, [sp, #0]
 8000980:	605a      	str	r2, [r3, #4]
  pwmp->period = config->period;
 8000982:	9b00      	ldr	r3, [sp, #0]
 8000984:	685a      	ldr	r2, [r3, #4]
 8000986:	9b01      	ldr	r3, [sp, #4]
 8000988:	609a      	str	r2, [r3, #8]
  pwmp->enabled = 0U;
 800098a:	9b01      	ldr	r3, [sp, #4]
 800098c:	2200      	movs	r2, #0
 800098e:	60da      	str	r2, [r3, #12]

#if defined(PWM_LLD_ENHANCED_API)
  msg = pwm_lld_start(pwmp);
#else
  pwm_lld_start(pwmp);
 8000990:	9801      	ldr	r0, [sp, #4]
 8000992:	f001 f87d 	bl	8001a90 <pwm_lld_start>
  msg = HAL_RET_SUCCESS;
 8000996:	2300      	movs	r3, #0
 8000998:	9303      	str	r3, [sp, #12]
#endif
  if (msg == HAL_RET_SUCCESS) {
 800099a:	9b03      	ldr	r3, [sp, #12]
 800099c:	2b00      	cmp	r3, #0
 800099e:	d103      	bne.n	80009a8 <pwmStart+0x88>
    pwmp->state = PWM_READY;
 80009a0:	9b01      	ldr	r3, [sp, #4]
 80009a2:	2202      	movs	r2, #2
 80009a4:	701a      	strb	r2, [r3, #0]
 80009a6:	e002      	b.n	80009ae <pwmStart+0x8e>
  }
  else {
    pwmp->state = PWM_STOP;
 80009a8:	9b01      	ldr	r3, [sp, #4]
 80009aa:	2201      	movs	r2, #1
 80009ac:	701a      	strb	r2, [r3, #0]
  }

  osalSysUnlock();
 80009ae:	f7ff ff8f 	bl	80008d0 <osalSysUnlock>

  return msg;
 80009b2:	9b03      	ldr	r3, [sp, #12]
}
 80009b4:	4618      	mov	r0, r3
 80009b6:	b005      	add	sp, #20
 80009b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80009bc:	08004414 	.word	0x08004414

080009c0 <pwmStop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmStop(PWMDriver *pwmp) {
 80009c0:	b500      	push	{lr}
 80009c2:	b083      	sub	sp, #12
 80009c4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(pwmp != NULL);
 80009c6:	9b01      	ldr	r3, [sp, #4]
 80009c8:	2b00      	cmp	r3, #0
 80009ca:	bf0c      	ite	eq
 80009cc:	2301      	moveq	r3, #1
 80009ce:	2300      	movne	r3, #0
 80009d0:	b2db      	uxtb	r3, r3
 80009d2:	2b00      	cmp	r3, #0
 80009d4:	d002      	beq.n	80009dc <pwmStop+0x1c>
 80009d6:	4816      	ldr	r0, [pc, #88]	; (8000a30 <pwmStop+0x70>)
 80009d8:	f001 fc12 	bl	8002200 <chSysHalt>

  osalSysLock();
 80009dc:	f7ff ff70 	bl	80008c0 <osalSysLock>

  osalDbgAssert((pwmp->state == PWM_STOP) || (pwmp->state == PWM_READY),
 80009e0:	9b01      	ldr	r3, [sp, #4]
 80009e2:	781b      	ldrb	r3, [r3, #0]
 80009e4:	2b01      	cmp	r3, #1
 80009e6:	bf14      	ite	ne
 80009e8:	2301      	movne	r3, #1
 80009ea:	2300      	moveq	r3, #0
 80009ec:	b2db      	uxtb	r3, r3
 80009ee:	2b00      	cmp	r3, #0
 80009f0:	d00b      	beq.n	8000a0a <pwmStop+0x4a>
 80009f2:	9b01      	ldr	r3, [sp, #4]
 80009f4:	781b      	ldrb	r3, [r3, #0]
 80009f6:	2b02      	cmp	r3, #2
 80009f8:	bf14      	ite	ne
 80009fa:	2301      	movne	r3, #1
 80009fc:	2300      	moveq	r3, #0
 80009fe:	b2db      	uxtb	r3, r3
 8000a00:	2b00      	cmp	r3, #0
 8000a02:	d002      	beq.n	8000a0a <pwmStop+0x4a>
 8000a04:	480a      	ldr	r0, [pc, #40]	; (8000a30 <pwmStop+0x70>)
 8000a06:	f001 fbfb 	bl	8002200 <chSysHalt>
                "invalid state");

  pwm_lld_stop(pwmp);
 8000a0a:	9801      	ldr	r0, [sp, #4]
 8000a0c:	f001 f988 	bl	8001d20 <pwm_lld_stop>
  pwmp->enabled = 0;
 8000a10:	9b01      	ldr	r3, [sp, #4]
 8000a12:	2200      	movs	r2, #0
 8000a14:	60da      	str	r2, [r3, #12]
  pwmp->config  = NULL;
 8000a16:	9b01      	ldr	r3, [sp, #4]
 8000a18:	2200      	movs	r2, #0
 8000a1a:	605a      	str	r2, [r3, #4]
  pwmp->state   = PWM_STOP;
 8000a1c:	9b01      	ldr	r3, [sp, #4]
 8000a1e:	2201      	movs	r2, #1
 8000a20:	701a      	strb	r2, [r3, #0]

  osalSysUnlock();
 8000a22:	f7ff ff55 	bl	80008d0 <osalSysUnlock>
}
 8000a26:	bf00      	nop
 8000a28:	b003      	add	sp, #12
 8000a2a:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a2e:	bf00      	nop
 8000a30:	0800442c 	.word	0x0800442c
	...

08000a40 <pwmChangePeriod>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] period    new cycle time in ticks
 *
 * @api
 */
void pwmChangePeriod(PWMDriver *pwmp, pwmcnt_t period) {
 8000a40:	b500      	push	{lr}
 8000a42:	b083      	sub	sp, #12
 8000a44:	9001      	str	r0, [sp, #4]
 8000a46:	9100      	str	r1, [sp, #0]

  osalDbgCheck(pwmp != NULL);
 8000a48:	9b01      	ldr	r3, [sp, #4]
 8000a4a:	2b00      	cmp	r3, #0
 8000a4c:	bf0c      	ite	eq
 8000a4e:	2301      	moveq	r3, #1
 8000a50:	2300      	movne	r3, #0
 8000a52:	b2db      	uxtb	r3, r3
 8000a54:	2b00      	cmp	r3, #0
 8000a56:	d002      	beq.n	8000a5e <pwmChangePeriod+0x1e>
 8000a58:	480f      	ldr	r0, [pc, #60]	; (8000a98 <pwmChangePeriod+0x58>)
 8000a5a:	f001 fbd1 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000a5e:	f7ff ff2f 	bl	80008c0 <osalSysLock>
  osalDbgAssert(pwmp->state == PWM_READY, "invalid state");
 8000a62:	9b01      	ldr	r3, [sp, #4]
 8000a64:	781b      	ldrb	r3, [r3, #0]
 8000a66:	2b02      	cmp	r3, #2
 8000a68:	bf14      	ite	ne
 8000a6a:	2301      	movne	r3, #1
 8000a6c:	2300      	moveq	r3, #0
 8000a6e:	b2db      	uxtb	r3, r3
 8000a70:	2b00      	cmp	r3, #0
 8000a72:	d002      	beq.n	8000a7a <pwmChangePeriod+0x3a>
 8000a74:	4808      	ldr	r0, [pc, #32]	; (8000a98 <pwmChangePeriod+0x58>)
 8000a76:	f001 fbc3 	bl	8002200 <chSysHalt>
  pwmChangePeriodI(pwmp, period);
 8000a7a:	9b01      	ldr	r3, [sp, #4]
 8000a7c:	9a00      	ldr	r2, [sp, #0]
 8000a7e:	609a      	str	r2, [r3, #8]
 8000a80:	9b01      	ldr	r3, [sp, #4]
 8000a82:	69db      	ldr	r3, [r3, #28]
 8000a84:	9a00      	ldr	r2, [sp, #0]
 8000a86:	3a01      	subs	r2, #1
 8000a88:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 8000a8a:	f7ff ff21 	bl	80008d0 <osalSysUnlock>
}
 8000a8e:	bf00      	nop
 8000a90:	b003      	add	sp, #12
 8000a92:	f85d fb04 	ldr.w	pc, [sp], #4
 8000a96:	bf00      	nop
 8000a98:	08004434 	.word	0x08004434
 8000a9c:	00000000 	.word	0x00000000

08000aa0 <pwmEnableChannel>:
 *
 * @api
 */
void pwmEnableChannel(PWMDriver *pwmp,
                      pwmchannel_t channel,
                      pwmcnt_t width) {
 8000aa0:	b500      	push	{lr}
 8000aa2:	b085      	sub	sp, #20
 8000aa4:	9003      	str	r0, [sp, #12]
 8000aa6:	460b      	mov	r3, r1
 8000aa8:	9201      	str	r2, [sp, #4]
 8000aaa:	f88d 300b 	strb.w	r3, [sp, #11]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000aae:	9b03      	ldr	r3, [sp, #12]
 8000ab0:	2b00      	cmp	r3, #0
 8000ab2:	bf0c      	ite	eq
 8000ab4:	2301      	moveq	r3, #1
 8000ab6:	2300      	movne	r3, #0
 8000ab8:	b2db      	uxtb	r3, r3
 8000aba:	2b00      	cmp	r3, #0
 8000abc:	d10a      	bne.n	8000ad4 <pwmEnableChannel+0x34>
 8000abe:	9b03      	ldr	r3, [sp, #12]
 8000ac0:	7c1b      	ldrb	r3, [r3, #16]
 8000ac2:	f89d 200b 	ldrb.w	r2, [sp, #11]
 8000ac6:	429a      	cmp	r2, r3
 8000ac8:	bf2c      	ite	cs
 8000aca:	2301      	movcs	r3, #1
 8000acc:	2300      	movcc	r3, #0
 8000ace:	b2db      	uxtb	r3, r3
 8000ad0:	2b00      	cmp	r3, #0
 8000ad2:	d002      	beq.n	8000ada <pwmEnableChannel+0x3a>
 8000ad4:	4813      	ldr	r0, [pc, #76]	; (8000b24 <pwmEnableChannel+0x84>)
 8000ad6:	f001 fb93 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000ada:	f7ff fef1 	bl	80008c0 <osalSysLock>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000ade:	9b03      	ldr	r3, [sp, #12]
 8000ae0:	781b      	ldrb	r3, [r3, #0]
 8000ae2:	2b02      	cmp	r3, #2
 8000ae4:	bf14      	ite	ne
 8000ae6:	2301      	movne	r3, #1
 8000ae8:	2300      	moveq	r3, #0
 8000aea:	b2db      	uxtb	r3, r3
 8000aec:	2b00      	cmp	r3, #0
 8000aee:	d002      	beq.n	8000af6 <pwmEnableChannel+0x56>
 8000af0:	480c      	ldr	r0, [pc, #48]	; (8000b24 <pwmEnableChannel+0x84>)
 8000af2:	f001 fb85 	bl	8002200 <chSysHalt>

  pwmEnableChannelI(pwmp, channel, width);
 8000af6:	9b03      	ldr	r3, [sp, #12]
 8000af8:	68da      	ldr	r2, [r3, #12]
 8000afa:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8000afe:	2101      	movs	r1, #1
 8000b00:	fa01 f303 	lsl.w	r3, r1, r3
 8000b04:	431a      	orrs	r2, r3
 8000b06:	9b03      	ldr	r3, [sp, #12]
 8000b08:	60da      	str	r2, [r3, #12]
 8000b0a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8000b0e:	9a01      	ldr	r2, [sp, #4]
 8000b10:	4619      	mov	r1, r3
 8000b12:	9803      	ldr	r0, [sp, #12]
 8000b14:	f001 f93c 	bl	8001d90 <pwm_lld_enable_channel>

  osalSysUnlock();
 8000b18:	f7ff feda 	bl	80008d0 <osalSysUnlock>
}
 8000b1c:	bf00      	nop
 8000b1e:	b005      	add	sp, #20
 8000b20:	f85d fb04 	ldr.w	pc, [sp], #4
 8000b24:	08004444 	.word	0x08004444
	...

08000b30 <pwmDisableChannel>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmDisableChannel(PWMDriver *pwmp, pwmchannel_t channel) {
 8000b30:	b500      	push	{lr}
 8000b32:	b083      	sub	sp, #12
 8000b34:	9001      	str	r0, [sp, #4]
 8000b36:	460b      	mov	r3, r1
 8000b38:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000b3c:	9b01      	ldr	r3, [sp, #4]
 8000b3e:	2b00      	cmp	r3, #0
 8000b40:	bf0c      	ite	eq
 8000b42:	2301      	moveq	r3, #1
 8000b44:	2300      	movne	r3, #0
 8000b46:	b2db      	uxtb	r3, r3
 8000b48:	2b00      	cmp	r3, #0
 8000b4a:	d10a      	bne.n	8000b62 <pwmDisableChannel+0x32>
 8000b4c:	9b01      	ldr	r3, [sp, #4]
 8000b4e:	7c1b      	ldrb	r3, [r3, #16]
 8000b50:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8000b54:	429a      	cmp	r2, r3
 8000b56:	bf2c      	ite	cs
 8000b58:	2301      	movcs	r3, #1
 8000b5a:	2300      	movcc	r3, #0
 8000b5c:	b2db      	uxtb	r3, r3
 8000b5e:	2b00      	cmp	r3, #0
 8000b60:	d002      	beq.n	8000b68 <pwmDisableChannel+0x38>
 8000b62:	4814      	ldr	r0, [pc, #80]	; (8000bb4 <pwmDisableChannel+0x84>)
 8000b64:	f001 fb4c 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000b68:	f7ff feaa 	bl	80008c0 <osalSysLock>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000b6c:	9b01      	ldr	r3, [sp, #4]
 8000b6e:	781b      	ldrb	r3, [r3, #0]
 8000b70:	2b02      	cmp	r3, #2
 8000b72:	bf14      	ite	ne
 8000b74:	2301      	movne	r3, #1
 8000b76:	2300      	moveq	r3, #0
 8000b78:	b2db      	uxtb	r3, r3
 8000b7a:	2b00      	cmp	r3, #0
 8000b7c:	d002      	beq.n	8000b84 <pwmDisableChannel+0x54>
 8000b7e:	480d      	ldr	r0, [pc, #52]	; (8000bb4 <pwmDisableChannel+0x84>)
 8000b80:	f001 fb3e 	bl	8002200 <chSysHalt>

  pwmDisableChannelI(pwmp, channel);
 8000b84:	9b01      	ldr	r3, [sp, #4]
 8000b86:	68da      	ldr	r2, [r3, #12]
 8000b88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000b8c:	2101      	movs	r1, #1
 8000b8e:	fa01 f303 	lsl.w	r3, r1, r3
 8000b92:	43db      	mvns	r3, r3
 8000b94:	401a      	ands	r2, r3
 8000b96:	9b01      	ldr	r3, [sp, #4]
 8000b98:	60da      	str	r2, [r3, #12]
 8000b9a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000b9e:	4619      	mov	r1, r3
 8000ba0:	9801      	ldr	r0, [sp, #4]
 8000ba2:	f001 f90d 	bl	8001dc0 <pwm_lld_disable_channel>

  osalSysUnlock();
 8000ba6:	f7ff fe93 	bl	80008d0 <osalSysUnlock>
}
 8000baa:	bf00      	nop
 8000bac:	b003      	add	sp, #12
 8000bae:	f85d fb04 	ldr.w	pc, [sp], #4
 8000bb2:	bf00      	nop
 8000bb4:	08004458 	.word	0x08004458
	...

08000bc0 <pwmEnablePeriodicNotification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @api
 */
void pwmEnablePeriodicNotification(PWMDriver *pwmp) {
 8000bc0:	b500      	push	{lr}
 8000bc2:	b083      	sub	sp, #12
 8000bc4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(pwmp != NULL);
 8000bc6:	9b01      	ldr	r3, [sp, #4]
 8000bc8:	2b00      	cmp	r3, #0
 8000bca:	bf0c      	ite	eq
 8000bcc:	2301      	moveq	r3, #1
 8000bce:	2300      	movne	r3, #0
 8000bd0:	b2db      	uxtb	r3, r3
 8000bd2:	2b00      	cmp	r3, #0
 8000bd4:	d002      	beq.n	8000bdc <pwmEnablePeriodicNotification+0x1c>
 8000bd6:	4813      	ldr	r0, [pc, #76]	; (8000c24 <pwmEnablePeriodicNotification+0x64>)
 8000bd8:	f001 fb12 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000bdc:	f7ff fe70 	bl	80008c0 <osalSysLock>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000be0:	9b01      	ldr	r3, [sp, #4]
 8000be2:	781b      	ldrb	r3, [r3, #0]
 8000be4:	2b02      	cmp	r3, #2
 8000be6:	bf14      	ite	ne
 8000be8:	2301      	movne	r3, #1
 8000bea:	2300      	moveq	r3, #0
 8000bec:	b2db      	uxtb	r3, r3
 8000bee:	2b00      	cmp	r3, #0
 8000bf0:	d002      	beq.n	8000bf8 <pwmEnablePeriodicNotification+0x38>
 8000bf2:	480c      	ldr	r0, [pc, #48]	; (8000c24 <pwmEnablePeriodicNotification+0x64>)
 8000bf4:	f001 fb04 	bl	8002200 <chSysHalt>
  osalDbgAssert(pwmp->config->callback != NULL, "undefined periodic callback");
 8000bf8:	9b01      	ldr	r3, [sp, #4]
 8000bfa:	685b      	ldr	r3, [r3, #4]
 8000bfc:	689b      	ldr	r3, [r3, #8]
 8000bfe:	2b00      	cmp	r3, #0
 8000c00:	bf0c      	ite	eq
 8000c02:	2301      	moveq	r3, #1
 8000c04:	2300      	movne	r3, #0
 8000c06:	b2db      	uxtb	r3, r3
 8000c08:	2b00      	cmp	r3, #0
 8000c0a:	d002      	beq.n	8000c12 <pwmEnablePeriodicNotification+0x52>
 8000c0c:	4805      	ldr	r0, [pc, #20]	; (8000c24 <pwmEnablePeriodicNotification+0x64>)
 8000c0e:	f001 faf7 	bl	8002200 <chSysHalt>

  pwmEnablePeriodicNotificationI(pwmp);
 8000c12:	9801      	ldr	r0, [sp, #4]
 8000c14:	f001 f8f4 	bl	8001e00 <pwm_lld_enable_periodic_notification>

  osalSysUnlock();
 8000c18:	f7ff fe5a 	bl	80008d0 <osalSysUnlock>
}
 8000c1c:	bf00      	nop
 8000c1e:	b003      	add	sp, #12
 8000c20:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c24:	0800446c 	.word	0x0800446c
	...

08000c30 <pwmEnableChannelNotification>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @api
 */
void pwmEnableChannelNotification(PWMDriver *pwmp, pwmchannel_t channel) {
 8000c30:	b500      	push	{lr}
 8000c32:	b083      	sub	sp, #12
 8000c34:	9001      	str	r0, [sp, #4]
 8000c36:	460b      	mov	r3, r1
 8000c38:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheck((pwmp != NULL) && (channel < pwmp->channels));
 8000c3c:	9b01      	ldr	r3, [sp, #4]
 8000c3e:	2b00      	cmp	r3, #0
 8000c40:	bf0c      	ite	eq
 8000c42:	2301      	moveq	r3, #1
 8000c44:	2300      	movne	r3, #0
 8000c46:	b2db      	uxtb	r3, r3
 8000c48:	2b00      	cmp	r3, #0
 8000c4a:	d10a      	bne.n	8000c62 <pwmEnableChannelNotification+0x32>
 8000c4c:	9b01      	ldr	r3, [sp, #4]
 8000c4e:	7c1b      	ldrb	r3, [r3, #16]
 8000c50:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8000c54:	429a      	cmp	r2, r3
 8000c56:	bf2c      	ite	cs
 8000c58:	2301      	movcs	r3, #1
 8000c5a:	2300      	movcc	r3, #0
 8000c5c:	b2db      	uxtb	r3, r3
 8000c5e:	2b00      	cmp	r3, #0
 8000c60:	d002      	beq.n	8000c68 <pwmEnableChannelNotification+0x38>
 8000c62:	4820      	ldr	r0, [pc, #128]	; (8000ce4 <pwmEnableChannelNotification+0xb4>)
 8000c64:	f001 facc 	bl	8002200 <chSysHalt>

  osalSysLock();
 8000c68:	f7ff fe2a 	bl	80008c0 <osalSysLock>

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");
 8000c6c:	9b01      	ldr	r3, [sp, #4]
 8000c6e:	781b      	ldrb	r3, [r3, #0]
 8000c70:	2b02      	cmp	r3, #2
 8000c72:	bf14      	ite	ne
 8000c74:	2301      	movne	r3, #1
 8000c76:	2300      	moveq	r3, #0
 8000c78:	b2db      	uxtb	r3, r3
 8000c7a:	2b00      	cmp	r3, #0
 8000c7c:	d002      	beq.n	8000c84 <pwmEnableChannelNotification+0x54>
 8000c7e:	4819      	ldr	r0, [pc, #100]	; (8000ce4 <pwmEnableChannelNotification+0xb4>)
 8000c80:	f001 fabe 	bl	8002200 <chSysHalt>
  osalDbgAssert((pwmp->enabled & ((pwmchnmsk_t)1U << (pwmchnmsk_t)channel)) != 0U,
 8000c84:	9b01      	ldr	r3, [sp, #4]
 8000c86:	68da      	ldr	r2, [r3, #12]
 8000c88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000c8c:	fa22 f303 	lsr.w	r3, r2, r3
 8000c90:	f003 0301 	and.w	r3, r3, #1
 8000c94:	2b00      	cmp	r3, #0
 8000c96:	bf0c      	ite	eq
 8000c98:	2301      	moveq	r3, #1
 8000c9a:	2300      	movne	r3, #0
 8000c9c:	b2db      	uxtb	r3, r3
 8000c9e:	2b00      	cmp	r3, #0
 8000ca0:	d002      	beq.n	8000ca8 <pwmEnableChannelNotification+0x78>
 8000ca2:	4810      	ldr	r0, [pc, #64]	; (8000ce4 <pwmEnableChannelNotification+0xb4>)
 8000ca4:	f001 faac 	bl	8002200 <chSysHalt>
                "channel not enabled");
  osalDbgAssert(pwmp->config->channels[channel].callback != NULL,
 8000ca8:	9b01      	ldr	r3, [sp, #4]
 8000caa:	685a      	ldr	r2, [r3, #4]
 8000cac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000cb0:	3301      	adds	r3, #1
 8000cb2:	00db      	lsls	r3, r3, #3
 8000cb4:	4413      	add	r3, r2
 8000cb6:	689b      	ldr	r3, [r3, #8]
 8000cb8:	2b00      	cmp	r3, #0
 8000cba:	bf0c      	ite	eq
 8000cbc:	2301      	moveq	r3, #1
 8000cbe:	2300      	movne	r3, #0
 8000cc0:	b2db      	uxtb	r3, r3
 8000cc2:	2b00      	cmp	r3, #0
 8000cc4:	d002      	beq.n	8000ccc <pwmEnableChannelNotification+0x9c>
 8000cc6:	4807      	ldr	r0, [pc, #28]	; (8000ce4 <pwmEnableChannelNotification+0xb4>)
 8000cc8:	f001 fa9a 	bl	8002200 <chSysHalt>
                "undefined channel callback");

  pwmEnableChannelNotificationI(pwmp, channel);
 8000ccc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8000cd0:	4619      	mov	r1, r3
 8000cd2:	9801      	ldr	r0, [sp, #4]
 8000cd4:	f001 f8b4 	bl	8001e40 <pwm_lld_enable_channel_notification>

  osalSysUnlock();
 8000cd8:	f7ff fdfa 	bl	80008d0 <osalSysUnlock>
}
 8000cdc:	bf00      	nop
 8000cde:	b003      	add	sp, #12
 8000ce0:	f85d fb04 	ldr.w	pc, [sp], #4
 8000ce4:	0800448c 	.word	0x0800448c
	...

08000cf0 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8000cf0:	b082      	sub	sp, #8
 8000cf2:	9001      	str	r0, [sp, #4]
 8000cf4:	9100      	str	r1, [sp, #0]
#if defined(__CORE_CM0_H_GENERIC) || defined(__CORE_CM0PLUS_H_GENERIC) ||   \
    defined(__CORE_CM23_H_GENERIC)
  NVIC->__IPR[_IP_IDX(n)] = (NVIC->__IPR[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                            (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->__IPR[n] = NVIC_PRIORITY_MASK(prio);
 8000cf6:	9b00      	ldr	r3, [sp, #0]
 8000cf8:	b2db      	uxtb	r3, r3
 8000cfa:	4a11      	ldr	r2, [pc, #68]	; (8000d40 <nvicEnableVector+0x50>)
 8000cfc:	011b      	lsls	r3, r3, #4
 8000cfe:	b2d9      	uxtb	r1, r3
 8000d00:	9b01      	ldr	r3, [sp, #4]
 8000d02:	4413      	add	r3, r2
 8000d04:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8000d08:	460a      	mov	r2, r1
 8000d0a:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->__ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000d0c:	9b01      	ldr	r3, [sp, #4]
 8000d0e:	f003 021f 	and.w	r2, r3, #31
 8000d12:	490b      	ldr	r1, [pc, #44]	; (8000d40 <nvicEnableVector+0x50>)
 8000d14:	9b01      	ldr	r3, [sp, #4]
 8000d16:	095b      	lsrs	r3, r3, #5
 8000d18:	2001      	movs	r0, #1
 8000d1a:	fa00 f202 	lsl.w	r2, r0, r2
 8000d1e:	3360      	adds	r3, #96	; 0x60
 8000d20:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
  NVIC->__ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000d24:	9b01      	ldr	r3, [sp, #4]
 8000d26:	f003 021f 	and.w	r2, r3, #31
 8000d2a:	4905      	ldr	r1, [pc, #20]	; (8000d40 <nvicEnableVector+0x50>)
 8000d2c:	9b01      	ldr	r3, [sp, #4]
 8000d2e:	095b      	lsrs	r3, r3, #5
 8000d30:	2001      	movs	r0, #1
 8000d32:	fa00 f202 	lsl.w	r2, r0, r2
 8000d36:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
#if defined(__ARM_FEATURE_CMSE) && (__ARM_FEATURE_CMSE == 3)
  /* If the IRQ is enabled from secure mode then it is marked as secure
     interrupt in ITNS.*/
  NVIC->__ITNS[n >> 5U] &= ~(1U << (n & 0x1FU));
#endif
}
 8000d3a:	bf00      	nop
 8000d3c:	b002      	add	sp, #8
 8000d3e:	4770      	bx	lr
 8000d40:	e000e100 	.word	0xe000e100
	...

08000d50 <exti0_irq_init>:

static inline void exti0_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI0_NUMBER, STM32_IRQ_EXTI0_PRIORITY);
#endif
}
 8000d50:	bf00      	nop
 8000d52:	4770      	bx	lr
	...

08000d60 <exti1_irq_init>:

static inline void exti1_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI1_NUMBER, STM32_IRQ_EXTI1_PRIORITY);
#endif
}
 8000d60:	bf00      	nop
 8000d62:	4770      	bx	lr
	...

08000d70 <exti2_irq_init>:

static inline void exti2_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI2_NUMBER, STM32_IRQ_EXTI2_PRIORITY);
#endif
}
 8000d70:	bf00      	nop
 8000d72:	4770      	bx	lr
	...

08000d80 <exti3_irq_init>:

static inline void exti3_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI3_NUMBER, STM32_IRQ_EXTI3_PRIORITY);
#endif
}
 8000d80:	bf00      	nop
 8000d82:	4770      	bx	lr
	...

08000d90 <exti4_irq_init>:

static inline void exti4_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI4_NUMBER, STM32_IRQ_EXTI4_PRIORITY);
#endif
}
 8000d90:	bf00      	nop
 8000d92:	4770      	bx	lr
	...

08000da0 <exti5_9_irq_init>:

static inline void exti5_9_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI5_9_NUMBER, STM32_IRQ_EXTI5_9_PRIORITY);
#endif
}
 8000da0:	bf00      	nop
 8000da2:	4770      	bx	lr
	...

08000db0 <exti10_15_irq_init>:

static inline void exti10_15_irq_init(void) {
#if (HAL_USE_PAL && (PAL_USE_WAIT || PAL_USE_CALLBACKS))
  nvicEnableVector(STM32_EXTI10_15_NUMBER, STM32_IRQ_EXTI10_15_PRIORITY);
#endif
}
 8000db0:	bf00      	nop
 8000db2:	4770      	bx	lr
	...

08000dc0 <exti16_irq_init>:

static inline void exti16_irq_init(void) {
#if defined(STM32_EXTI16_IS_USED)
  nvicEnableVector(STM32_EXTI16_NUMBER, STM32_IRQ_EXTI16_PRIORITY);
#endif
}
 8000dc0:	bf00      	nop
 8000dc2:	4770      	bx	lr
	...

08000dd0 <exti17_irq_init>:

static inline void exti17_irq_init(void) {
#if defined(STM32_EXTI17_IS_USED)
  nvicEnableVector(STM32_EXTI17_NUMBER, STM32_IRQ_EXTI17_PRIORITY);
#endif
}
 8000dd0:	bf00      	nop
 8000dd2:	4770      	bx	lr
	...

08000de0 <exti18_irq_init>:

static inline void exti18_irq_init(void) {
#if defined(STM32_EXTI18_IS_USED)
  nvicEnableVector(STM32_EXTI18_NUMBER, STM32_IRQ_EXTI18_PRIORITY);
#endif
}
 8000de0:	bf00      	nop
 8000de2:	4770      	bx	lr
	...

08000df0 <exti19_irq_init>:

static inline void exti19_irq_init(void) {
#if defined(STM32_EXTI19_IS_USED)
  nvicEnableVector(STM32_EXTI19_NUMBER, STM32_IRQ_EXTI19_PRIORITY);
#endif
}
 8000df0:	bf00      	nop
 8000df2:	4770      	bx	lr
	...

08000e00 <exti20_irq_init>:

static inline void exti20_irq_init(void) {
#if defined(STM32_EXTI20_IS_USED)
  nvicEnableVector(STM32_EXTI20_NUMBER, STM32_IRQ_EXTI20_PRIORITY);
#endif
}
 8000e00:	bf00      	nop
 8000e02:	4770      	bx	lr
	...

08000e10 <exti21_irq_init>:

static inline void exti21_irq_init(void) {
#if defined(STM32_EXTI21_IS_USED)
  nvicEnableVector(STM32_EXTI21_NUMBER, STM32_IRQ_EXTI21_PRIORITY);
#endif
}
 8000e10:	bf00      	nop
 8000e12:	4770      	bx	lr
	...

08000e20 <exti22_irq_init>:

static inline void exti22_irq_init(void) {
#if defined(STM32_EXTI22_IS_USED)
  nvicEnableVector(STM32_EXTI22_NUMBER, STM32_IRQ_EXTI22_PRIORITY);
#endif
}
 8000e20:	bf00      	nop
 8000e22:	4770      	bx	lr
	...

08000e30 <usart1_irq_init>:

static inline void usart1_irq_init(void) {
#if defined(STM32_USART1_IS_USED)
  nvicEnableVector(STM32_USART1_NUMBER, STM32_IRQ_USART1_PRIORITY);
#endif
}
 8000e30:	bf00      	nop
 8000e32:	4770      	bx	lr
	...

08000e40 <usart2_irq_init>:

static inline void usart2_irq_init(void) {
#if defined(STM32_USART2_IS_USED)
  nvicEnableVector(STM32_USART2_NUMBER, STM32_IRQ_USART2_PRIORITY);
#endif
}
 8000e40:	bf00      	nop
 8000e42:	4770      	bx	lr
	...

08000e50 <usart3_irq_init>:

static inline void usart3_irq_init(void) {
#if defined(STM32_USART3_IS_USED)
  nvicEnableVector(STM32_USART3_NUMBER, STM32_IRQ_USART3_PRIORITY);
#endif
}
 8000e50:	bf00      	nop
 8000e52:	4770      	bx	lr
	...

08000e60 <uart4_irq_init>:

static inline void uart4_irq_init(void) {
#if defined(STM32_UART4_IS_USED)
  nvicEnableVector(STM32_UART4_NUMBER, STM32_IRQ_UART4_PRIORITY);
#endif
}
 8000e60:	bf00      	nop
 8000e62:	4770      	bx	lr
	...

08000e70 <uart5_irq_init>:

static inline void uart5_irq_init(void) {
#if defined(STM32_UART5_IS_USED)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_IRQ_UART5_PRIORITY);
#endif
}
 8000e70:	bf00      	nop
 8000e72:	4770      	bx	lr
	...

08000e80 <usart6_irq_init>:

static inline void usart6_irq_init(void) {
#if defined(STM32_USART6_IS_USED)
  nvicEnableVector(STM32_USART6_NUMBER, STM32_IRQ_USART6_PRIORITY);
#endif
}
 8000e80:	bf00      	nop
 8000e82:	4770      	bx	lr
	...

08000e90 <uart7_irq_init>:

static inline void uart7_irq_init(void) {
#if defined(STM32_UART7_IS_USED)
  nvicEnableVector(STM32_UART7_NUMBER, STM32_IRQ_UART7_PRIORITY);
#endif
}
 8000e90:	bf00      	nop
 8000e92:	4770      	bx	lr
	...

08000ea0 <uart8_irq_init>:

static inline void uart8_irq_init(void) {
#if defined(STM32_UART8_IS_USED)
  nvicEnableVector(STM32_UART8_NUMBER, STM32_IRQ_UART8_PRIORITY);
#endif
}
 8000ea0:	bf00      	nop
 8000ea2:	4770      	bx	lr
	...

08000eb0 <uart9_irq_init>:

static inline void uart9_irq_init(void) {
#if defined(STM32_UART9_IS_USED)
  nvicEnableVector(STM32_UART9_NUMBER, STM32_IRQ_UART9_PRIORITY);
#endif
}
 8000eb0:	bf00      	nop
 8000eb2:	4770      	bx	lr
	...

08000ec0 <uart10_irq_init>:

static inline void uart10_irq_init(void) {
#if defined(STM32_UART10_IS_USED)
  nvicEnableVector(STM32_UART10_NUMBER, STM32_IRQ_UART10_PRIORITY);
#endif
}
 8000ec0:	bf00      	nop
 8000ec2:	4770      	bx	lr
	...

08000ed0 <tim1_tim9_tim10_tim11_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim1_tim9_tim10_tim11_irq_init(void) {
 8000ed0:	b508      	push	{r3, lr}
#if defined(STM32_TIM1_IS_USED) || defined(STM32_TIM9_IS_USED)
  nvicEnableVector(STM32_TIM1_BRK_TIM9_NUMBER,
 8000ed2:	2107      	movs	r1, #7
 8000ed4:	2018      	movs	r0, #24
 8000ed6:	f7ff ff0b 	bl	8000cf0 <nvicEnableVector>
                   STM32_IRQ_TIM1_BRK_TIM9_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED) || defined(STM32_TIM10_IS_USED)
  nvicEnableVector(STM32_TIM1_UP_TIM10_NUMBER,
 8000eda:	2107      	movs	r1, #7
 8000edc:	2019      	movs	r0, #25
 8000ede:	f7ff ff07 	bl	8000cf0 <nvicEnableVector>
                   STM32_IRQ_TIM1_UP_TIM10_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED) || defined(STM32_TIM11_IS_USED)
  nvicEnableVector(STM32_TIM1_TRGCO_TIM11_NUMBER,
 8000ee2:	2107      	movs	r1, #7
 8000ee4:	201a      	movs	r0, #26
 8000ee6:	f7ff ff03 	bl	8000cf0 <nvicEnableVector>
                   STM32_IRQ_TIM1_TRGCO_TIM11_PRIORITY);
#endif
#if defined(STM32_TIM1_IS_USED)
  nvicEnableVector(STM32_TIM1_CC_NUMBER,
 8000eea:	2107      	movs	r1, #7
 8000eec:	201b      	movs	r0, #27
 8000eee:	f7ff feff 	bl	8000cf0 <nvicEnableVector>
                   STM32_IRQ_TIM1_CC_PRIORITY);
#endif
}
 8000ef2:	bf00      	nop
 8000ef4:	bd08      	pop	{r3, pc}
 8000ef6:	bf00      	nop
	...

08000f00 <VectorA0>:
/**
 * @brief   TIM1-BRK, TIM9 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_BRK_TIM9_HANDLER) {
 8000f00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f02:	4807      	ldr	r0, [pc, #28]	; (8000f20 <VectorA0+0x20>)
 8000f04:	f001 fc04 	bl	8002710 <__trace_isr_enter>
 8000f08:	f001 fa6a 	bl	80023e0 <__dbg_check_enter_isr>
#if STM32_ST_USE_TIM9
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000f0c:	f001 faa0 	bl	8002450 <__dbg_check_leave_isr>
 8000f10:	4803      	ldr	r0, [pc, #12]	; (8000f20 <VectorA0+0x20>)
 8000f12:	f001 fc3d 	bl	8002790 <__trace_isr_leave>
 8000f16:	f003 f89b 	bl	8004050 <__port_irq_epilogue>
}
 8000f1a:	bf00      	nop
 8000f1c:	bd08      	pop	{r3, pc}
 8000f1e:	bf00      	nop
 8000f20:	080044ac 	.word	0x080044ac
	...

08000f30 <VectorA4>:
/**
 * @brief   TIM1-UP, TIM10 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_UP_TIM10_HANDLER) {
 8000f30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f32:	4808      	ldr	r0, [pc, #32]	; (8000f54 <VectorA4+0x24>)
 8000f34:	f001 fbec 	bl	8002710 <__trace_isr_enter>
 8000f38:	f001 fa52 	bl	80023e0 <__dbg_check_enter_isr>
  gpt_lld_serve_interrupt(&GPTD10);
#endif
#endif
#if HAL_USE_ICU
#if STM32_ICU_USE_TIM1
  icu_lld_serve_interrupt(&ICUD1);
 8000f3c:	4806      	ldr	r0, [pc, #24]	; (8000f58 <VectorA4+0x28>)
 8000f3e:	f000 fd0f 	bl	8001960 <icu_lld_serve_interrupt>
#if STM32_ST_USE_TIM10
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000f42:	f001 fa85 	bl	8002450 <__dbg_check_leave_isr>
 8000f46:	4803      	ldr	r0, [pc, #12]	; (8000f54 <VectorA4+0x24>)
 8000f48:	f001 fc22 	bl	8002790 <__trace_isr_leave>
 8000f4c:	f003 f880 	bl	8004050 <__port_irq_epilogue>
}
 8000f50:	bf00      	nop
 8000f52:	bd08      	pop	{r3, pc}
 8000f54:	080044b8 	.word	0x080044b8
 8000f58:	20000858 	.word	0x20000858
 8000f5c:	00000000 	.word	0x00000000

08000f60 <VectorA8>:
/**
 * @brief   TIM1-TRG-COM, TIM11 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_TRGCO_TIM11_HANDLER) {
 8000f60:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f62:	4807      	ldr	r0, [pc, #28]	; (8000f80 <VectorA8+0x20>)
 8000f64:	f001 fbd4 	bl	8002710 <__trace_isr_enter>
 8000f68:	f001 fa3a 	bl	80023e0 <__dbg_check_enter_isr>
#if STM32_ST_USE_TIM11
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000f6c:	f001 fa70 	bl	8002450 <__dbg_check_leave_isr>
 8000f70:	4803      	ldr	r0, [pc, #12]	; (8000f80 <VectorA8+0x20>)
 8000f72:	f001 fc0d 	bl	8002790 <__trace_isr_leave>
 8000f76:	f003 f86b 	bl	8004050 <__port_irq_epilogue>
}
 8000f7a:	bf00      	nop
 8000f7c:	bd08      	pop	{r3, pc}
 8000f7e:	bf00      	nop
 8000f80:	080044c4 	.word	0x080044c4
	...

08000f90 <VectorAC>:
/**
 * @brief   TIM1-CC interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM1_CC_HANDLER) {
 8000f90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000f92:	4808      	ldr	r0, [pc, #32]	; (8000fb4 <VectorAC+0x24>)
 8000f94:	f001 fbbc 	bl	8002710 <__trace_isr_enter>
 8000f98:	f001 fa22 	bl	80023e0 <__dbg_check_enter_isr>
#if HAL_USE_GPT
  /* Not used by GPT.*/
#endif
#if HAL_USE_ICU
#if STM32_ICU_USE_TIM1
  icu_lld_serve_interrupt(&ICUD1);
 8000f9c:	4806      	ldr	r0, [pc, #24]	; (8000fb8 <VectorAC+0x28>)
 8000f9e:	f000 fcdf 	bl	8001960 <icu_lld_serve_interrupt>
#if STM32_PWM_USE_TIM1
  pwm_lld_serve_interrupt(&PWMD1);
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000fa2:	f001 fa55 	bl	8002450 <__dbg_check_leave_isr>
 8000fa6:	4803      	ldr	r0, [pc, #12]	; (8000fb4 <VectorAC+0x24>)
 8000fa8:	f001 fbf2 	bl	8002790 <__trace_isr_leave>
 8000fac:	f003 f850 	bl	8004050 <__port_irq_epilogue>
}
 8000fb0:	bf00      	nop
 8000fb2:	bd08      	pop	{r3, pc}
 8000fb4:	080044d0 	.word	0x080044d0
 8000fb8:	20000858 	.word	0x20000858
 8000fbc:	00000000 	.word	0x00000000

08000fc0 <tim2_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim2_irq_init(void) {
 8000fc0:	b508      	push	{r3, lr}
#if defined(STM32_TIM2_IS_USED)
  nvicEnableVector(STM32_TIM2_NUMBER, STM32_IRQ_TIM2_PRIORITY);
 8000fc2:	2107      	movs	r1, #7
 8000fc4:	201c      	movs	r0, #28
 8000fc6:	f7ff fe93 	bl	8000cf0 <nvicEnableVector>
#endif
}
 8000fca:	bf00      	nop
 8000fcc:	bd08      	pop	{r3, pc}
 8000fce:	bf00      	nop

08000fd0 <VectorB0>:
/**
 * @brief   TIM2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM2_HANDLER) {
 8000fd0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8000fd2:	4808      	ldr	r0, [pc, #32]	; (8000ff4 <VectorB0+0x24>)
 8000fd4:	f001 fb9c 	bl	8002710 <__trace_isr_enter>
 8000fd8:	f001 fa02 	bl	80023e0 <__dbg_check_enter_isr>
  pwm_lld_serve_interrupt(&PWMD2);
#endif
#endif
#if 1
#if STM32_ST_USE_TIM2
  st_lld_serve_interrupt();
 8000fdc:	f000 faf0 	bl	80015c0 <st_lld_serve_interrupt>
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8000fe0:	f001 fa36 	bl	8002450 <__dbg_check_leave_isr>
 8000fe4:	4803      	ldr	r0, [pc, #12]	; (8000ff4 <VectorB0+0x24>)
 8000fe6:	f001 fbd3 	bl	8002790 <__trace_isr_leave>
 8000fea:	f003 f831 	bl	8004050 <__port_irq_epilogue>
}
 8000fee:	bf00      	nop
 8000ff0:	bd08      	pop	{r3, pc}
 8000ff2:	bf00      	nop
 8000ff4:	080044dc 	.word	0x080044dc
	...

08001000 <tim3_irq_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static inline void tim3_irq_init(void) {
 8001000:	b508      	push	{r3, lr}
#if defined(STM32_TIM3_IS_USED)
  nvicEnableVector(STM32_TIM3_NUMBER, STM32_IRQ_TIM3_PRIORITY);
 8001002:	2107      	movs	r1, #7
 8001004:	201d      	movs	r0, #29
 8001006:	f7ff fe73 	bl	8000cf0 <nvicEnableVector>
#endif
}
 800100a:	bf00      	nop
 800100c:	bd08      	pop	{r3, pc}
 800100e:	bf00      	nop

08001010 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001010:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();
 8001012:	4808      	ldr	r0, [pc, #32]	; (8001034 <VectorB4+0x24>)
 8001014:	f001 fb7c 	bl	8002710 <__trace_isr_enter>
 8001018:	f001 f9e2 	bl	80023e0 <__dbg_check_enter_isr>
  icu_lld_serve_interrupt(&ICUD3);
#endif
#endif
#if HAL_USE_PWM
#if STM32_PWM_USE_TIM3
  pwm_lld_serve_interrupt(&PWMD3);
 800101c:	4806      	ldr	r0, [pc, #24]	; (8001038 <VectorB4+0x28>)
 800101e:	f000 ff3f 	bl	8001ea0 <pwm_lld_serve_interrupt>
#if STM32_ST_USE_TIM3
  st_lld_serve_interrupt();
#endif
#endif

  OSAL_IRQ_EPILOGUE();
 8001022:	f001 fa15 	bl	8002450 <__dbg_check_leave_isr>
 8001026:	4803      	ldr	r0, [pc, #12]	; (8001034 <VectorB4+0x24>)
 8001028:	f001 fbb2 	bl	8002790 <__trace_isr_leave>
 800102c:	f003 f810 	bl	8004050 <__port_irq_epilogue>
}
 8001030:	bf00      	nop
 8001032:	bd08      	pop	{r3, pc}
 8001034:	080044e8 	.word	0x080044e8
 8001038:	20000870 	.word	0x20000870
 800103c:	00000000 	.word	0x00000000

08001040 <tim4_irq_init>:

static inline void tim4_irq_init(void) {
#if defined(STM32_TIM4_IS_USED)
  nvicEnableVector(STM32_TIM4_NUMBER, STM32_IRQ_TIM4_PRIORITY);
#endif
}
 8001040:	bf00      	nop
 8001042:	4770      	bx	lr
	...

08001050 <tim5_irq_init>:

static inline void tim5_irq_init(void) {
#if defined(STM32_TIM5_IS_USED)
  nvicEnableVector(STM32_TIM5_NUMBER, STM32_IRQ_TIM5_PRIORITY);
#endif
}
 8001050:	bf00      	nop
 8001052:	4770      	bx	lr
	...

08001060 <tim6_irq_init>:

static inline void tim6_irq_init(void) {
#if defined(STM32_TIM6_IS_USED)
  nvicEnableVector(STM32_TIM6_NUMBER, STM32_IRQ_TIM6_PRIORITY);
#endif
}
 8001060:	bf00      	nop
 8001062:	4770      	bx	lr
	...

08001070 <tim7_irq_init>:

static inline void tim7_irq_init(void) {
#if defined(STM32_TIM7_IS_USED)
  nvicEnableVector(STM32_TIM7_NUMBER, STM32_IRQ_TIM7_PRIORITY);
#endif
}
 8001070:	bf00      	nop
 8001072:	4770      	bx	lr
	...

08001080 <tim8_tim12_tim13_tim14_irq_init>:
#endif
#if defined(STM32_TIM8_IS_USED)
  nvicEnableVector(STM32_TIM8_CC_NUMBER,
                   STM32_IRQ_TIM8_CC_PRIORITY);
#endif
}
 8001080:	bf00      	nop
 8001082:	4770      	bx	lr
	...

08001090 <irqInit>:
/**
 * @brief   Enables IRQ sources.
 *
 * @notapi
 */
void irqInit(void) {
 8001090:	b508      	push	{r3, lr}

  exti0_irq_init();
 8001092:	f7ff fe5d 	bl	8000d50 <exti0_irq_init>
  exti1_irq_init();
 8001096:	f7ff fe63 	bl	8000d60 <exti1_irq_init>
  exti2_irq_init();
 800109a:	f7ff fe69 	bl	8000d70 <exti2_irq_init>
  exti3_irq_init();
 800109e:	f7ff fe6f 	bl	8000d80 <exti3_irq_init>
  exti4_irq_init();
 80010a2:	f7ff fe75 	bl	8000d90 <exti4_irq_init>
  exti5_9_irq_init();
 80010a6:	f7ff fe7b 	bl	8000da0 <exti5_9_irq_init>
  exti10_15_irq_init();
 80010aa:	f7ff fe81 	bl	8000db0 <exti10_15_irq_init>
  exti16_irq_init();
 80010ae:	f7ff fe87 	bl	8000dc0 <exti16_irq_init>
  exti17_irq_init();
 80010b2:	f7ff fe8d 	bl	8000dd0 <exti17_irq_init>
  exti18_irq_init();
 80010b6:	f7ff fe93 	bl	8000de0 <exti18_irq_init>
  exti19_irq_init();
 80010ba:	f7ff fe99 	bl	8000df0 <exti19_irq_init>
  exti20_irq_init();
 80010be:	f7ff fe9f 	bl	8000e00 <exti20_irq_init>
  exti21_irq_init();
 80010c2:	f7ff fea5 	bl	8000e10 <exti21_irq_init>
  exti22_irq_init();
 80010c6:	f7ff feab 	bl	8000e20 <exti22_irq_init>

  tim1_tim9_tim10_tim11_irq_init();
 80010ca:	f7ff ff01 	bl	8000ed0 <tim1_tim9_tim10_tim11_irq_init>
  tim2_irq_init();
 80010ce:	f7ff ff77 	bl	8000fc0 <tim2_irq_init>
  tim3_irq_init();
 80010d2:	f7ff ff95 	bl	8001000 <tim3_irq_init>
  tim4_irq_init();
 80010d6:	f7ff ffb3 	bl	8001040 <tim4_irq_init>
  tim5_irq_init();
 80010da:	f7ff ffb9 	bl	8001050 <tim5_irq_init>
  tim6_irq_init();
 80010de:	f7ff ffbf 	bl	8001060 <tim6_irq_init>
  tim7_irq_init();
 80010e2:	f7ff ffc5 	bl	8001070 <tim7_irq_init>
  tim8_tim12_tim13_tim14_irq_init();
 80010e6:	f7ff ffcb 	bl	8001080 <tim8_tim12_tim13_tim14_irq_init>

  usart1_irq_init();
 80010ea:	f7ff fea1 	bl	8000e30 <usart1_irq_init>
  usart2_irq_init();
 80010ee:	f7ff fea7 	bl	8000e40 <usart2_irq_init>
  usart3_irq_init();
 80010f2:	f7ff fead 	bl	8000e50 <usart3_irq_init>
  uart4_irq_init();
 80010f6:	f7ff feb3 	bl	8000e60 <uart4_irq_init>
  uart5_irq_init();
 80010fa:	f7ff feb9 	bl	8000e70 <uart5_irq_init>
  usart6_irq_init();
 80010fe:	f7ff febf 	bl	8000e80 <usart6_irq_init>
  uart7_irq_init();
 8001102:	f7ff fec5 	bl	8000e90 <uart7_irq_init>
  uart8_irq_init();
 8001106:	f7ff fecb 	bl	8000ea0 <uart8_irq_init>
  uart9_irq_init();
 800110a:	f7ff fed1 	bl	8000eb0 <uart9_irq_init>
  uart10_irq_init();
 800110e:	f7ff fed7 	bl	8000ec0 <uart10_irq_init>
}
 8001112:	bf00      	nop
 8001114:	bd08      	pop	{r3, pc}
 8001116:	bf00      	nop
	...

08001120 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8001120:	4b0d      	ldr	r3, [pc, #52]	; (8001158 <hal_lld_backup_domain_init+0x38>)
 8001122:	681b      	ldr	r3, [r3, #0]
 8001124:	4a0c      	ldr	r2, [pc, #48]	; (8001158 <hal_lld_backup_domain_init+0x38>)
 8001126:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800112a:	6013      	str	r3, [r2, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 800112c:	4b0b      	ldr	r3, [pc, #44]	; (800115c <hal_lld_backup_domain_init+0x3c>)
 800112e:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8001130:	f403 7340 	and.w	r3, r3, #768	; 0x300
 8001134:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 8001138:	d006      	beq.n	8001148 <hal_lld_backup_domain_init+0x28>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800113a:	4b08      	ldr	r3, [pc, #32]	; (800115c <hal_lld_backup_domain_init+0x3c>)
 800113c:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8001140:	671a      	str	r2, [r3, #112]	; 0x70
    RCC->BDCR = 0;
 8001142:	4b06      	ldr	r3, [pc, #24]	; (800115c <hal_lld_backup_domain_init+0x3c>)
 8001144:	2200      	movs	r2, #0
 8001146:	671a      	str	r2, [r3, #112]	; 0x70

  PWR->CSR |= PWR_CSR_BRE;
  while ((PWR->CSR & PWR_CSR_BRR) == 0)
    ;                                /* Waits until the regulator is stable */
#else
  PWR->CSR &= ~PWR_CSR_BRE;
 8001148:	4b03      	ldr	r3, [pc, #12]	; (8001158 <hal_lld_backup_domain_init+0x38>)
 800114a:	685b      	ldr	r3, [r3, #4]
 800114c:	4a02      	ldr	r2, [pc, #8]	; (8001158 <hal_lld_backup_domain_init+0x38>)
 800114e:	f423 7300 	bic.w	r3, r3, #512	; 0x200
 8001152:	6053      	str	r3, [r2, #4]
#endif /* STM32_BKPRAM_ENABLE */
}
 8001154:	bf00      	nop
 8001156:	4770      	bx	lr
 8001158:	40007000 	.word	0x40007000
 800115c:	40023800 	.word	0x40023800

08001160 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 8001160:	b508      	push	{r3, lr}

  /* Reset of all peripherals. AHB3 is not reseted because it could have
     been initialized in the board initialization file (board.c).
     Note, GPIOs are not reset because initialized before this point in
     board files.*/
  rccResetAHB1(~STM32_GPIO_EN_MASK);
 8001162:	4b26      	ldr	r3, [pc, #152]	; (80011fc <hal_lld_init+0x9c>)
 8001164:	691b      	ldr	r3, [r3, #16]
 8001166:	4a25      	ldr	r2, [pc, #148]	; (80011fc <hal_lld_init+0x9c>)
 8001168:	ea6f 53c3 	mvn.w	r3, r3, lsl #23
 800116c:	ea6f 53d3 	mvn.w	r3, r3, lsr #23
 8001170:	6113      	str	r3, [r2, #16]
 8001172:	4b22      	ldr	r3, [pc, #136]	; (80011fc <hal_lld_init+0x9c>)
 8001174:	691b      	ldr	r3, [r3, #16]
 8001176:	4a21      	ldr	r2, [pc, #132]	; (80011fc <hal_lld_init+0x9c>)
 8001178:	f3c3 0308 	ubfx	r3, r3, #0, #9
 800117c:	6113      	str	r3, [r2, #16]
 800117e:	4b1f      	ldr	r3, [pc, #124]	; (80011fc <hal_lld_init+0x9c>)
 8001180:	691b      	ldr	r3, [r3, #16]
#if !defined(STM32F410xx)
  rccResetAHB2(~0);
 8001182:	4b1e      	ldr	r3, [pc, #120]	; (80011fc <hal_lld_init+0x9c>)
 8001184:	695b      	ldr	r3, [r3, #20]
 8001186:	4b1d      	ldr	r3, [pc, #116]	; (80011fc <hal_lld_init+0x9c>)
 8001188:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800118c:	615a      	str	r2, [r3, #20]
 800118e:	4b1b      	ldr	r3, [pc, #108]	; (80011fc <hal_lld_init+0x9c>)
 8001190:	695b      	ldr	r3, [r3, #20]
 8001192:	4b1a      	ldr	r3, [pc, #104]	; (80011fc <hal_lld_init+0x9c>)
 8001194:	2200      	movs	r2, #0
 8001196:	615a      	str	r2, [r3, #20]
 8001198:	4b18      	ldr	r3, [pc, #96]	; (80011fc <hal_lld_init+0x9c>)
 800119a:	695b      	ldr	r3, [r3, #20]
#endif
  rccResetAPB1(~RCC_APB1RSTR_PWRRST);
 800119c:	4b17      	ldr	r3, [pc, #92]	; (80011fc <hal_lld_init+0x9c>)
 800119e:	6a1b      	ldr	r3, [r3, #32]
 80011a0:	4a16      	ldr	r2, [pc, #88]	; (80011fc <hal_lld_init+0x9c>)
 80011a2:	f063 5380 	orn	r3, r3, #268435456	; 0x10000000
 80011a6:	6213      	str	r3, [r2, #32]
 80011a8:	4b14      	ldr	r3, [pc, #80]	; (80011fc <hal_lld_init+0x9c>)
 80011aa:	6a1b      	ldr	r3, [r3, #32]
 80011ac:	4a13      	ldr	r2, [pc, #76]	; (80011fc <hal_lld_init+0x9c>)
 80011ae:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80011b2:	6213      	str	r3, [r2, #32]
 80011b4:	4b11      	ldr	r3, [pc, #68]	; (80011fc <hal_lld_init+0x9c>)
 80011b6:	6a1b      	ldr	r3, [r3, #32]
  rccResetAPB2(~0);
 80011b8:	4b10      	ldr	r3, [pc, #64]	; (80011fc <hal_lld_init+0x9c>)
 80011ba:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80011bc:	4b0f      	ldr	r3, [pc, #60]	; (80011fc <hal_lld_init+0x9c>)
 80011be:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80011c2:	625a      	str	r2, [r3, #36]	; 0x24
 80011c4:	4b0d      	ldr	r3, [pc, #52]	; (80011fc <hal_lld_init+0x9c>)
 80011c6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80011c8:	4b0c      	ldr	r3, [pc, #48]	; (80011fc <hal_lld_init+0x9c>)
 80011ca:	2200      	movs	r2, #0
 80011cc:	625a      	str	r2, [r3, #36]	; 0x24
 80011ce:	4b0b      	ldr	r3, [pc, #44]	; (80011fc <hal_lld_init+0x9c>)
 80011d0:	6a5b      	ldr	r3, [r3, #36]	; 0x24

  /* PWR clock enabled.*/
  rccEnablePWRInterface(true);
 80011d2:	4b0a      	ldr	r3, [pc, #40]	; (80011fc <hal_lld_init+0x9c>)
 80011d4:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80011d6:	4a09      	ldr	r2, [pc, #36]	; (80011fc <hal_lld_init+0x9c>)
 80011d8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80011dc:	6413      	str	r3, [r2, #64]	; 0x40
 80011de:	4b07      	ldr	r3, [pc, #28]	; (80011fc <hal_lld_init+0x9c>)
 80011e0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80011e2:	4a06      	ldr	r2, [pc, #24]	; (80011fc <hal_lld_init+0x9c>)
 80011e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80011e8:	6613      	str	r3, [r2, #96]	; 0x60
 80011ea:	4b04      	ldr	r3, [pc, #16]	; (80011fc <hal_lld_init+0x9c>)
 80011ec:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 80011ee:	f7ff ff97 	bl	8001120 <hal_lld_backup_domain_init>
#if defined(STM32_DMA_REQUIRED)
  dmaInit();
#endif

  /* IRQ subsystem initialization.*/
  irqInit();
 80011f2:	f7ff ff4d 	bl	8001090 <irqInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */
}
 80011f6:	bf00      	nop
 80011f8:	bd08      	pop	{r3, pc}
 80011fa:	bf00      	nop
 80011fc:	40023800 	.word	0x40023800

08001200 <stm32_clock_init>:
#if !STM32_NO_INIT
  /* PWR clock enable.*/
#if defined(HAL_USE_RTC) && defined(RCC_APB1ENR_RTCAPBEN)
  RCC->APB1ENR = RCC_APB1ENR_PWREN | RCC_APB1ENR_RTCAPBEN;
#else
  RCC->APB1ENR = RCC_APB1ENR_PWREN;
 8001200:	4b4a      	ldr	r3, [pc, #296]	; (800132c <stm32_clock_init+0x12c>)
 8001202:	f04f 5280 	mov.w	r2, #268435456	; 0x10000000
 8001206:	641a      	str	r2, [r3, #64]	; 0x40
#endif

  /* PWR initialization.*/
#if defined(STM32F4XX) || defined(__DOXYGEN__)
  PWR->CR = STM32_VOS;
 8001208:	4b49      	ldr	r3, [pc, #292]	; (8001330 <stm32_clock_init+0x130>)
 800120a:	f44f 4240 	mov.w	r2, #49152	; 0xc000
 800120e:	601a      	str	r2, [r3, #0]
  PWR->CR = 0;
#endif

  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001210:	4b46      	ldr	r3, [pc, #280]	; (800132c <stm32_clock_init+0x12c>)
 8001212:	681b      	ldr	r3, [r3, #0]
 8001214:	4a45      	ldr	r2, [pc, #276]	; (800132c <stm32_clock_init+0x12c>)
 8001216:	f043 0301 	orr.w	r3, r3, #1
 800121a:	6013      	str	r3, [r2, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800121c:	bf00      	nop
 800121e:	4b43      	ldr	r3, [pc, #268]	; (800132c <stm32_clock_init+0x12c>)
 8001220:	681b      	ldr	r3, [r3, #0]
 8001222:	f003 0302 	and.w	r3, r3, #2
 8001226:	2b00      	cmp	r3, #0
 8001228:	d0f9      	beq.n	800121e <stm32_clock_init+0x1e>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW, selecting HSI.     */
 800122a:	4b40      	ldr	r3, [pc, #256]	; (800132c <stm32_clock_init+0x12c>)
 800122c:	689b      	ldr	r3, [r3, #8]
 800122e:	4a3f      	ldr	r2, [pc, #252]	; (800132c <stm32_clock_init+0x12c>)
 8001230:	f023 0303 	bic.w	r3, r3, #3
 8001234:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001236:	bf00      	nop
 8001238:	4b3c      	ldr	r3, [pc, #240]	; (800132c <stm32_clock_init+0x12c>)
 800123a:	689b      	ldr	r3, [r3, #8]
 800123c:	f003 030c 	and.w	r3, r3, #12
 8001240:	2b00      	cmp	r3, #0
 8001242:	d1f9      	bne.n	8001238 <stm32_clock_init+0x38>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001244:	4b39      	ldr	r3, [pc, #228]	; (800132c <stm32_clock_init+0x12c>)
 8001246:	681b      	ldr	r3, [r3, #0]
 8001248:	4a38      	ldr	r2, [pc, #224]	; (800132c <stm32_clock_init+0x12c>)
 800124a:	f003 03f9 	and.w	r3, r3, #249	; 0xf9
 800124e:	6013      	str	r3, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001250:	4b36      	ldr	r3, [pc, #216]	; (800132c <stm32_clock_init+0x12c>)
 8001252:	2200      	movs	r2, #0
 8001254:	609a      	str	r2, [r3, #8]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001256:	4b35      	ldr	r3, [pc, #212]	; (800132c <stm32_clock_init+0x12c>)
 8001258:	681b      	ldr	r3, [r3, #0]
 800125a:	4a34      	ldr	r2, [pc, #208]	; (800132c <stm32_clock_init+0x12c>)
 800125c:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001260:	6013      	str	r3, [r2, #0]
#endif
  while ((RCC->CR & RCC_CR_HSERDY) == 0)
 8001262:	bf00      	nop
 8001264:	4b31      	ldr	r3, [pc, #196]	; (800132c <stm32_clock_init+0x12c>)
 8001266:	681b      	ldr	r3, [r3, #0]
 8001268:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 800126c:	2b00      	cmp	r3, #0
 800126e:	d0f9      	beq.n	8001264 <stm32_clock_init+0x64>
    ;                           /* Waits until HSE is stable.               */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001270:	4b2e      	ldr	r3, [pc, #184]	; (800132c <stm32_clock_init+0x12c>)
 8001272:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001274:	4a2d      	ldr	r2, [pc, #180]	; (800132c <stm32_clock_init+0x12c>)
 8001276:	f043 0301 	orr.w	r3, r3, #1
 800127a:	6753      	str	r3, [r2, #116]	; 0x74
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 800127c:	bf00      	nop
 800127e:	4b2b      	ldr	r3, [pc, #172]	; (800132c <stm32_clock_init+0x12c>)
 8001280:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001282:	f003 0302 	and.w	r3, r3, #2
 8001286:	2b00      	cmp	r3, #0
 8001288:	d0f9      	beq.n	800127e <stm32_clock_init+0x7e>
    ;                           /* Waits until LSI is stable.               */
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->PLLCFGR = STM32_PLLQ | STM32_PLLSRC | STM32_PLLP | STM32_PLLN |
 800128a:	4b28      	ldr	r3, [pc, #160]	; (800132c <stm32_clock_init+0x12c>)
 800128c:	4a29      	ldr	r2, [pc, #164]	; (8001334 <stm32_clock_init+0x134>)
 800128e:	605a      	str	r2, [r3, #4]
                 STM32_PLLM;
  RCC->CR |= RCC_CR_PLLON;
 8001290:	4b26      	ldr	r3, [pc, #152]	; (800132c <stm32_clock_init+0x12c>)
 8001292:	681b      	ldr	r3, [r3, #0]
 8001294:	4a25      	ldr	r2, [pc, #148]	; (800132c <stm32_clock_init+0x12c>)
 8001296:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800129a:	6013      	str	r3, [r2, #0]

  /* Synchronization with voltage regulator stabilization.*/
#if defined(STM32F4XX)
  while ((PWR->CSR & PWR_CSR_VOSRDY) == 0)
 800129c:	bf00      	nop
 800129e:	4b24      	ldr	r3, [pc, #144]	; (8001330 <stm32_clock_init+0x130>)
 80012a0:	685b      	ldr	r3, [r3, #4]
 80012a2:	f403 4380 	and.w	r3, r3, #16384	; 0x4000
 80012a6:	2b00      	cmp	r3, #0
 80012a8:	d0f9      	beq.n	800129e <stm32_clock_init+0x9e>
      ;
#endif /* STM32_OVERDRIVE_REQUIRED */
#endif /* defined(STM32F4XX) */

  /* Waiting for PLL lock.*/
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80012aa:	bf00      	nop
 80012ac:	4b1f      	ldr	r3, [pc, #124]	; (800132c <stm32_clock_init+0x12c>)
 80012ae:	681b      	ldr	r3, [r3, #0]
 80012b0:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 80012b4:	2b00      	cmp	r3, #0
 80012b6:	d0f9      	beq.n	80012ac <stm32_clock_init+0xac>
    ;
#endif /* STM32_ACTIVATE_PLLSAI */

  /* Other clock-related settings (dividers, MCO etc).*/
#if !defined(STM32F413xx)
  RCC->CFGR = STM32_MCO2PRE | STM32_MCO2SEL | STM32_MCO1PRE | STM32_MCO1SEL |
 80012b8:	4b1c      	ldr	r3, [pc, #112]	; (800132c <stm32_clock_init+0x12c>)
 80012ba:	4a1f      	ldr	r2, [pc, #124]	; (8001338 <stm32_clock_init+0x138>)
 80012bc:	609a      	str	r2, [r3, #8]

  /* Flash setup.*/
#if !defined(STM32_REMOVE_REVISION_A_FIX)
  /* Some old revisions of F4x MCUs randomly crashes with compiler
     optimizations enabled AND flash caches enabled. */
  if ((DBGMCU->IDCODE == 0x20006411) && (SCB->CPUID == 0x410FC241))
 80012be:	4b1f      	ldr	r3, [pc, #124]	; (800133c <stm32_clock_init+0x13c>)
 80012c0:	681b      	ldr	r3, [r3, #0]
 80012c2:	4a1f      	ldr	r2, [pc, #124]	; (8001340 <stm32_clock_init+0x140>)
 80012c4:	4293      	cmp	r3, r2
 80012c6:	d109      	bne.n	80012dc <stm32_clock_init+0xdc>
 80012c8:	4b1e      	ldr	r3, [pc, #120]	; (8001344 <stm32_clock_init+0x144>)
 80012ca:	681b      	ldr	r3, [r3, #0]
 80012cc:	4a1e      	ldr	r2, [pc, #120]	; (8001348 <stm32_clock_init+0x148>)
 80012ce:	4293      	cmp	r3, r2
 80012d0:	d104      	bne.n	80012dc <stm32_clock_init+0xdc>
    FLASH->ACR = FLASH_ACR_PRFTEN | STM32_FLASHBITS;
 80012d2:	4b1e      	ldr	r3, [pc, #120]	; (800134c <stm32_clock_init+0x14c>)
 80012d4:	f240 1205 	movw	r2, #261	; 0x105
 80012d8:	601a      	str	r2, [r3, #0]
 80012da:	e003      	b.n	80012e4 <stm32_clock_init+0xe4>
  else
    FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
 80012dc:	4b1b      	ldr	r3, [pc, #108]	; (800134c <stm32_clock_init+0x14c>)
 80012de:	f240 7205 	movw	r2, #1797	; 0x705
 80012e2:	601a      	str	r2, [r3, #0]
                 FLASH_ACR_DCEN | STM32_FLASHBITS;
#else
  FLASH->ACR = FLASH_ACR_PRFTEN | FLASH_ACR_ICEN |
               FLASH_ACR_DCEN | STM32_FLASHBITS;
#endif
  while ((FLASH->ACR & FLASH_ACR_LATENCY_Msk) !=
 80012e4:	bf00      	nop
 80012e6:	4b19      	ldr	r3, [pc, #100]	; (800134c <stm32_clock_init+0x14c>)
 80012e8:	681b      	ldr	r3, [r3, #0]
 80012ea:	f003 030f 	and.w	r3, r3, #15
 80012ee:	2b05      	cmp	r3, #5
 80012f0:	d1f9      	bne.n	80012e6 <stm32_clock_init+0xe6>
         (STM32_FLASHBITS & FLASH_ACR_LATENCY_Msk)) {
  }

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80012f2:	4b0e      	ldr	r3, [pc, #56]	; (800132c <stm32_clock_init+0x12c>)
 80012f4:	689b      	ldr	r3, [r3, #8]
 80012f6:	4a0d      	ldr	r2, [pc, #52]	; (800132c <stm32_clock_init+0x12c>)
 80012f8:	f043 0302 	orr.w	r3, r3, #2
 80012fc:	6093      	str	r3, [r2, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80012fe:	bf00      	nop
 8001300:	4b0a      	ldr	r3, [pc, #40]	; (800132c <stm32_clock_init+0x12c>)
 8001302:	689b      	ldr	r3, [r3, #8]
 8001304:	f003 030c 	and.w	r3, r3, #12
 8001308:	2b08      	cmp	r3, #8
 800130a:	d1f9      	bne.n	8001300 <stm32_clock_init+0x100>
#endif
#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, true);
 800130c:	4b07      	ldr	r3, [pc, #28]	; (800132c <stm32_clock_init+0x12c>)
 800130e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001310:	4a06      	ldr	r2, [pc, #24]	; (800132c <stm32_clock_init+0x12c>)
 8001312:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001316:	6453      	str	r3, [r2, #68]	; 0x44
 8001318:	4b04      	ldr	r3, [pc, #16]	; (800132c <stm32_clock_init+0x12c>)
 800131a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800131c:	4a03      	ldr	r2, [pc, #12]	; (800132c <stm32_clock_init+0x12c>)
 800131e:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001322:	6653      	str	r3, [r2, #100]	; 0x64
 8001324:	4b01      	ldr	r3, [pc, #4]	; (800132c <stm32_clock_init+0x12c>)
 8001326:	6e5b      	ldr	r3, [r3, #100]	; 0x64
}
 8001328:	bf00      	nop
 800132a:	4770      	bx	lr
 800132c:	40023800 	.word	0x40023800
 8001330:	40007000 	.word	0x40007000
 8001334:	07405410 	.word	0x07405410
 8001338:	38889400 	.word	0x38889400
 800133c:	e0042000 	.word	0xe0042000
 8001340:	20006411 	.word	0x20006411
 8001344:	e000ed00 	.word	0xe000ed00
 8001348:	410fc241 	.word	0x410fc241
 800134c:	40023c00 	.word	0x40023c00

08001350 <_pal_lld_init>:

  for (i = 0; i < 16; i++) {
    _pal_init_event(i);
  }
#endif
}
 8001350:	bf00      	nop
 8001352:	4770      	bx	lr
	...

08001360 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 8001360:	b08e      	sub	sp, #56	; 0x38
 8001362:	9003      	str	r0, [sp, #12]
 8001364:	9102      	str	r1, [sp, #8]
 8001366:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8001368:	9b01      	ldr	r3, [sp, #4]
 800136a:	f003 0303 	and.w	r3, r3, #3
 800136e:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 8001370:	9b01      	ldr	r3, [sp, #4]
 8001372:	089b      	lsrs	r3, r3, #2
 8001374:	f003 0301 	and.w	r3, r3, #1
 8001378:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 800137a:	9b01      	ldr	r3, [sp, #4]
 800137c:	08db      	lsrs	r3, r3, #3
 800137e:	f003 0303 	and.w	r3, r3, #3
 8001382:	930b      	str	r3, [sp, #44]	; 0x2c
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 8001384:	9b01      	ldr	r3, [sp, #4]
 8001386:	095b      	lsrs	r3, r3, #5
 8001388:	f003 0303 	and.w	r3, r3, #3
 800138c:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 800138e:	9b01      	ldr	r3, [sp, #4]
 8001390:	09db      	lsrs	r3, r3, #7
 8001392:	f003 030f 	and.w	r3, r3, #15
 8001396:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 8001398:	2300      	movs	r3, #0
 800139a:	9309      	str	r3, [sp, #36]	; 0x24
  while (true) {
    if ((mask & 1) != 0) {
 800139c:	9b02      	ldr	r3, [sp, #8]
 800139e:	f003 0301 	and.w	r3, r3, #1
 80013a2:	2b00      	cmp	r3, #0
 80013a4:	d079      	beq.n	800149a <_pal_lld_setgroupmode+0x13a>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80013a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013a8:	f003 0307 	and.w	r3, r3, #7
 80013ac:	009b      	lsls	r3, r3, #2
 80013ae:	9a08      	ldr	r2, [sp, #32]
 80013b0:	fa02 f303 	lsl.w	r3, r2, r3
 80013b4:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 80013b6:	2201      	movs	r2, #1
 80013b8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013ba:	fa02 f303 	lsl.w	r3, r2, r3
 80013be:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 80013c0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013c2:	005b      	lsls	r3, r3, #1
 80013c4:	2203      	movs	r2, #3
 80013c6:	fa02 f303 	lsl.w	r3, r2, r3
 80013ca:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 80013cc:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80013ce:	f003 0307 	and.w	r3, r3, #7
 80013d2:	009b      	lsls	r3, r3, #2
 80013d4:	220f      	movs	r2, #15
 80013d6:	fa02 f303 	lsl.w	r3, r2, r3
 80013da:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80013dc:	9b03      	ldr	r3, [sp, #12]
 80013de:	685a      	ldr	r2, [r3, #4]
 80013e0:	9b06      	ldr	r3, [sp, #24]
 80013e2:	43db      	mvns	r3, r3
 80013e4:	401a      	ands	r2, r3
 80013e6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80013e8:	431a      	orrs	r2, r3
 80013ea:	9b03      	ldr	r3, [sp, #12]
 80013ec:	605a      	str	r2, [r3, #4]
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 80013ee:	9b03      	ldr	r3, [sp, #12]
 80013f0:	689a      	ldr	r2, [r3, #8]
 80013f2:	9b05      	ldr	r3, [sp, #20]
 80013f4:	43db      	mvns	r3, r3
 80013f6:	401a      	ands	r2, r3
 80013f8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80013fa:	431a      	orrs	r2, r3
 80013fc:	9b03      	ldr	r3, [sp, #12]
 80013fe:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8001400:	9b03      	ldr	r3, [sp, #12]
 8001402:	68da      	ldr	r2, [r3, #12]
 8001404:	9b05      	ldr	r3, [sp, #20]
 8001406:	43db      	mvns	r3, r3
 8001408:	401a      	ands	r2, r3
 800140a:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 800140c:	431a      	orrs	r2, r3
 800140e:	9b03      	ldr	r3, [sp, #12]
 8001410:	60da      	str	r2, [r3, #12]
      if ((mode & PAL_STM32_MODE_MASK) == PAL_STM32_MODE_ALTERNATE) {
 8001412:	9b01      	ldr	r3, [sp, #4]
 8001414:	f003 0303 	and.w	r3, r3, #3
 8001418:	2b02      	cmp	r3, #2
 800141a:	d11f      	bne.n	800145c <_pal_lld_setgroupmode+0xfc>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 800141c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 800141e:	2b07      	cmp	r3, #7
 8001420:	d809      	bhi.n	8001436 <_pal_lld_setgroupmode+0xd6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001422:	9b03      	ldr	r3, [sp, #12]
 8001424:	6a1a      	ldr	r2, [r3, #32]
 8001426:	9b04      	ldr	r3, [sp, #16]
 8001428:	43db      	mvns	r3, r3
 800142a:	401a      	ands	r2, r3
 800142c:	9b07      	ldr	r3, [sp, #28]
 800142e:	431a      	orrs	r2, r3
 8001430:	9b03      	ldr	r3, [sp, #12]
 8001432:	621a      	str	r2, [r3, #32]
 8001434:	e008      	b.n	8001448 <_pal_lld_setgroupmode+0xe8>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001436:	9b03      	ldr	r3, [sp, #12]
 8001438:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800143a:	9b04      	ldr	r3, [sp, #16]
 800143c:	43db      	mvns	r3, r3
 800143e:	401a      	ands	r2, r3
 8001440:	9b07      	ldr	r3, [sp, #28]
 8001442:	431a      	orrs	r2, r3
 8001444:	9b03      	ldr	r3, [sp, #12]
 8001446:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 8001448:	9b03      	ldr	r3, [sp, #12]
 800144a:	681a      	ldr	r2, [r3, #0]
 800144c:	9b05      	ldr	r3, [sp, #20]
 800144e:	43db      	mvns	r3, r3
 8001450:	401a      	ands	r2, r3
 8001452:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001454:	431a      	orrs	r2, r3
 8001456:	9b03      	ldr	r3, [sp, #12]
 8001458:	601a      	str	r2, [r3, #0]
 800145a:	e01e      	b.n	800149a <_pal_lld_setgroupmode+0x13a>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 800145c:	9b03      	ldr	r3, [sp, #12]
 800145e:	681a      	ldr	r2, [r3, #0]
 8001460:	9b05      	ldr	r3, [sp, #20]
 8001462:	43db      	mvns	r3, r3
 8001464:	401a      	ands	r2, r3
 8001466:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8001468:	431a      	orrs	r2, r3
 800146a:	9b03      	ldr	r3, [sp, #12]
 800146c:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 800146e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8001470:	2b07      	cmp	r3, #7
 8001472:	d809      	bhi.n	8001488 <_pal_lld_setgroupmode+0x128>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8001474:	9b03      	ldr	r3, [sp, #12]
 8001476:	6a1a      	ldr	r2, [r3, #32]
 8001478:	9b04      	ldr	r3, [sp, #16]
 800147a:	43db      	mvns	r3, r3
 800147c:	401a      	ands	r2, r3
 800147e:	9b07      	ldr	r3, [sp, #28]
 8001480:	431a      	orrs	r2, r3
 8001482:	9b03      	ldr	r3, [sp, #12]
 8001484:	621a      	str	r2, [r3, #32]
 8001486:	e008      	b.n	800149a <_pal_lld_setgroupmode+0x13a>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8001488:	9b03      	ldr	r3, [sp, #12]
 800148a:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800148c:	9b04      	ldr	r3, [sp, #16]
 800148e:	43db      	mvns	r3, r3
 8001490:	401a      	ands	r2, r3
 8001492:	9b07      	ldr	r3, [sp, #28]
 8001494:	431a      	orrs	r2, r3
 8001496:	9b03      	ldr	r3, [sp, #12]
 8001498:	625a      	str	r2, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
 800149a:	9b02      	ldr	r3, [sp, #8]
 800149c:	085b      	lsrs	r3, r3, #1
 800149e:	9302      	str	r3, [sp, #8]
    if (!mask)
 80014a0:	9b02      	ldr	r3, [sp, #8]
 80014a2:	2b00      	cmp	r3, #0
 80014a4:	d00f      	beq.n	80014c6 <_pal_lld_setgroupmode+0x166>
      return;
    otyper <<= 1;
 80014a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80014a8:	005b      	lsls	r3, r3, #1
 80014aa:	930c      	str	r3, [sp, #48]	; 0x30
    ospeedr <<= 2;
 80014ac:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80014ae:	009b      	lsls	r3, r3, #2
 80014b0:	930b      	str	r3, [sp, #44]	; 0x2c
    pupdr <<= 2;
 80014b2:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80014b4:	009b      	lsls	r3, r3, #2
 80014b6:	930a      	str	r3, [sp, #40]	; 0x28
    moder <<= 2;
 80014b8:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 80014ba:	009b      	lsls	r3, r3, #2
 80014bc:	930d      	str	r3, [sp, #52]	; 0x34
    bit++;
 80014be:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80014c0:	3301      	adds	r3, #1
 80014c2:	9309      	str	r3, [sp, #36]	; 0x24
    if ((mask & 1) != 0) {
 80014c4:	e76a      	b.n	800139c <_pal_lld_setgroupmode+0x3c>
      return;
 80014c6:	bf00      	nop
  }
}
 80014c8:	b00e      	add	sp, #56	; 0x38
 80014ca:	4770      	bx	lr
 80014cc:	0000      	movs	r0, r0
	...

080014d0 <chSysLockFromISR>:
 *          not be limited to disabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80014d0:	b500      	push	{lr}
 80014d2:	b083      	sub	sp, #12
 80014d4:	2330      	movs	r3, #48	; 0x30
 80014d6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80014d8:	9b01      	ldr	r3, [sp, #4]
 80014da:	f383 8811 	msr	BASEPRI, r3
}
 80014de:	bf00      	nop
}
 80014e0:	bf00      	nop
 * @note    Same as @p port_lock() in this port.
 */
__STATIC_FORCEINLINE void port_lock_from_isr(void) {

  port_lock();
}
 80014e2:	bf00      	nop

  port_lock_from_isr();
  __stats_start_measure_crit_isr();
  __dbg_check_lock_from_isr();
 80014e4:	f000 ff2c 	bl	8002340 <__dbg_check_lock_from_isr>
}
 80014e8:	bf00      	nop
 80014ea:	b003      	add	sp, #12
 80014ec:	f85d fb04 	ldr.w	pc, [sp], #4

080014f0 <chSysUnlockFromISR>:
 *          not be limited to enabling interrupts.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80014f0:	b500      	push	{lr}
 80014f2:	b083      	sub	sp, #12

  __dbg_check_unlock_from_isr();
 80014f4:	f000 ff4c 	bl	8002390 <__dbg_check_unlock_from_isr>
 80014f8:	2300      	movs	r3, #0
 80014fa:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80014fc:	9b01      	ldr	r3, [sp, #4]
 80014fe:	f383 8811 	msr	BASEPRI, r3
}
 8001502:	bf00      	nop
}
 8001504:	bf00      	nop
 * @note    Same as @p port_unlock() in this port.
 */
__STATIC_FORCEINLINE void port_unlock_from_isr(void) {

  port_unlock();
}
 8001506:	bf00      	nop
  __stats_stop_measure_crit_isr();
  port_unlock_from_isr();
}
 8001508:	bf00      	nop
 800150a:	b003      	add	sp, #12
 800150c:	f85d fb04 	ldr.w	pc, [sp], #4

08001510 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8001510:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8001512:	f7ff ffdd 	bl	80014d0 <chSysLockFromISR>
}
 8001516:	bf00      	nop
 8001518:	bd08      	pop	{r3, pc}
 800151a:	bf00      	nop
 800151c:	0000      	movs	r0, r0
	...

08001520 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8001520:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8001522:	f7ff ffe5 	bl	80014f0 <chSysUnlockFromISR>
}
 8001526:	bf00      	nop
 8001528:	bd08      	pop	{r3, pc}
 800152a:	bf00      	nop
 800152c:	0000      	movs	r0, r0
	...

08001530 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8001530:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8001532:	f000 fe9d 	bl	8002270 <chSysTimerHandlerI>
}
 8001536:	bf00      	nop
 8001538:	bd08      	pop	{r3, pc}
 800153a:	bf00      	nop
 800153c:	0000      	movs	r0, r0
	...

08001540 <st_lld_init>:
                "clock rounding error");
  osalDbgAssert(((ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1U) < 0x10000,
                "clock prescaler overflow");

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8001540:	4b1b      	ldr	r3, [pc, #108]	; (80015b0 <st_lld_init+0x70>)
 8001542:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001544:	4a1a      	ldr	r2, [pc, #104]	; (80015b0 <st_lld_init+0x70>)
 8001546:	f043 0301 	orr.w	r3, r3, #1
 800154a:	6413      	str	r3, [r2, #64]	; 0x40
 800154c:	4b18      	ldr	r3, [pc, #96]	; (80015b0 <st_lld_init+0x70>)
 800154e:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001550:	4a17      	ldr	r2, [pc, #92]	; (80015b0 <st_lld_init+0x70>)
 8001552:	f043 0301 	orr.w	r3, r3, #1
 8001556:	6613      	str	r3, [r2, #96]	; 0x60
 8001558:	4b15      	ldr	r3, [pc, #84]	; (80015b0 <st_lld_init+0x70>)
 800155a:	6e1b      	ldr	r3, [r3, #96]	; 0x60

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 800155c:	4b15      	ldr	r3, [pc, #84]	; (80015b4 <st_lld_init+0x74>)
 800155e:	689b      	ldr	r3, [r3, #8]
 8001560:	4a14      	ldr	r2, [pc, #80]	; (80015b4 <st_lld_init+0x74>)
 8001562:	f043 0301 	orr.w	r3, r3, #1
 8001566:	6093      	str	r3, [r2, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8001568:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 800156c:	f242 02cf 	movw	r2, #8399	; 0x20cf
 8001570:	629a      	str	r2, [r3, #40]	; 0x28
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8001572:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001576:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800157a:	62da      	str	r2, [r3, #44]	; 0x2c
  STM32_ST_TIM->CCMR1  = 0;
 800157c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001580:	2200      	movs	r2, #0
 8001582:	619a      	str	r2, [r3, #24]
  STM32_ST_TIM->CCR[0] = 0;
 8001584:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001588:	2200      	movs	r2, #0
 800158a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->CCR[2] = 0;
#endif
#if ST_LLD_NUM_ALARMS > 3
  STM32_ST_TIM->CCR[3] = 0;
#endif
  STM32_ST_TIM->DIER   = 0;
 800158c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001590:	2200      	movs	r2, #0
 8001592:	60da      	str	r2, [r3, #12]
  STM32_ST_TIM->CR2    = 0;
 8001594:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8001598:	2200      	movs	r2, #0
 800159a:	605a      	str	r2, [r3, #4]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 800159c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80015a0:	2201      	movs	r2, #1
 80015a2:	615a      	str	r2, [r3, #20]
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 80015a4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80015a8:	2201      	movs	r2, #1
 80015aa:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 80015ac:	bf00      	nop
 80015ae:	4770      	bx	lr
 80015b0:	40023800 	.word	0x40023800
 80015b4:	e0042000 	.word	0xe0042000
	...

080015c0 <st_lld_serve_interrupt>:

/**
 * @brief   IRQ handling code.
 */
void st_lld_serve_interrupt(void) {
 80015c0:	b500      	push	{lr}
 80015c2:	b083      	sub	sp, #12
#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  uint32_t sr;
  stm32_tim_t *timp = STM32_ST_TIM;
 80015c4:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80015c8:	9301      	str	r3, [sp, #4]

  sr  = timp->SR;
 80015ca:	9b01      	ldr	r3, [sp, #4]
 80015cc:	691b      	ldr	r3, [r3, #16]
 80015ce:	9300      	str	r3, [sp, #0]
  sr &= timp->DIER & STM32_TIM_DIER_IRQ_MASK;
 80015d0:	9b01      	ldr	r3, [sp, #4]
 80015d2:	68db      	ldr	r3, [r3, #12]
 80015d4:	b2db      	uxtb	r3, r3
 80015d6:	9a00      	ldr	r2, [sp, #0]
 80015d8:	4013      	ands	r3, r2
 80015da:	9300      	str	r3, [sp, #0]
  timp->SR = ~sr;
 80015dc:	9b00      	ldr	r3, [sp, #0]
 80015de:	43da      	mvns	r2, r3
 80015e0:	9b01      	ldr	r3, [sp, #4]
 80015e2:	611a      	str	r2, [r3, #16]

  if ((sr & TIM_SR_CC1IF) != 0U)
 80015e4:	9b00      	ldr	r3, [sp, #0]
 80015e6:	f003 0302 	and.w	r3, r3, #2
 80015ea:	2b00      	cmp	r3, #0
 80015ec:	d005      	beq.n	80015fa <st_lld_serve_interrupt+0x3a>
#endif
  {
    osalSysLockFromISR();
 80015ee:	f7ff ff8f 	bl	8001510 <osalSysLockFromISR>
    osalOsTimerHandlerI();
 80015f2:	f7ff ff9d 	bl	8001530 <osalOsTimerHandlerI>
    osalSysUnlockFromISR();
 80015f6:	f7ff ff93 	bl	8001520 <osalSysUnlockFromISR>
      st_callbacks[2](3U);
    }
  }
#endif
#endif
}
 80015fa:	bf00      	nop
 80015fc:	b003      	add	sp, #12
 80015fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001602:	bf00      	nop
	...

08001610 <icu_lld_init>:
/**
 * @brief   Low level ICU driver initialization.
 *
 * @notapi
 */
void icu_lld_init(void) {
 8001610:	b508      	push	{r3, lr}

#if STM32_ICU_USE_TIM1
  /* Driver initialization.*/
  icuObjectInit(&ICUD1);
 8001612:	4804      	ldr	r0, [pc, #16]	; (8001624 <icu_lld_init+0x14>)
 8001614:	f7fe ffd4 	bl	80005c0 <icuObjectInit>
  ICUD1.tim = STM32_TIM1;
 8001618:	4b02      	ldr	r3, [pc, #8]	; (8001624 <icu_lld_init+0x14>)
 800161a:	4a03      	ldr	r2, [pc, #12]	; (8001628 <icu_lld_init+0x18>)
 800161c:	60da      	str	r2, [r3, #12]
#if STM32_ICU_USE_TIM22
  /* Driver initialization.*/
  icuObjectInit(&ICUD22);
  ICUD22.tim = STM32_TIM22;
#endif
}
 800161e:	bf00      	nop
 8001620:	bd08      	pop	{r3, pc}
 8001622:	bf00      	nop
 8001624:	20000858 	.word	0x20000858
 8001628:	40010000 	.word	0x40010000
 800162c:	00000000 	.word	0x00000000

08001630 <icu_lld_start>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_start(ICUDriver *icup) {
 8001630:	b500      	push	{lr}
 8001632:	b085      	sub	sp, #20
 8001634:	9001      	str	r0, [sp, #4]
  uint32_t psc;

  osalDbgAssert((icup->config->channel == ICU_CHANNEL_1) ||
 8001636:	9b01      	ldr	r3, [sp, #4]
 8001638:	685b      	ldr	r3, [r3, #4]
 800163a:	7d1b      	ldrb	r3, [r3, #20]
 800163c:	2b00      	cmp	r3, #0
 800163e:	bf14      	ite	ne
 8001640:	2301      	movne	r3, #1
 8001642:	2300      	moveq	r3, #0
 8001644:	b2db      	uxtb	r3, r3
 8001646:	2b00      	cmp	r3, #0
 8001648:	d00c      	beq.n	8001664 <icu_lld_start+0x34>
 800164a:	9b01      	ldr	r3, [sp, #4]
 800164c:	685b      	ldr	r3, [r3, #4]
 800164e:	7d1b      	ldrb	r3, [r3, #20]
 8001650:	2b01      	cmp	r3, #1
 8001652:	bf14      	ite	ne
 8001654:	2301      	movne	r3, #1
 8001656:	2300      	moveq	r3, #0
 8001658:	b2db      	uxtb	r3, r3
 800165a:	2b00      	cmp	r3, #0
 800165c:	d002      	beq.n	8001664 <icu_lld_start+0x34>
 800165e:	4869      	ldr	r0, [pc, #420]	; (8001804 <icu_lld_start+0x1d4>)
 8001660:	f000 fdce 	bl	8002200 <chSysHalt>
                (icup->config->channel == ICU_CHANNEL_2),
                "invalid input");

  if (icup->state == ICU_STOP) {
 8001664:	9b01      	ldr	r3, [sp, #4]
 8001666:	781b      	ldrb	r3, [r3, #0]
 8001668:	2b01      	cmp	r3, #1
 800166a:	d123      	bne.n	80016b4 <icu_lld_start+0x84>
    /* Clock activation and timer reset.*/
#if STM32_ICU_USE_TIM1
    if (&ICUD1 == icup) {
 800166c:	9b01      	ldr	r3, [sp, #4]
 800166e:	4a66      	ldr	r2, [pc, #408]	; (8001808 <icu_lld_start+0x1d8>)
 8001670:	4293      	cmp	r3, r2
 8001672:	d12f      	bne.n	80016d4 <icu_lld_start+0xa4>
      rccEnableTIM1(true);
 8001674:	4b65      	ldr	r3, [pc, #404]	; (800180c <icu_lld_start+0x1dc>)
 8001676:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001678:	4a64      	ldr	r2, [pc, #400]	; (800180c <icu_lld_start+0x1dc>)
 800167a:	f043 0301 	orr.w	r3, r3, #1
 800167e:	6453      	str	r3, [r2, #68]	; 0x44
 8001680:	4b62      	ldr	r3, [pc, #392]	; (800180c <icu_lld_start+0x1dc>)
 8001682:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001684:	4a61      	ldr	r2, [pc, #388]	; (800180c <icu_lld_start+0x1dc>)
 8001686:	f043 0301 	orr.w	r3, r3, #1
 800168a:	6653      	str	r3, [r2, #100]	; 0x64
 800168c:	4b5f      	ldr	r3, [pc, #380]	; (800180c <icu_lld_start+0x1dc>)
 800168e:	6e5b      	ldr	r3, [r3, #100]	; 0x64
      rccResetTIM1();
 8001690:	4b5e      	ldr	r3, [pc, #376]	; (800180c <icu_lld_start+0x1dc>)
 8001692:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001694:	4a5d      	ldr	r2, [pc, #372]	; (800180c <icu_lld_start+0x1dc>)
 8001696:	f043 0301 	orr.w	r3, r3, #1
 800169a:	6253      	str	r3, [r2, #36]	; 0x24
 800169c:	4b5b      	ldr	r3, [pc, #364]	; (800180c <icu_lld_start+0x1dc>)
 800169e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80016a0:	4a5a      	ldr	r2, [pc, #360]	; (800180c <icu_lld_start+0x1dc>)
 80016a2:	f023 0301 	bic.w	r3, r3, #1
 80016a6:	6253      	str	r3, [r2, #36]	; 0x24
 80016a8:	4b58      	ldr	r3, [pc, #352]	; (800180c <icu_lld_start+0x1dc>)
 80016aa:	6a5b      	ldr	r3, [r3, #36]	; 0x24
      nvicEnableVector(STM32_TIM1_CC_NUMBER, STM32_ICU_TIM1_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM1CLK)
      icup->clock = STM32_TIM1CLK;
#else
      icup->clock = STM32_TIMCLK2;
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	4a58      	ldr	r2, [pc, #352]	; (8001810 <icu_lld_start+0x1e0>)
 80016b0:	609a      	str	r2, [r3, #8]
 80016b2:	e00f      	b.n	80016d4 <icu_lld_start+0xa4>
    }
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    icup->tim->CR1    = 0;                  /* Timer disabled.              */
 80016b4:	9b01      	ldr	r3, [sp, #4]
 80016b6:	68db      	ldr	r3, [r3, #12]
 80016b8:	2200      	movs	r2, #0
 80016ba:	601a      	str	r2, [r3, #0]
    icup->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 80016bc:	9b01      	ldr	r3, [sp, #4]
 80016be:	68db      	ldr	r3, [r3, #12]
 80016c0:	2200      	movs	r2, #0
 80016c2:	635a      	str	r2, [r3, #52]	; 0x34
    icup->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 80016c4:	9b01      	ldr	r3, [sp, #4]
 80016c6:	68db      	ldr	r3, [r3, #12]
 80016c8:	2200      	movs	r2, #0
 80016ca:	639a      	str	r2, [r3, #56]	; 0x38
    icup->tim->CNT    = 0;                  /* Counter reset to zero.       */
 80016cc:	9b01      	ldr	r3, [sp, #4]
 80016ce:	68db      	ldr	r3, [r3, #12]
 80016d0:	2200      	movs	r2, #0
 80016d2:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  icup->tim->SR   = 0;                      /* Clear eventual pending IRQs. */
 80016d4:	9b01      	ldr	r3, [sp, #4]
 80016d6:	68db      	ldr	r3, [r3, #12]
 80016d8:	2200      	movs	r2, #0
 80016da:	611a      	str	r2, [r3, #16]
  icup->tim->DIER = icup->config->dier &    /* DMA-related DIER settings.   */
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	685b      	ldr	r3, [r3, #4]
 80016e0:	699a      	ldr	r2, [r3, #24]
 80016e2:	9b01      	ldr	r3, [sp, #4]
 80016e4:	68db      	ldr	r3, [r3, #12]
 80016e6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80016ea:	60da      	str	r2, [r3, #12]
                    ~STM32_TIM_DIER_IRQ_MASK;
  psc = (icup->clock / icup->config->frequency) - 1;
 80016ec:	9b01      	ldr	r3, [sp, #4]
 80016ee:	689a      	ldr	r2, [r3, #8]
 80016f0:	9b01      	ldr	r3, [sp, #4]
 80016f2:	685b      	ldr	r3, [r3, #4]
 80016f4:	685b      	ldr	r3, [r3, #4]
 80016f6:	fbb2 f3f3 	udiv	r3, r2, r3
 80016fa:	3b01      	subs	r3, #1
 80016fc:	9303      	str	r3, [sp, #12]
  osalDbgAssert((psc <= 0xFFFF) &&
 80016fe:	9b03      	ldr	r3, [sp, #12]
 8001700:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001704:	4293      	cmp	r3, r2
 8001706:	bf8c      	ite	hi
 8001708:	2301      	movhi	r3, #1
 800170a:	2300      	movls	r3, #0
 800170c:	b2db      	uxtb	r3, r3
 800170e:	2b00      	cmp	r3, #0
 8001710:	d10f      	bne.n	8001732 <icu_lld_start+0x102>
 8001712:	9b03      	ldr	r3, [sp, #12]
 8001714:	3301      	adds	r3, #1
 8001716:	9a01      	ldr	r2, [sp, #4]
 8001718:	6852      	ldr	r2, [r2, #4]
 800171a:	6852      	ldr	r2, [r2, #4]
 800171c:	fb03 f202 	mul.w	r2, r3, r2
 8001720:	9b01      	ldr	r3, [sp, #4]
 8001722:	689b      	ldr	r3, [r3, #8]
 8001724:	429a      	cmp	r2, r3
 8001726:	bf14      	ite	ne
 8001728:	2301      	movne	r3, #1
 800172a:	2300      	moveq	r3, #0
 800172c:	b2db      	uxtb	r3, r3
 800172e:	2b00      	cmp	r3, #0
 8001730:	d002      	beq.n	8001738 <icu_lld_start+0x108>
 8001732:	4834      	ldr	r0, [pc, #208]	; (8001804 <icu_lld_start+0x1d4>)
 8001734:	f000 fd64 	bl	8002200 <chSysHalt>
                ((psc + 1) * icup->config->frequency) == icup->clock,
                "invalid frequency");
  icup->tim->PSC = psc;
 8001738:	9b01      	ldr	r3, [sp, #4]
 800173a:	68db      	ldr	r3, [r3, #12]
 800173c:	9a03      	ldr	r2, [sp, #12]
 800173e:	629a      	str	r2, [r3, #40]	; 0x28
  if (icup->config->arr == 0U) {
 8001740:	9b01      	ldr	r3, [sp, #4]
 8001742:	685b      	ldr	r3, [r3, #4]
 8001744:	69db      	ldr	r3, [r3, #28]
 8001746:	2b00      	cmp	r3, #0
 8001748:	d105      	bne.n	8001756 <icu_lld_start+0x126>
    /* Zero is an invalid value and is turned in maximum value, also for
       legacy configurations compatibility.*/
    icup->tim->ARR = 0xFFFFFFFFU;
 800174a:	9b01      	ldr	r3, [sp, #4]
 800174c:	68db      	ldr	r3, [r3, #12]
 800174e:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8001752:	62da      	str	r2, [r3, #44]	; 0x2c
 8001754:	e005      	b.n	8001762 <icu_lld_start+0x132>
  }
  else {
    icup->tim->ARR = icup->config->arr;
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	685a      	ldr	r2, [r3, #4]
 800175a:	9b01      	ldr	r3, [sp, #4]
 800175c:	68db      	ldr	r3, [r3, #12]
 800175e:	69d2      	ldr	r2, [r2, #28]
 8001760:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  if (icup->config->channel == ICU_CHANNEL_1) {
 8001762:	9b01      	ldr	r3, [sp, #4]
 8001764:	685b      	ldr	r3, [r3, #4]
 8001766:	7d1b      	ldrb	r3, [r3, #20]
 8001768:	2b00      	cmp	r3, #0
 800176a:	d123      	bne.n	80017b4 <icu_lld_start+0x184>
    /* Selected input 1.
       CCMR1_CC1S = 01 = CH1 Input on TI1.
       CCMR1_CC2S = 10 = CH2 Input on TI1.*/
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(1) | STM32_TIM_CCMR1_CC2S(2);
 800176c:	9b01      	ldr	r3, [sp, #4]
 800176e:	68db      	ldr	r3, [r3, #12]
 8001770:	f240 2201 	movw	r2, #513	; 0x201
 8001774:	619a      	str	r2, [r3, #24]

    /* SMCR_TS  = 101, input is TI1FP1.
       SMCR_SMS = 100, reset on rising edge.*/
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(5) | STM32_TIM_SMCR_SMS(4);
 8001776:	9b01      	ldr	r3, [sp, #4]
 8001778:	68db      	ldr	r3, [r3, #12]
 800177a:	2254      	movs	r2, #84	; 0x54
 800177c:	609a      	str	r2, [r3, #8]

    /* The CCER settings depend on the selected trigger mode.
       ICU_INPUT_ACTIVE_HIGH: Active on rising edge, idle on falling edge.
       ICU_INPUT_ACTIVE_LOW:  Active on falling edge, idle on rising edge.*/
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 800177e:	9b01      	ldr	r3, [sp, #4]
 8001780:	685b      	ldr	r3, [r3, #4]
 8001782:	781b      	ldrb	r3, [r3, #0]
 8001784:	2b00      	cmp	r3, #0
 8001786:	d104      	bne.n	8001792 <icu_lld_start+0x162>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 8001788:	9b01      	ldr	r3, [sp, #4]
 800178a:	68db      	ldr	r3, [r3, #12]
 800178c:	2231      	movs	r2, #49	; 0x31
 800178e:	621a      	str	r2, [r3, #32]
 8001790:	e003      	b.n	800179a <icu_lld_start+0x16a>
                        STM32_TIM_CCER_CC2E | STM32_TIM_CCER_CC2P;
    else
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 8001792:	9b01      	ldr	r3, [sp, #4]
 8001794:	68db      	ldr	r3, [r3, #12]
 8001796:	2213      	movs	r2, #19
 8001798:	621a      	str	r2, [r3, #32]
                        STM32_TIM_CCER_CC2E;

    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[1];
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	68db      	ldr	r3, [r3, #12]
 800179e:	f103 0238 	add.w	r2, r3, #56	; 0x38
 80017a2:	9b01      	ldr	r3, [sp, #4]
 80017a4:	611a      	str	r2, [r3, #16]
    icup->pccrp = &icup->tim->CCR[0];
 80017a6:	9b01      	ldr	r3, [sp, #4]
 80017a8:	68db      	ldr	r3, [r3, #12]
 80017aa:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80017ae:	9b01      	ldr	r3, [sp, #4]
 80017b0:	615a      	str	r2, [r3, #20]
    /* Direct pointers to the capture registers in order to make reading
       data faster from within callbacks.*/
    icup->wccrp = &icup->tim->CCR[0];
    icup->pccrp = &icup->tim->CCR[1];
  }
}
 80017b2:	e022      	b.n	80017fa <icu_lld_start+0x1ca>
    icup->tim->CCMR1 = STM32_TIM_CCMR1_CC1S(2) | STM32_TIM_CCMR1_CC2S(1);
 80017b4:	9b01      	ldr	r3, [sp, #4]
 80017b6:	68db      	ldr	r3, [r3, #12]
 80017b8:	f44f 7281 	mov.w	r2, #258	; 0x102
 80017bc:	619a      	str	r2, [r3, #24]
    icup->tim->SMCR  = STM32_TIM_SMCR_TS(6) | STM32_TIM_SMCR_SMS(4);
 80017be:	9b01      	ldr	r3, [sp, #4]
 80017c0:	68db      	ldr	r3, [r3, #12]
 80017c2:	2264      	movs	r2, #100	; 0x64
 80017c4:	609a      	str	r2, [r3, #8]
    if (icup->config->mode == ICU_INPUT_ACTIVE_HIGH)
 80017c6:	9b01      	ldr	r3, [sp, #4]
 80017c8:	685b      	ldr	r3, [r3, #4]
 80017ca:	781b      	ldrb	r3, [r3, #0]
 80017cc:	2b00      	cmp	r3, #0
 80017ce:	d104      	bne.n	80017da <icu_lld_start+0x1aa>
      icup->tim->CCER = STM32_TIM_CCER_CC1E | STM32_TIM_CCER_CC1P |
 80017d0:	9b01      	ldr	r3, [sp, #4]
 80017d2:	68db      	ldr	r3, [r3, #12]
 80017d4:	2213      	movs	r2, #19
 80017d6:	621a      	str	r2, [r3, #32]
 80017d8:	e003      	b.n	80017e2 <icu_lld_start+0x1b2>
      icup->tim->CCER = STM32_TIM_CCER_CC1E |
 80017da:	9b01      	ldr	r3, [sp, #4]
 80017dc:	68db      	ldr	r3, [r3, #12]
 80017de:	2231      	movs	r2, #49	; 0x31
 80017e0:	621a      	str	r2, [r3, #32]
    icup->wccrp = &icup->tim->CCR[0];
 80017e2:	9b01      	ldr	r3, [sp, #4]
 80017e4:	68db      	ldr	r3, [r3, #12]
 80017e6:	f103 0234 	add.w	r2, r3, #52	; 0x34
 80017ea:	9b01      	ldr	r3, [sp, #4]
 80017ec:	611a      	str	r2, [r3, #16]
    icup->pccrp = &icup->tim->CCR[1];
 80017ee:	9b01      	ldr	r3, [sp, #4]
 80017f0:	68db      	ldr	r3, [r3, #12]
 80017f2:	f103 0238 	add.w	r2, r3, #56	; 0x38
 80017f6:	9b01      	ldr	r3, [sp, #4]
 80017f8:	615a      	str	r2, [r3, #20]
}
 80017fa:	bf00      	nop
 80017fc:	b005      	add	sp, #20
 80017fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001802:	bf00      	nop
 8001804:	080044f4 	.word	0x080044f4
 8001808:	20000858 	.word	0x20000858
 800180c:	40023800 	.word	0x40023800
 8001810:	0a037a00 	.word	0x0a037a00
	...

08001820 <icu_lld_stop>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_stop(ICUDriver *icup) {
 8001820:	b082      	sub	sp, #8
 8001822:	9001      	str	r0, [sp, #4]

  if (icup->state == ICU_READY) {
 8001824:	9b01      	ldr	r3, [sp, #4]
 8001826:	781b      	ldrb	r3, [r3, #0]
 8001828:	2b02      	cmp	r3, #2
 800182a:	d11d      	bne.n	8001868 <icu_lld_stop+0x48>
    /* Clock deactivation.*/
    icup->tim->CR1  = 0;                    /* Timer disabled.              */
 800182c:	9b01      	ldr	r3, [sp, #4]
 800182e:	68db      	ldr	r3, [r3, #12]
 8001830:	2200      	movs	r2, #0
 8001832:	601a      	str	r2, [r3, #0]
    icup->tim->DIER = 0;                    /* All IRQs disabled.           */
 8001834:	9b01      	ldr	r3, [sp, #4]
 8001836:	68db      	ldr	r3, [r3, #12]
 8001838:	2200      	movs	r2, #0
 800183a:	60da      	str	r2, [r3, #12]
    icup->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 800183c:	9b01      	ldr	r3, [sp, #4]
 800183e:	68db      	ldr	r3, [r3, #12]
 8001840:	2200      	movs	r2, #0
 8001842:	611a      	str	r2, [r3, #16]

#if STM32_ICU_USE_TIM1
    if (&ICUD1 == icup) {
 8001844:	9b01      	ldr	r3, [sp, #4]
 8001846:	4a0a      	ldr	r2, [pc, #40]	; (8001870 <icu_lld_stop+0x50>)
 8001848:	4293      	cmp	r3, r2
 800184a:	d10d      	bne.n	8001868 <icu_lld_stop+0x48>
#if !defined(STM32_TIM1_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM1_UP_NUMBER);
      nvicDisableVector(STM32_TIM1_CC_NUMBER);
#endif
      rccDisableTIM1();
 800184c:	4b09      	ldr	r3, [pc, #36]	; (8001874 <icu_lld_stop+0x54>)
 800184e:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001850:	4a08      	ldr	r2, [pc, #32]	; (8001874 <icu_lld_stop+0x54>)
 8001852:	f023 0301 	bic.w	r3, r3, #1
 8001856:	6453      	str	r3, [r2, #68]	; 0x44
 8001858:	4b06      	ldr	r3, [pc, #24]	; (8001874 <icu_lld_stop+0x54>)
 800185a:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 800185c:	4a05      	ldr	r2, [pc, #20]	; (8001874 <icu_lld_stop+0x54>)
 800185e:	f023 0301 	bic.w	r3, r3, #1
 8001862:	6653      	str	r3, [r2, #100]	; 0x64
 8001864:	4b03      	ldr	r3, [pc, #12]	; (8001874 <icu_lld_stop+0x54>)
 8001866:	6e5b      	ldr	r3, [r3, #100]	; 0x64
    if (&ICUD22 == icup) {
      rccDisableTIM22();
    }
#endif
  }
}
 8001868:	bf00      	nop
 800186a:	b002      	add	sp, #8
 800186c:	4770      	bx	lr
 800186e:	bf00      	nop
 8001870:	20000858 	.word	0x20000858
 8001874:	40023800 	.word	0x40023800
	...

08001880 <icu_lld_start_capture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_start_capture(ICUDriver *icup) {
 8001880:	b082      	sub	sp, #8
 8001882:	9001      	str	r0, [sp, #4]

  /* Triggering an UG and clearing the IRQ status.*/
  icup->tim->EGR |= STM32_TIM_EGR_UG;
 8001884:	9b01      	ldr	r3, [sp, #4]
 8001886:	68db      	ldr	r3, [r3, #12]
 8001888:	695a      	ldr	r2, [r3, #20]
 800188a:	9b01      	ldr	r3, [sp, #4]
 800188c:	68db      	ldr	r3, [r3, #12]
 800188e:	f042 0201 	orr.w	r2, r2, #1
 8001892:	615a      	str	r2, [r3, #20]
  icup->tim->SR = 0;
 8001894:	9b01      	ldr	r3, [sp, #4]
 8001896:	68db      	ldr	r3, [r3, #12]
 8001898:	2200      	movs	r2, #0
 800189a:	611a      	str	r2, [r3, #16]

  /* Timer is started.*/
  icup->tim->CR1 = STM32_TIM_CR1_URS | STM32_TIM_CR1_CEN;
 800189c:	9b01      	ldr	r3, [sp, #4]
 800189e:	68db      	ldr	r3, [r3, #12]
 80018a0:	2205      	movs	r2, #5
 80018a2:	601a      	str	r2, [r3, #0]
}
 80018a4:	bf00      	nop
 80018a6:	b002      	add	sp, #8
 80018a8:	4770      	bx	lr
 80018aa:	bf00      	nop
 80018ac:	0000      	movs	r0, r0
	...

080018b0 <icu_lld_stop_capture>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_stop_capture(ICUDriver *icup) {
 80018b0:	b082      	sub	sp, #8
 80018b2:	9001      	str	r0, [sp, #4]

  /* Timer stopped.*/
  icup->tim->CR1   = 0;
 80018b4:	9b01      	ldr	r3, [sp, #4]
 80018b6:	68db      	ldr	r3, [r3, #12]
 80018b8:	2200      	movs	r2, #0
 80018ba:	601a      	str	r2, [r3, #0]

  /* All interrupts disabled.*/
  icup->tim->DIER &= ~STM32_TIM_DIER_IRQ_MASK;
 80018bc:	9b01      	ldr	r3, [sp, #4]
 80018be:	68db      	ldr	r3, [r3, #12]
 80018c0:	68da      	ldr	r2, [r3, #12]
 80018c2:	9b01      	ldr	r3, [sp, #4]
 80018c4:	68db      	ldr	r3, [r3, #12]
 80018c6:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 80018ca:	60da      	str	r2, [r3, #12]
}
 80018cc:	bf00      	nop
 80018ce:	b002      	add	sp, #8
 80018d0:	4770      	bx	lr
 80018d2:	bf00      	nop
	...

080018e0 <icu_lld_enable_notifications>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_enable_notifications(ICUDriver *icup) {
 80018e0:	b084      	sub	sp, #16
 80018e2:	9001      	str	r0, [sp, #4]
  uint32_t dier = icup->tim->DIER;
 80018e4:	9b01      	ldr	r3, [sp, #4]
 80018e6:	68db      	ldr	r3, [r3, #12]
 80018e8:	68db      	ldr	r3, [r3, #12]
 80018ea:	9303      	str	r3, [sp, #12]

  /* If interrupts were already enabled then the operation is skipped.
     This is done in order to avoid clearing the SR and risk losing
     pending interrupts.*/
  if ((dier & STM32_TIM_DIER_IRQ_MASK) == 0) {
 80018ec:	9b03      	ldr	r3, [sp, #12]
 80018ee:	b2db      	uxtb	r3, r3
 80018f0:	2b00      	cmp	r3, #0
 80018f2:	d130      	bne.n	8001956 <icu_lld_enable_notifications+0x76>
    /* Previously triggered IRQs are ignored, status cleared.*/
    icup->tim->SR = 0;
 80018f4:	9b01      	ldr	r3, [sp, #4]
 80018f6:	68db      	ldr	r3, [r3, #12]
 80018f8:	2200      	movs	r2, #0
 80018fa:	611a      	str	r2, [r3, #16]

    if (icup->config->channel == ICU_CHANNEL_1) {
 80018fc:	9b01      	ldr	r3, [sp, #4]
 80018fe:	685b      	ldr	r3, [r3, #4]
 8001900:	7d1b      	ldrb	r3, [r3, #20]
 8001902:	2b00      	cmp	r3, #0
 8001904:	d10d      	bne.n	8001922 <icu_lld_enable_notifications+0x42>
      /* Enabling periodic callback on CC1.*/
      dier |= STM32_TIM_DIER_CC1IE;
 8001906:	9b03      	ldr	r3, [sp, #12]
 8001908:	f043 0302 	orr.w	r3, r3, #2
 800190c:	9303      	str	r3, [sp, #12]

      /* Optionally enabling width callback on CC2.*/
      if (icup->config->width_cb != NULL)
 800190e:	9b01      	ldr	r3, [sp, #4]
 8001910:	685b      	ldr	r3, [r3, #4]
 8001912:	689b      	ldr	r3, [r3, #8]
 8001914:	2b00      	cmp	r3, #0
 8001916:	d011      	beq.n	800193c <icu_lld_enable_notifications+0x5c>
        dier |= STM32_TIM_DIER_CC2IE;
 8001918:	9b03      	ldr	r3, [sp, #12]
 800191a:	f043 0304 	orr.w	r3, r3, #4
 800191e:	9303      	str	r3, [sp, #12]
 8001920:	e00c      	b.n	800193c <icu_lld_enable_notifications+0x5c>
    }
    else {
      /* Enabling periodic callback on CC2.*/
      dier |= STM32_TIM_DIER_CC2IE;
 8001922:	9b03      	ldr	r3, [sp, #12]
 8001924:	f043 0304 	orr.w	r3, r3, #4
 8001928:	9303      	str	r3, [sp, #12]

      /* Optionally enabling width callback on CC1.*/
      if (icup->config->width_cb != NULL)
 800192a:	9b01      	ldr	r3, [sp, #4]
 800192c:	685b      	ldr	r3, [r3, #4]
 800192e:	689b      	ldr	r3, [r3, #8]
 8001930:	2b00      	cmp	r3, #0
 8001932:	d003      	beq.n	800193c <icu_lld_enable_notifications+0x5c>
        dier |= STM32_TIM_DIER_CC1IE;
 8001934:	9b03      	ldr	r3, [sp, #12]
 8001936:	f043 0302 	orr.w	r3, r3, #2
 800193a:	9303      	str	r3, [sp, #12]
    }

    /* If an overflow callback is defined then also the overflow callback
       is enabled.*/
    if (icup->config->overflow_cb != NULL)
 800193c:	9b01      	ldr	r3, [sp, #4]
 800193e:	685b      	ldr	r3, [r3, #4]
 8001940:	691b      	ldr	r3, [r3, #16]
 8001942:	2b00      	cmp	r3, #0
 8001944:	d003      	beq.n	800194e <icu_lld_enable_notifications+0x6e>
      dier |= STM32_TIM_DIER_UIE;
 8001946:	9b03      	ldr	r3, [sp, #12]
 8001948:	f043 0301 	orr.w	r3, r3, #1
 800194c:	9303      	str	r3, [sp, #12]

    /* One single atomic write.*/
    icup->tim->DIER = dier;
 800194e:	9b01      	ldr	r3, [sp, #4]
 8001950:	68db      	ldr	r3, [r3, #12]
 8001952:	9a03      	ldr	r2, [sp, #12]
 8001954:	60da      	str	r2, [r3, #12]
  }
}
 8001956:	bf00      	nop
 8001958:	b004      	add	sp, #16
 800195a:	4770      	bx	lr
 800195c:	0000      	movs	r0, r0
	...

08001960 <icu_lld_serve_interrupt>:
 *
 * @param[in] icup      pointer to the @p ICUDriver object
 *
 * @notapi
 */
void icu_lld_serve_interrupt(ICUDriver *icup) {
 8001960:	b500      	push	{lr}
 8001962:	b085      	sub	sp, #20
 8001964:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = icup->tim->SR;
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	68db      	ldr	r3, [r3, #12]
 800196a:	691b      	ldr	r3, [r3, #16]
 800196c:	9303      	str	r3, [sp, #12]
  sr &= icup->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 800196e:	9b01      	ldr	r3, [sp, #4]
 8001970:	68db      	ldr	r3, [r3, #12]
 8001972:	68db      	ldr	r3, [r3, #12]
 8001974:	b2db      	uxtb	r3, r3
 8001976:	9a03      	ldr	r2, [sp, #12]
 8001978:	4013      	ands	r3, r2
 800197a:	9303      	str	r3, [sp, #12]
  icup->tim->SR = ~sr;
 800197c:	9b01      	ldr	r3, [sp, #4]
 800197e:	68db      	ldr	r3, [r3, #12]
 8001980:	9a03      	ldr	r2, [sp, #12]
 8001982:	43d2      	mvns	r2, r2
 8001984:	611a      	str	r2, [r3, #16]
  if (icup->config->channel == ICU_CHANNEL_1) {
 8001986:	9b01      	ldr	r3, [sp, #4]
 8001988:	685b      	ldr	r3, [r3, #4]
 800198a:	7d1b      	ldrb	r3, [r3, #20]
 800198c:	2b00      	cmp	r3, #0
 800198e:	d129      	bne.n	80019e4 <icu_lld_serve_interrupt+0x84>
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001990:	9b03      	ldr	r3, [sp, #12]
 8001992:	f003 0304 	and.w	r3, r3, #4
 8001996:	2b00      	cmp	r3, #0
 8001998:	d00d      	beq.n	80019b6 <icu_lld_serve_interrupt+0x56>
      _icu_isr_invoke_width_cb(icup);
 800199a:	9b01      	ldr	r3, [sp, #4]
 800199c:	781b      	ldrb	r3, [r3, #0]
 800199e:	2b04      	cmp	r3, #4
 80019a0:	d109      	bne.n	80019b6 <icu_lld_serve_interrupt+0x56>
 80019a2:	9b01      	ldr	r3, [sp, #4]
 80019a4:	685b      	ldr	r3, [r3, #4]
 80019a6:	689b      	ldr	r3, [r3, #8]
 80019a8:	2b00      	cmp	r3, #0
 80019aa:	d004      	beq.n	80019b6 <icu_lld_serve_interrupt+0x56>
 80019ac:	9b01      	ldr	r3, [sp, #4]
 80019ae:	685b      	ldr	r3, [r3, #4]
 80019b0:	689b      	ldr	r3, [r3, #8]
 80019b2:	9801      	ldr	r0, [sp, #4]
 80019b4:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80019b6:	9b03      	ldr	r3, [sp, #12]
 80019b8:	f003 0302 	and.w	r3, r3, #2
 80019bc:	2b00      	cmp	r3, #0
 80019be:	d03a      	beq.n	8001a36 <icu_lld_serve_interrupt+0xd6>
      _icu_isr_invoke_period_cb(icup);
 80019c0:	9b01      	ldr	r3, [sp, #4]
 80019c2:	781b      	ldrb	r3, [r3, #0]
 80019c4:	2b04      	cmp	r3, #4
 80019c6:	d109      	bne.n	80019dc <icu_lld_serve_interrupt+0x7c>
 80019c8:	9b01      	ldr	r3, [sp, #4]
 80019ca:	685b      	ldr	r3, [r3, #4]
 80019cc:	68db      	ldr	r3, [r3, #12]
 80019ce:	2b00      	cmp	r3, #0
 80019d0:	d004      	beq.n	80019dc <icu_lld_serve_interrupt+0x7c>
 80019d2:	9b01      	ldr	r3, [sp, #4]
 80019d4:	685b      	ldr	r3, [r3, #4]
 80019d6:	68db      	ldr	r3, [r3, #12]
 80019d8:	9801      	ldr	r0, [sp, #4]
 80019da:	4798      	blx	r3
 80019dc:	9b01      	ldr	r3, [sp, #4]
 80019de:	2204      	movs	r2, #4
 80019e0:	701a      	strb	r2, [r3, #0]
 80019e2:	e028      	b.n	8001a36 <icu_lld_serve_interrupt+0xd6>
  }
  else {
    if ((sr & STM32_TIM_SR_CC1IF) != 0)
 80019e4:	9b03      	ldr	r3, [sp, #12]
 80019e6:	f003 0302 	and.w	r3, r3, #2
 80019ea:	2b00      	cmp	r3, #0
 80019ec:	d00d      	beq.n	8001a0a <icu_lld_serve_interrupt+0xaa>
      _icu_isr_invoke_width_cb(icup);
 80019ee:	9b01      	ldr	r3, [sp, #4]
 80019f0:	781b      	ldrb	r3, [r3, #0]
 80019f2:	2b04      	cmp	r3, #4
 80019f4:	d109      	bne.n	8001a0a <icu_lld_serve_interrupt+0xaa>
 80019f6:	9b01      	ldr	r3, [sp, #4]
 80019f8:	685b      	ldr	r3, [r3, #4]
 80019fa:	689b      	ldr	r3, [r3, #8]
 80019fc:	2b00      	cmp	r3, #0
 80019fe:	d004      	beq.n	8001a0a <icu_lld_serve_interrupt+0xaa>
 8001a00:	9b01      	ldr	r3, [sp, #4]
 8001a02:	685b      	ldr	r3, [r3, #4]
 8001a04:	689b      	ldr	r3, [r3, #8]
 8001a06:	9801      	ldr	r0, [sp, #4]
 8001a08:	4798      	blx	r3
    if ((sr & STM32_TIM_SR_CC2IF) != 0)
 8001a0a:	9b03      	ldr	r3, [sp, #12]
 8001a0c:	f003 0304 	and.w	r3, r3, #4
 8001a10:	2b00      	cmp	r3, #0
 8001a12:	d010      	beq.n	8001a36 <icu_lld_serve_interrupt+0xd6>
      _icu_isr_invoke_period_cb(icup);
 8001a14:	9b01      	ldr	r3, [sp, #4]
 8001a16:	781b      	ldrb	r3, [r3, #0]
 8001a18:	2b04      	cmp	r3, #4
 8001a1a:	d109      	bne.n	8001a30 <icu_lld_serve_interrupt+0xd0>
 8001a1c:	9b01      	ldr	r3, [sp, #4]
 8001a1e:	685b      	ldr	r3, [r3, #4]
 8001a20:	68db      	ldr	r3, [r3, #12]
 8001a22:	2b00      	cmp	r3, #0
 8001a24:	d004      	beq.n	8001a30 <icu_lld_serve_interrupt+0xd0>
 8001a26:	9b01      	ldr	r3, [sp, #4]
 8001a28:	685b      	ldr	r3, [r3, #4]
 8001a2a:	68db      	ldr	r3, [r3, #12]
 8001a2c:	9801      	ldr	r0, [sp, #4]
 8001a2e:	4798      	blx	r3
 8001a30:	9b01      	ldr	r3, [sp, #4]
 8001a32:	2204      	movs	r2, #4
 8001a34:	701a      	strb	r2, [r3, #0]
  }
  if ((sr & STM32_TIM_SR_UIF) != 0)
 8001a36:	9b03      	ldr	r3, [sp, #12]
 8001a38:	f003 0301 	and.w	r3, r3, #1
 8001a3c:	2b00      	cmp	r3, #0
 8001a3e:	d007      	beq.n	8001a50 <icu_lld_serve_interrupt+0xf0>
    _icu_isr_invoke_overflow_cb(icup);
 8001a40:	9b01      	ldr	r3, [sp, #4]
 8001a42:	685b      	ldr	r3, [r3, #4]
 8001a44:	691b      	ldr	r3, [r3, #16]
 8001a46:	9801      	ldr	r0, [sp, #4]
 8001a48:	4798      	blx	r3
 8001a4a:	9b01      	ldr	r3, [sp, #4]
 8001a4c:	2203      	movs	r2, #3
 8001a4e:	701a      	strb	r2, [r3, #0]
}
 8001a50:	bf00      	nop
 8001a52:	b005      	add	sp, #20
 8001a54:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001a60 <pwm_lld_init>:
/**
 * @brief   Low level PWM driver initialization.
 *
 * @notapi
 */
void pwm_lld_init(void) {
 8001a60:	b508      	push	{r3, lr}
  PWMD2.has_bdtr = false;
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
 8001a62:	4807      	ldr	r0, [pc, #28]	; (8001a80 <pwm_lld_init+0x20>)
 8001a64:	f7fe ff44 	bl	80008f0 <pwmObjectInit>
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8001a68:	4b05      	ldr	r3, [pc, #20]	; (8001a80 <pwm_lld_init+0x20>)
 8001a6a:	2204      	movs	r2, #4
 8001a6c:	741a      	strb	r2, [r3, #16]
  PWMD3.tim = STM32_TIM3;
 8001a6e:	4b04      	ldr	r3, [pc, #16]	; (8001a80 <pwm_lld_init+0x20>)
 8001a70:	4a04      	ldr	r2, [pc, #16]	; (8001a84 <pwm_lld_init+0x24>)
 8001a72:	61da      	str	r2, [r3, #28]
  PWMD3.has_bdtr = false;
 8001a74:	4b02      	ldr	r3, [pc, #8]	; (8001a80 <pwm_lld_init+0x20>)
 8001a76:	2200      	movs	r2, #0
 8001a78:	761a      	strb	r2, [r3, #24]
  pwmObjectInit(&PWMD22);
  PWMD22.channels = STM32_TIM22_CHANNELS;
  PWMD22.tim = STM32_TIM22;
  PWMD22.has_bdtr = false;
#endif
}
 8001a7a:	bf00      	nop
 8001a7c:	bd08      	pop	{r3, pc}
 8001a7e:	bf00      	nop
 8001a80:	20000870 	.word	0x20000870
 8001a84:	40000400 	.word	0x40000400
	...

08001a90 <pwm_lld_start>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_start(PWMDriver *pwmp) {
 8001a90:	b500      	push	{lr}
 8001a92:	b085      	sub	sp, #20
 8001a94:	9001      	str	r0, [sp, #4]
  uint32_t psc;
  uint32_t ccer;

  if (pwmp->state == PWM_STOP) {
 8001a96:	9b01      	ldr	r3, [sp, #4]
 8001a98:	781b      	ldrb	r3, [r3, #0]
 8001a9a:	2b01      	cmp	r3, #1
 8001a9c:	d12d      	bne.n	8001afa <pwm_lld_start+0x6a>
#endif
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
 8001a9e:	9b01      	ldr	r3, [sp, #4]
 8001aa0:	4a84      	ldr	r2, [pc, #528]	; (8001cb4 <pwm_lld_start+0x224>)
 8001aa2:	4293      	cmp	r3, r2
 8001aa4:	d11e      	bne.n	8001ae4 <pwm_lld_start+0x54>
      rccEnableTIM3(true);
 8001aa6:	4b84      	ldr	r3, [pc, #528]	; (8001cb8 <pwm_lld_start+0x228>)
 8001aa8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001aaa:	4a83      	ldr	r2, [pc, #524]	; (8001cb8 <pwm_lld_start+0x228>)
 8001aac:	f043 0302 	orr.w	r3, r3, #2
 8001ab0:	6413      	str	r3, [r2, #64]	; 0x40
 8001ab2:	4b81      	ldr	r3, [pc, #516]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ab4:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001ab6:	4a80      	ldr	r2, [pc, #512]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ab8:	f043 0302 	orr.w	r3, r3, #2
 8001abc:	6613      	str	r3, [r2, #96]	; 0x60
 8001abe:	4b7e      	ldr	r3, [pc, #504]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ac0:	6e1b      	ldr	r3, [r3, #96]	; 0x60
      rccResetTIM3();
 8001ac2:	4b7d      	ldr	r3, [pc, #500]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ac4:	6a1b      	ldr	r3, [r3, #32]
 8001ac6:	4a7c      	ldr	r2, [pc, #496]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ac8:	f043 0302 	orr.w	r3, r3, #2
 8001acc:	6213      	str	r3, [r2, #32]
 8001ace:	4b7a      	ldr	r3, [pc, #488]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ad0:	6a1b      	ldr	r3, [r3, #32]
 8001ad2:	4a79      	ldr	r2, [pc, #484]	; (8001cb8 <pwm_lld_start+0x228>)
 8001ad4:	f023 0302 	bic.w	r3, r3, #2
 8001ad8:	6213      	str	r3, [r2, #32]
 8001ada:	4b77      	ldr	r3, [pc, #476]	; (8001cb8 <pwm_lld_start+0x228>)
 8001adc:	6a1b      	ldr	r3, [r3, #32]
      nvicEnableVector(STM32_TIM3_NUMBER, STM32_PWM_TIM3_IRQ_PRIORITY);
#endif
#if defined(STM32_TIM3CLK)
      pwmp->clock = STM32_TIM3CLK;
#else
      pwmp->clock = STM32_TIMCLK1;
 8001ade:	9b01      	ldr	r3, [sp, #4]
 8001ae0:	4a76      	ldr	r2, [pc, #472]	; (8001cbc <pwm_lld_start+0x22c>)
 8001ae2:	615a      	str	r2, [r3, #20]
    }
#endif

    /* All channels configured in PWM1 mode with preload enabled and will
       stay that way until the driver is stopped.*/
    pwmp->tim->CCMR1 = STM32_TIM_CCMR1_OC1M(6) | STM32_TIM_CCMR1_OC1PE |
 8001ae4:	9b01      	ldr	r3, [sp, #4]
 8001ae6:	69db      	ldr	r3, [r3, #28]
 8001ae8:	f646 0268 	movw	r2, #26728	; 0x6868
 8001aec:	619a      	str	r2, [r3, #24]
                       STM32_TIM_CCMR1_OC2M(6) | STM32_TIM_CCMR1_OC2PE;
    pwmp->tim->CCMR2 = STM32_TIM_CCMR2_OC3M(6) | STM32_TIM_CCMR2_OC3PE |
 8001aee:	9b01      	ldr	r3, [sp, #4]
 8001af0:	69db      	ldr	r3, [r3, #28]
 8001af2:	f646 0268 	movw	r2, #26728	; 0x6868
 8001af6:	61da      	str	r2, [r3, #28]
 8001af8:	e017      	b.n	8001b2a <pwm_lld_start+0x9a>
                       STM32_TIM_CCMR3_OC6M(6) | STM32_TIM_CCMR3_OC6PE;
#endif
  }
  else {
    /* Driver re-configuration scenario, it must be stopped first.*/
    pwmp->tim->CR1    = 0;                  /* Timer disabled.              */
 8001afa:	9b01      	ldr	r3, [sp, #4]
 8001afc:	69db      	ldr	r3, [r3, #28]
 8001afe:	2200      	movs	r2, #0
 8001b00:	601a      	str	r2, [r3, #0]
    pwmp->tim->CCR[0] = 0;                  /* Comparator 1 disabled.       */
 8001b02:	9b01      	ldr	r3, [sp, #4]
 8001b04:	69db      	ldr	r3, [r3, #28]
 8001b06:	2200      	movs	r2, #0
 8001b08:	635a      	str	r2, [r3, #52]	; 0x34
    pwmp->tim->CCR[1] = 0;                  /* Comparator 2 disabled.       */
 8001b0a:	9b01      	ldr	r3, [sp, #4]
 8001b0c:	69db      	ldr	r3, [r3, #28]
 8001b0e:	2200      	movs	r2, #0
 8001b10:	639a      	str	r2, [r3, #56]	; 0x38
    pwmp->tim->CCR[2] = 0;                  /* Comparator 3 disabled.       */
 8001b12:	9b01      	ldr	r3, [sp, #4]
 8001b14:	69db      	ldr	r3, [r3, #28]
 8001b16:	2200      	movs	r2, #0
 8001b18:	63da      	str	r2, [r3, #60]	; 0x3c
    pwmp->tim->CCR[3] = 0;                  /* Comparator 4 disabled.       */
 8001b1a:	9b01      	ldr	r3, [sp, #4]
 8001b1c:	69db      	ldr	r3, [r3, #28]
 8001b1e:	2200      	movs	r2, #0
 8001b20:	641a      	str	r2, [r3, #64]	; 0x40
    if (pwmp->channels > 4) {
      pwmp->tim->CCXR[0] = 0;               /* Comparator 5 disabled.       */
      pwmp->tim->CCXR[1] = 0;               /* Comparator 6 disabled.       */
    }
#endif
    pwmp->tim->CNT  = 0;                    /* Counter reset to zero.       */
 8001b22:	9b01      	ldr	r3, [sp, #4]
 8001b24:	69db      	ldr	r3, [r3, #28]
 8001b26:	2200      	movs	r2, #0
 8001b28:	625a      	str	r2, [r3, #36]	; 0x24
  }

  /* Timer configuration.*/
  psc = (pwmp->clock / pwmp->config->frequency) - 1;
 8001b2a:	9b01      	ldr	r3, [sp, #4]
 8001b2c:	695a      	ldr	r2, [r3, #20]
 8001b2e:	9b01      	ldr	r3, [sp, #4]
 8001b30:	685b      	ldr	r3, [r3, #4]
 8001b32:	681b      	ldr	r3, [r3, #0]
 8001b34:	fbb2 f3f3 	udiv	r3, r2, r3
 8001b38:	3b01      	subs	r3, #1
 8001b3a:	9302      	str	r3, [sp, #8]
  osalDbgAssert((psc <= 0xFFFF) &&
 8001b3c:	9b02      	ldr	r3, [sp, #8]
 8001b3e:	f64f 72ff 	movw	r2, #65535	; 0xffff
 8001b42:	4293      	cmp	r3, r2
 8001b44:	bf8c      	ite	hi
 8001b46:	2301      	movhi	r3, #1
 8001b48:	2300      	movls	r3, #0
 8001b4a:	b2db      	uxtb	r3, r3
 8001b4c:	2b00      	cmp	r3, #0
 8001b4e:	d10f      	bne.n	8001b70 <pwm_lld_start+0xe0>
 8001b50:	9b02      	ldr	r3, [sp, #8]
 8001b52:	3301      	adds	r3, #1
 8001b54:	9a01      	ldr	r2, [sp, #4]
 8001b56:	6852      	ldr	r2, [r2, #4]
 8001b58:	6812      	ldr	r2, [r2, #0]
 8001b5a:	fb03 f202 	mul.w	r2, r3, r2
 8001b5e:	9b01      	ldr	r3, [sp, #4]
 8001b60:	695b      	ldr	r3, [r3, #20]
 8001b62:	429a      	cmp	r2, r3
 8001b64:	bf14      	ite	ne
 8001b66:	2301      	movne	r3, #1
 8001b68:	2300      	moveq	r3, #0
 8001b6a:	b2db      	uxtb	r3, r3
 8001b6c:	2b00      	cmp	r3, #0
 8001b6e:	d002      	beq.n	8001b76 <pwm_lld_start+0xe6>
 8001b70:	4853      	ldr	r0, [pc, #332]	; (8001cc0 <pwm_lld_start+0x230>)
 8001b72:	f000 fb45 	bl	8002200 <chSysHalt>
                ((psc + 1) * pwmp->config->frequency) == pwmp->clock,
                "invalid frequency");
  pwmp->tim->PSC  = psc;
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	69db      	ldr	r3, [r3, #28]
 8001b7a:	9a02      	ldr	r2, [sp, #8]
 8001b7c:	629a      	str	r2, [r3, #40]	; 0x28
  pwmp->tim->ARR  = pwmp->period - 1;
 8001b7e:	9b01      	ldr	r3, [sp, #4]
 8001b80:	689a      	ldr	r2, [r3, #8]
 8001b82:	9b01      	ldr	r3, [sp, #4]
 8001b84:	69db      	ldr	r3, [r3, #28]
 8001b86:	3a01      	subs	r2, #1
 8001b88:	62da      	str	r2, [r3, #44]	; 0x2c
  pwmp->tim->CR2  = pwmp->config->cr2;
 8001b8a:	9b01      	ldr	r3, [sp, #4]
 8001b8c:	685a      	ldr	r2, [r3, #4]
 8001b8e:	9b01      	ldr	r3, [sp, #4]
 8001b90:	69db      	ldr	r3, [r3, #28]
 8001b92:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8001b94:	605a      	str	r2, [r3, #4]

  /* Output enables and polarities setup.*/
  ccer = 0;
 8001b96:	2300      	movs	r3, #0
 8001b98:	9303      	str	r3, [sp, #12]
  switch (pwmp->config->channels[0].mode & PWM_OUTPUT_MASK) {
 8001b9a:	9b01      	ldr	r3, [sp, #4]
 8001b9c:	685b      	ldr	r3, [r3, #4]
 8001b9e:	68db      	ldr	r3, [r3, #12]
 8001ba0:	f003 030f 	and.w	r3, r3, #15
 8001ba4:	2b01      	cmp	r3, #1
 8001ba6:	d005      	beq.n	8001bb4 <pwm_lld_start+0x124>
 8001ba8:	2b02      	cmp	r3, #2
 8001baa:	d107      	bne.n	8001bbc <pwm_lld_start+0x12c>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC1P;
 8001bac:	9b03      	ldr	r3, [sp, #12]
 8001bae:	f043 0302 	orr.w	r3, r3, #2
 8001bb2:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC1E;
 8001bb4:	9b03      	ldr	r3, [sp, #12]
 8001bb6:	f043 0301 	orr.w	r3, r3, #1
 8001bba:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[1].mode & PWM_OUTPUT_MASK) {
 8001bbc:	9b01      	ldr	r3, [sp, #4]
 8001bbe:	685b      	ldr	r3, [r3, #4]
 8001bc0:	695b      	ldr	r3, [r3, #20]
 8001bc2:	f003 030f 	and.w	r3, r3, #15
 8001bc6:	2b01      	cmp	r3, #1
 8001bc8:	d005      	beq.n	8001bd6 <pwm_lld_start+0x146>
 8001bca:	2b02      	cmp	r3, #2
 8001bcc:	d107      	bne.n	8001bde <pwm_lld_start+0x14e>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC2P;
 8001bce:	9b03      	ldr	r3, [sp, #12]
 8001bd0:	f043 0320 	orr.w	r3, r3, #32
 8001bd4:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC2E;
 8001bd6:	9b03      	ldr	r3, [sp, #12]
 8001bd8:	f043 0310 	orr.w	r3, r3, #16
 8001bdc:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[2].mode & PWM_OUTPUT_MASK) {
 8001bde:	9b01      	ldr	r3, [sp, #4]
 8001be0:	685b      	ldr	r3, [r3, #4]
 8001be2:	69db      	ldr	r3, [r3, #28]
 8001be4:	f003 030f 	and.w	r3, r3, #15
 8001be8:	2b01      	cmp	r3, #1
 8001bea:	d005      	beq.n	8001bf8 <pwm_lld_start+0x168>
 8001bec:	2b02      	cmp	r3, #2
 8001bee:	d107      	bne.n	8001c00 <pwm_lld_start+0x170>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC3P;
 8001bf0:	9b03      	ldr	r3, [sp, #12]
 8001bf2:	f443 7300 	orr.w	r3, r3, #512	; 0x200
 8001bf6:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC3E;
 8001bf8:	9b03      	ldr	r3, [sp, #12]
 8001bfa:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8001bfe:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  switch (pwmp->config->channels[3].mode & PWM_OUTPUT_MASK) {
 8001c00:	9b01      	ldr	r3, [sp, #4]
 8001c02:	685b      	ldr	r3, [r3, #4]
 8001c04:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c06:	f003 030f 	and.w	r3, r3, #15
 8001c0a:	2b01      	cmp	r3, #1
 8001c0c:	d005      	beq.n	8001c1a <pwm_lld_start+0x18a>
 8001c0e:	2b02      	cmp	r3, #2
 8001c10:	d107      	bne.n	8001c22 <pwm_lld_start+0x192>
  case PWM_OUTPUT_ACTIVE_LOW:
    ccer |= STM32_TIM_CCER_CC4P;
 8001c12:	9b03      	ldr	r3, [sp, #12]
 8001c14:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001c18:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  case PWM_OUTPUT_ACTIVE_HIGH:
    ccer |= STM32_TIM_CCER_CC4E;
 8001c1a:	9b03      	ldr	r3, [sp, #12]
 8001c1c:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8001c20:	9303      	str	r3, [sp, #12]
    /* Falls through.*/
  default:
    ;
  }
  if (pwmp->has_bdtr) {
 8001c22:	9b01      	ldr	r3, [sp, #4]
 8001c24:	7e1b      	ldrb	r3, [r3, #24]
 8001c26:	2b00      	cmp	r3, #0
 8001c28:	d04c      	beq.n	8001cc4 <pwm_lld_start+0x234>
    switch (pwmp->config->channels[0].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 8001c2a:	9b01      	ldr	r3, [sp, #4]
 8001c2c:	685b      	ldr	r3, [r3, #4]
 8001c2e:	68db      	ldr	r3, [r3, #12]
 8001c30:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001c34:	2b10      	cmp	r3, #16
 8001c36:	d005      	beq.n	8001c44 <pwm_lld_start+0x1b4>
 8001c38:	2b20      	cmp	r3, #32
 8001c3a:	d107      	bne.n	8001c4c <pwm_lld_start+0x1bc>
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
      ccer |= STM32_TIM_CCER_CC1NP;
 8001c3c:	9b03      	ldr	r3, [sp, #12]
 8001c3e:	f043 0308 	orr.w	r3, r3, #8
 8001c42:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
      ccer |= STM32_TIM_CCER_CC1NE;
 8001c44:	9b03      	ldr	r3, [sp, #12]
 8001c46:	f043 0304 	orr.w	r3, r3, #4
 8001c4a:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[1].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 8001c4c:	9b01      	ldr	r3, [sp, #4]
 8001c4e:	685b      	ldr	r3, [r3, #4]
 8001c50:	695b      	ldr	r3, [r3, #20]
 8001c52:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001c56:	2b10      	cmp	r3, #16
 8001c58:	d005      	beq.n	8001c66 <pwm_lld_start+0x1d6>
 8001c5a:	2b20      	cmp	r3, #32
 8001c5c:	d107      	bne.n	8001c6e <pwm_lld_start+0x1de>
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
      ccer |= STM32_TIM_CCER_CC2NP;
 8001c5e:	9b03      	ldr	r3, [sp, #12]
 8001c60:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001c64:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
      ccer |= STM32_TIM_CCER_CC2NE;
 8001c66:	9b03      	ldr	r3, [sp, #12]
 8001c68:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8001c6c:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[2].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 8001c6e:	9b01      	ldr	r3, [sp, #4]
 8001c70:	685b      	ldr	r3, [r3, #4]
 8001c72:	69db      	ldr	r3, [r3, #28]
 8001c74:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001c78:	2b10      	cmp	r3, #16
 8001c7a:	d005      	beq.n	8001c88 <pwm_lld_start+0x1f8>
 8001c7c:	2b20      	cmp	r3, #32
 8001c7e:	d107      	bne.n	8001c90 <pwm_lld_start+0x200>
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
      ccer |= STM32_TIM_CCER_CC3NP;
 8001c80:	9b03      	ldr	r3, [sp, #12]
 8001c82:	f443 6300 	orr.w	r3, r3, #2048	; 0x800
 8001c86:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
      ccer |= STM32_TIM_CCER_CC3NE;
 8001c88:	9b03      	ldr	r3, [sp, #12]
 8001c8a:	f443 6380 	orr.w	r3, r3, #1024	; 0x400
 8001c8e:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    default:
      ;
    }
    switch (pwmp->config->channels[3].mode & PWM_COMPLEMENTARY_OUTPUT_MASK) {
 8001c90:	9b01      	ldr	r3, [sp, #4]
 8001c92:	685b      	ldr	r3, [r3, #4]
 8001c94:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8001c96:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8001c9a:	2b10      	cmp	r3, #16
 8001c9c:	d005      	beq.n	8001caa <pwm_lld_start+0x21a>
 8001c9e:	2b20      	cmp	r3, #32
 8001ca0:	d111      	bne.n	8001cc6 <pwm_lld_start+0x236>
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_LOW:
      ccer |= STM32_TIM_CCER_CC4NP;
 8001ca2:	9b03      	ldr	r3, [sp, #12]
 8001ca4:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001ca8:	9303      	str	r3, [sp, #12]
      /* Falls through.*/
    case PWM_COMPLEMENTARY_OUTPUT_ACTIVE_HIGH:
      ccer |= STM32_TIM_CCER_CC4NE;
 8001caa:	9b03      	ldr	r3, [sp, #12]
 8001cac:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001cb0:	9303      	str	r3, [sp, #12]
 8001cb2:	e008      	b.n	8001cc6 <pwm_lld_start+0x236>
 8001cb4:	20000870 	.word	0x20000870
 8001cb8:	40023800 	.word	0x40023800
 8001cbc:	0501bd00 	.word	0x0501bd00
 8001cc0:	08004504 	.word	0x08004504
      /* Falls through.*/
    default:
 8001cc4:	bf00      	nop
      ;
    }
  }

  pwmp->tim->CCER  = ccer;
 8001cc6:	9b01      	ldr	r3, [sp, #4]
 8001cc8:	69db      	ldr	r3, [r3, #28]
 8001cca:	9a03      	ldr	r2, [sp, #12]
 8001ccc:	621a      	str	r2, [r3, #32]
  pwmp->tim->EGR   = STM32_TIM_EGR_UG;      /* Update event.                */
 8001cce:	9b01      	ldr	r3, [sp, #4]
 8001cd0:	69db      	ldr	r3, [r3, #28]
 8001cd2:	2201      	movs	r2, #1
 8001cd4:	615a      	str	r2, [r3, #20]
  pwmp->tim->SR    = 0;                     /* Clear pending IRQs.          */
 8001cd6:	9b01      	ldr	r3, [sp, #4]
 8001cd8:	69db      	ldr	r3, [r3, #28]
 8001cda:	2200      	movs	r2, #0
 8001cdc:	611a      	str	r2, [r3, #16]
  pwmp->tim->DIER  = pwmp->config->dier &   /* DMA-related DIER settings.   */
 8001cde:	9b01      	ldr	r3, [sp, #4]
 8001ce0:	685b      	ldr	r3, [r3, #4]
 8001ce2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	69db      	ldr	r3, [r3, #28]
 8001ce8:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 8001cec:	60da      	str	r2, [r3, #12]
                     ~STM32_TIM_DIER_IRQ_MASK;
  if (pwmp->has_bdtr) {
 8001cee:	9b01      	ldr	r3, [sp, #4]
 8001cf0:	7e1b      	ldrb	r3, [r3, #24]
 8001cf2:	2b00      	cmp	r3, #0
 8001cf4:	d007      	beq.n	8001d06 <pwm_lld_start+0x276>
    pwmp->tim->BDTR  = pwmp->config->bdtr | STM32_TIM_BDTR_MOE;
 8001cf6:	9b01      	ldr	r3, [sp, #4]
 8001cf8:	685b      	ldr	r3, [r3, #4]
 8001cfa:	6b1a      	ldr	r2, [r3, #48]	; 0x30
 8001cfc:	9b01      	ldr	r3, [sp, #4]
 8001cfe:	69db      	ldr	r3, [r3, #28]
 8001d00:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001d04:	645a      	str	r2, [r3, #68]	; 0x44
  }
  /* Timer configured and started.*/
  pwmp->tim->CR1   = STM32_TIM_CR1_ARPE | STM32_TIM_CR1_URS |
 8001d06:	9b01      	ldr	r3, [sp, #4]
 8001d08:	69db      	ldr	r3, [r3, #28]
 8001d0a:	2285      	movs	r2, #133	; 0x85
 8001d0c:	601a      	str	r2, [r3, #0]
                     STM32_TIM_CR1_CEN;
}
 8001d0e:	bf00      	nop
 8001d10:	b005      	add	sp, #20
 8001d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d16:	bf00      	nop
	...

08001d20 <pwm_lld_stop>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_stop(PWMDriver *pwmp) {
 8001d20:	b082      	sub	sp, #8
 8001d22:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the PWM clock.*/
  if (pwmp->state == PWM_READY) {
 8001d24:	9b01      	ldr	r3, [sp, #4]
 8001d26:	781b      	ldrb	r3, [r3, #0]
 8001d28:	2b02      	cmp	r3, #2
 8001d2a:	d125      	bne.n	8001d78 <pwm_lld_stop+0x58>
    pwmp->tim->CR1  = 0;                    /* Timer disabled.              */
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	69db      	ldr	r3, [r3, #28]
 8001d30:	2200      	movs	r2, #0
 8001d32:	601a      	str	r2, [r3, #0]
    pwmp->tim->DIER = 0;                    /* All IRQs disabled.           */
 8001d34:	9b01      	ldr	r3, [sp, #4]
 8001d36:	69db      	ldr	r3, [r3, #28]
 8001d38:	2200      	movs	r2, #0
 8001d3a:	60da      	str	r2, [r3, #12]
    pwmp->tim->SR   = 0;                    /* Clear eventual pending IRQs. */
 8001d3c:	9b01      	ldr	r3, [sp, #4]
 8001d3e:	69db      	ldr	r3, [r3, #28]
 8001d40:	2200      	movs	r2, #0
 8001d42:	611a      	str	r2, [r3, #16]
    if (pwmp->has_bdtr) {
 8001d44:	9b01      	ldr	r3, [sp, #4]
 8001d46:	7e1b      	ldrb	r3, [r3, #24]
 8001d48:	2b00      	cmp	r3, #0
 8001d4a:	d003      	beq.n	8001d54 <pwm_lld_stop+0x34>
      pwmp->tim->BDTR  = 0;
 8001d4c:	9b01      	ldr	r3, [sp, #4]
 8001d4e:	69db      	ldr	r3, [r3, #28]
 8001d50:	2200      	movs	r2, #0
 8001d52:	645a      	str	r2, [r3, #68]	; 0x44
      rccDisableTIM2();
    }
#endif

#if STM32_PWM_USE_TIM3
    if (&PWMD3 == pwmp) {
 8001d54:	9b01      	ldr	r3, [sp, #4]
 8001d56:	4a0a      	ldr	r2, [pc, #40]	; (8001d80 <pwm_lld_stop+0x60>)
 8001d58:	4293      	cmp	r3, r2
 8001d5a:	d10d      	bne.n	8001d78 <pwm_lld_stop+0x58>
#if !defined(STM32_TIM3_SUPPRESS_ISR)
      nvicDisableVector(STM32_TIM3_NUMBER);
#endif
      rccDisableTIM3();
 8001d5c:	4b09      	ldr	r3, [pc, #36]	; (8001d84 <pwm_lld_stop+0x64>)
 8001d5e:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8001d60:	4a08      	ldr	r2, [pc, #32]	; (8001d84 <pwm_lld_stop+0x64>)
 8001d62:	f023 0302 	bic.w	r3, r3, #2
 8001d66:	6413      	str	r3, [r2, #64]	; 0x40
 8001d68:	4b06      	ldr	r3, [pc, #24]	; (8001d84 <pwm_lld_stop+0x64>)
 8001d6a:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 8001d6c:	4a05      	ldr	r2, [pc, #20]	; (8001d84 <pwm_lld_stop+0x64>)
 8001d6e:	f023 0302 	bic.w	r3, r3, #2
 8001d72:	6613      	str	r3, [r2, #96]	; 0x60
 8001d74:	4b03      	ldr	r3, [pc, #12]	; (8001d84 <pwm_lld_stop+0x64>)
 8001d76:	6e1b      	ldr	r3, [r3, #96]	; 0x60
    if (&PWMD22 == pwmp) {
      rccDisableTIM22();
    }
#endif
  }
}
 8001d78:	bf00      	nop
 8001d7a:	b002      	add	sp, #8
 8001d7c:	4770      	bx	lr
 8001d7e:	bf00      	nop
 8001d80:	20000870 	.word	0x20000870
 8001d84:	40023800 	.word	0x40023800
	...

08001d90 <pwm_lld_enable_channel>:
 *
 * @notapi
 */
void pwm_lld_enable_channel(PWMDriver *pwmp,
                            pwmchannel_t channel,
                            pwmcnt_t width) {
 8001d90:	b084      	sub	sp, #16
 8001d92:	9003      	str	r0, [sp, #12]
 8001d94:	460b      	mov	r3, r1
 8001d96:	9201      	str	r2, [sp, #4]
 8001d98:	f88d 300b 	strb.w	r3, [sp, #11]

  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
 8001d9c:	9b03      	ldr	r3, [sp, #12]
 8001d9e:	69da      	ldr	r2, [r3, #28]
 8001da0:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8001da4:	330c      	adds	r3, #12
 8001da6:	009b      	lsls	r3, r3, #2
 8001da8:	4413      	add	r3, r2
 8001daa:	9a01      	ldr	r2, [sp, #4]
 8001dac:	605a      	str	r2, [r3, #4]
  if (channel < 4)
    pwmp->tim->CCR[channel] = width;
  else
    pwmp->tim->CCXR[channel - 4] = width;
#endif
}
 8001dae:	bf00      	nop
 8001db0:	b004      	add	sp, #16
 8001db2:	4770      	bx	lr
	...

08001dc0 <pwm_lld_disable_channel>:
 * @param[in] pwmp      pointer to a @p PWMDriver object
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @notapi
 */
void pwm_lld_disable_channel(PWMDriver *pwmp, pwmchannel_t channel) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	9001      	str	r0, [sp, #4]
 8001dc4:	460b      	mov	r3, r1
 8001dc6:	f88d 3003 	strb.w	r3, [sp, #3]

#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = 0;
 8001dca:	9b01      	ldr	r3, [sp, #4]
 8001dcc:	69da      	ldr	r2, [r3, #28]
 8001dce:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001dd2:	330c      	adds	r3, #12
 8001dd4:	009b      	lsls	r3, r3, #2
 8001dd6:	4413      	add	r3, r2
 8001dd8:	2200      	movs	r2, #0
 8001dda:	605a      	str	r2, [r3, #4]
  pwmp->tim->DIER &= ~(2 << channel);
 8001ddc:	9b01      	ldr	r3, [sp, #4]
 8001dde:	69db      	ldr	r3, [r3, #28]
 8001de0:	68da      	ldr	r2, [r3, #12]
 8001de2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001de6:	2102      	movs	r1, #2
 8001de8:	fa01 f303 	lsl.w	r3, r1, r3
 8001dec:	43db      	mvns	r3, r3
 8001dee:	4619      	mov	r1, r3
 8001df0:	9b01      	ldr	r3, [sp, #4]
 8001df2:	69db      	ldr	r3, [r3, #28]
 8001df4:	400a      	ands	r2, r1
 8001df6:	60da      	str	r2, [r3, #12]
    pwmp->tim->DIER &= ~(2 << channel);
  }
  else
    pwmp->tim->CCXR[channel - 4] = 0;
#endif
}
 8001df8:	bf00      	nop
 8001dfa:	b002      	add	sp, #8
 8001dfc:	4770      	bx	lr
 8001dfe:	bf00      	nop

08001e00 <pwm_lld_enable_periodic_notification>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_enable_periodic_notification(PWMDriver *pwmp) {
 8001e00:	b084      	sub	sp, #16
 8001e02:	9001      	str	r0, [sp, #4]
  uint32_t dier = pwmp->tim->DIER;
 8001e04:	9b01      	ldr	r3, [sp, #4]
 8001e06:	69db      	ldr	r3, [r3, #28]
 8001e08:	68db      	ldr	r3, [r3, #12]
 8001e0a:	9303      	str	r3, [sp, #12]

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & STM32_TIM_DIER_UIE) == 0) {
 8001e0c:	9b03      	ldr	r3, [sp, #12]
 8001e0e:	f003 0301 	and.w	r3, r3, #1
 8001e12:	2b00      	cmp	r3, #0
 8001e14:	d10a      	bne.n	8001e2c <pwm_lld_enable_periodic_notification+0x2c>
    pwmp->tim->SR   = ~STM32_TIM_SR_UIF;
 8001e16:	9b01      	ldr	r3, [sp, #4]
 8001e18:	69db      	ldr	r3, [r3, #28]
 8001e1a:	f06f 0201 	mvn.w	r2, #1
 8001e1e:	611a      	str	r2, [r3, #16]
    pwmp->tim->DIER = dier | STM32_TIM_DIER_UIE;
 8001e20:	9b01      	ldr	r3, [sp, #4]
 8001e22:	69db      	ldr	r3, [r3, #28]
 8001e24:	9a03      	ldr	r2, [sp, #12]
 8001e26:	f042 0201 	orr.w	r2, r2, #1
 8001e2a:	60da      	str	r2, [r3, #12]
  }
}
 8001e2c:	bf00      	nop
 8001e2e:	b004      	add	sp, #16
 8001e30:	4770      	bx	lr
 8001e32:	bf00      	nop
	...

08001e40 <pwm_lld_enable_channel_notification>:
 * @param[in] channel   PWM channel identifier (0...channels-1)
 *
 * @notapi
 */
void pwm_lld_enable_channel_notification(PWMDriver *pwmp,
                                         pwmchannel_t channel) {
 8001e40:	b084      	sub	sp, #16
 8001e42:	9001      	str	r0, [sp, #4]
 8001e44:	460b      	mov	r3, r1
 8001e46:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t dier = pwmp->tim->DIER;
 8001e4a:	9b01      	ldr	r3, [sp, #4]
 8001e4c:	69db      	ldr	r3, [r3, #28]
 8001e4e:	68db      	ldr	r3, [r3, #12]
 8001e50:	9303      	str	r3, [sp, #12]
  osalDbgAssert(channel < 4, "callback not supported");
#endif

  /* If the IRQ is not already enabled care must be taken to clear it,
     it is probably already pending because the timer is running.*/
  if ((dier & (2 << channel)) == 0) {
 8001e52:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001e56:	2202      	movs	r2, #2
 8001e58:	fa02 f303 	lsl.w	r3, r2, r3
 8001e5c:	461a      	mov	r2, r3
 8001e5e:	9b03      	ldr	r3, [sp, #12]
 8001e60:	4013      	ands	r3, r2
 8001e62:	2b00      	cmp	r3, #0
 8001e64:	d113      	bne.n	8001e8e <pwm_lld_enable_channel_notification+0x4e>
    pwmp->tim->SR   = ~(2 << channel);
 8001e66:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001e6a:	2202      	movs	r2, #2
 8001e6c:	fa02 f303 	lsl.w	r3, r2, r3
 8001e70:	43da      	mvns	r2, r3
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	69db      	ldr	r3, [r3, #28]
 8001e76:	611a      	str	r2, [r3, #16]
    pwmp->tim->DIER = dier | (2 << channel);
 8001e78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8001e7c:	2202      	movs	r2, #2
 8001e7e:	fa02 f303 	lsl.w	r3, r2, r3
 8001e82:	4619      	mov	r1, r3
 8001e84:	9b01      	ldr	r3, [sp, #4]
 8001e86:	69db      	ldr	r3, [r3, #28]
 8001e88:	9a03      	ldr	r2, [sp, #12]
 8001e8a:	430a      	orrs	r2, r1
 8001e8c:	60da      	str	r2, [r3, #12]
  }
}
 8001e8e:	bf00      	nop
 8001e90:	b004      	add	sp, #16
 8001e92:	4770      	bx	lr
	...

08001ea0 <pwm_lld_serve_interrupt>:
 *
 * @param[in] pwmp      pointer to a @p PWMDriver object
 *
 * @notapi
 */
void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
 8001ea0:	b500      	push	{lr}
 8001ea2:	b085      	sub	sp, #20
 8001ea4:	9001      	str	r0, [sp, #4]
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8001ea6:	9b01      	ldr	r3, [sp, #4]
 8001ea8:	69db      	ldr	r3, [r3, #28]
 8001eaa:	691b      	ldr	r3, [r3, #16]
 8001eac:	9303      	str	r3, [sp, #12]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001eae:	9b01      	ldr	r3, [sp, #4]
 8001eb0:	69db      	ldr	r3, [r3, #28]
 8001eb2:	68db      	ldr	r3, [r3, #12]
 8001eb4:	b2db      	uxtb	r3, r3
 8001eb6:	9a03      	ldr	r2, [sp, #12]
 8001eb8:	4013      	ands	r3, r2
 8001eba:	9303      	str	r3, [sp, #12]
  pwmp->tim->SR = ~sr;
 8001ebc:	9b01      	ldr	r3, [sp, #4]
 8001ebe:	69db      	ldr	r3, [r3, #28]
 8001ec0:	9a03      	ldr	r2, [sp, #12]
 8001ec2:	43d2      	mvns	r2, r2
 8001ec4:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8001ec6:	9b03      	ldr	r3, [sp, #12]
 8001ec8:	f003 0302 	and.w	r3, r3, #2
 8001ecc:	2b00      	cmp	r3, #0
 8001ece:	d009      	beq.n	8001ee4 <pwm_lld_serve_interrupt+0x44>
      (pwmp->config->channels[0].callback != NULL))
 8001ed0:	9b01      	ldr	r3, [sp, #4]
 8001ed2:	685b      	ldr	r3, [r3, #4]
 8001ed4:	691b      	ldr	r3, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 8001ed6:	2b00      	cmp	r3, #0
 8001ed8:	d004      	beq.n	8001ee4 <pwm_lld_serve_interrupt+0x44>
    pwmp->config->channels[0].callback(pwmp);
 8001eda:	9b01      	ldr	r3, [sp, #4]
 8001edc:	685b      	ldr	r3, [r3, #4]
 8001ede:	691b      	ldr	r3, [r3, #16]
 8001ee0:	9801      	ldr	r0, [sp, #4]
 8001ee2:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001ee4:	9b03      	ldr	r3, [sp, #12]
 8001ee6:	f003 0304 	and.w	r3, r3, #4
 8001eea:	2b00      	cmp	r3, #0
 8001eec:	d009      	beq.n	8001f02 <pwm_lld_serve_interrupt+0x62>
      (pwmp->config->channels[1].callback != NULL))
 8001eee:	9b01      	ldr	r3, [sp, #4]
 8001ef0:	685b      	ldr	r3, [r3, #4]
 8001ef2:	699b      	ldr	r3, [r3, #24]
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 8001ef4:	2b00      	cmp	r3, #0
 8001ef6:	d004      	beq.n	8001f02 <pwm_lld_serve_interrupt+0x62>
    pwmp->config->channels[1].callback(pwmp);
 8001ef8:	9b01      	ldr	r3, [sp, #4]
 8001efa:	685b      	ldr	r3, [r3, #4]
 8001efc:	699b      	ldr	r3, [r3, #24]
 8001efe:	9801      	ldr	r0, [sp, #4]
 8001f00:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001f02:	9b03      	ldr	r3, [sp, #12]
 8001f04:	f003 0308 	and.w	r3, r3, #8
 8001f08:	2b00      	cmp	r3, #0
 8001f0a:	d009      	beq.n	8001f20 <pwm_lld_serve_interrupt+0x80>
      (pwmp->config->channels[2].callback != NULL))
 8001f0c:	9b01      	ldr	r3, [sp, #4]
 8001f0e:	685b      	ldr	r3, [r3, #4]
 8001f10:	6a1b      	ldr	r3, [r3, #32]
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 8001f12:	2b00      	cmp	r3, #0
 8001f14:	d004      	beq.n	8001f20 <pwm_lld_serve_interrupt+0x80>
    pwmp->config->channels[2].callback(pwmp);
 8001f16:	9b01      	ldr	r3, [sp, #4]
 8001f18:	685b      	ldr	r3, [r3, #4]
 8001f1a:	6a1b      	ldr	r3, [r3, #32]
 8001f1c:	9801      	ldr	r0, [sp, #4]
 8001f1e:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001f20:	9b03      	ldr	r3, [sp, #12]
 8001f22:	f003 0310 	and.w	r3, r3, #16
 8001f26:	2b00      	cmp	r3, #0
 8001f28:	d009      	beq.n	8001f3e <pwm_lld_serve_interrupt+0x9e>
      (pwmp->config->channels[3].callback != NULL))
 8001f2a:	9b01      	ldr	r3, [sp, #4]
 8001f2c:	685b      	ldr	r3, [r3, #4]
 8001f2e:	6a9b      	ldr	r3, [r3, #40]	; 0x28
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 8001f30:	2b00      	cmp	r3, #0
 8001f32:	d004      	beq.n	8001f3e <pwm_lld_serve_interrupt+0x9e>
    pwmp->config->channels[3].callback(pwmp);
 8001f34:	9b01      	ldr	r3, [sp, #4]
 8001f36:	685b      	ldr	r3, [r3, #4]
 8001f38:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8001f3a:	9801      	ldr	r0, [sp, #4]
 8001f3c:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 8001f3e:	9b03      	ldr	r3, [sp, #12]
 8001f40:	f003 0301 	and.w	r3, r3, #1
 8001f44:	2b00      	cmp	r3, #0
 8001f46:	d009      	beq.n	8001f5c <pwm_lld_serve_interrupt+0xbc>
 8001f48:	9b01      	ldr	r3, [sp, #4]
 8001f4a:	685b      	ldr	r3, [r3, #4]
 8001f4c:	689b      	ldr	r3, [r3, #8]
 8001f4e:	2b00      	cmp	r3, #0
 8001f50:	d004      	beq.n	8001f5c <pwm_lld_serve_interrupt+0xbc>
    pwmp->config->callback(pwmp);
 8001f52:	9b01      	ldr	r3, [sp, #4]
 8001f54:	685b      	ldr	r3, [r3, #4]
 8001f56:	689b      	ldr	r3, [r3, #8]
 8001f58:	9801      	ldr	r0, [sp, #4]
 8001f5a:	4798      	blx	r3
}
 8001f5c:	bf00      	nop
 8001f5e:	b005      	add	sp, #20
 8001f60:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08001f70 <gpio_init>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void gpio_init(stm32_gpio_t *gpiop, const gpio_setup_t *config) {
 8001f70:	b082      	sub	sp, #8
 8001f72:	9001      	str	r0, [sp, #4]
 8001f74:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8001f76:	9b00      	ldr	r3, [sp, #0]
 8001f78:	685a      	ldr	r2, [r3, #4]
 8001f7a:	9b01      	ldr	r3, [sp, #4]
 8001f7c:	605a      	str	r2, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001f7e:	9b00      	ldr	r3, [sp, #0]
 8001f80:	689a      	ldr	r2, [r3, #8]
 8001f82:	9b01      	ldr	r3, [sp, #4]
 8001f84:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8001f86:	9b00      	ldr	r3, [sp, #0]
 8001f88:	68da      	ldr	r2, [r3, #12]
 8001f8a:	9b01      	ldr	r3, [sp, #4]
 8001f8c:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8001f8e:	9b00      	ldr	r3, [sp, #0]
 8001f90:	691a      	ldr	r2, [r3, #16]
 8001f92:	9b01      	ldr	r3, [sp, #4]
 8001f94:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8001f96:	9b00      	ldr	r3, [sp, #0]
 8001f98:	695a      	ldr	r2, [r3, #20]
 8001f9a:	9b01      	ldr	r3, [sp, #4]
 8001f9c:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8001f9e:	9b00      	ldr	r3, [sp, #0]
 8001fa0:	699a      	ldr	r2, [r3, #24]
 8001fa2:	9b01      	ldr	r3, [sp, #4]
 8001fa4:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001fa6:	9b00      	ldr	r3, [sp, #0]
 8001fa8:	681a      	ldr	r2, [r3, #0]
 8001faa:	9b01      	ldr	r3, [sp, #4]
 8001fac:	601a      	str	r2, [r3, #0]
}
 8001fae:	bf00      	nop
 8001fb0:	b002      	add	sp, #8
 8001fb2:	4770      	bx	lr
	...

08001fc0 <stm32_gpio_init>:

static void stm32_gpio_init(void) {
 8001fc0:	b508      	push	{r3, lr}

  /* Enabling GPIO-related clocks, the mask comes from the
     registry header file.*/
  rccResetAHB1(STM32_GPIO_EN_MASK);
 8001fc2:	4b25      	ldr	r3, [pc, #148]	; (8002058 <stm32_gpio_init+0x98>)
 8001fc4:	691b      	ldr	r3, [r3, #16]
 8001fc6:	4a24      	ldr	r2, [pc, #144]	; (8002058 <stm32_gpio_init+0x98>)
 8001fc8:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8001fcc:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8001fd0:	6113      	str	r3, [r2, #16]
 8001fd2:	4b21      	ldr	r3, [pc, #132]	; (8002058 <stm32_gpio_init+0x98>)
 8001fd4:	691b      	ldr	r3, [r3, #16]
 8001fd6:	4a20      	ldr	r2, [pc, #128]	; (8002058 <stm32_gpio_init+0x98>)
 8001fd8:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8001fdc:	f023 0301 	bic.w	r3, r3, #1
 8001fe0:	6113      	str	r3, [r2, #16]
 8001fe2:	4b1d      	ldr	r3, [pc, #116]	; (8002058 <stm32_gpio_init+0x98>)
 8001fe4:	691b      	ldr	r3, [r3, #16]
  rccEnableAHB1(STM32_GPIO_EN_MASK, true);
 8001fe6:	4b1c      	ldr	r3, [pc, #112]	; (8002058 <stm32_gpio_init+0x98>)
 8001fe8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8001fea:	4a1b      	ldr	r2, [pc, #108]	; (8002058 <stm32_gpio_init+0x98>)
 8001fec:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8001ff0:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8001ff4:	6313      	str	r3, [r2, #48]	; 0x30
 8001ff6:	4b18      	ldr	r3, [pc, #96]	; (8002058 <stm32_gpio_init+0x98>)
 8001ff8:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 8001ffa:	4a17      	ldr	r2, [pc, #92]	; (8002058 <stm32_gpio_init+0x98>)
 8001ffc:	ea6f 2353 	mvn.w	r3, r3, lsr #9
 8002000:	ea6f 2343 	mvn.w	r3, r3, lsl #9
 8002004:	6513      	str	r3, [r2, #80]	; 0x50
 8002006:	4b14      	ldr	r3, [pc, #80]	; (8002058 <stm32_gpio_init+0x98>)
 8002008:	6d1b      	ldr	r3, [r3, #80]	; 0x50

  /* Initializing all the defined GPIO ports.*/
#if STM32_HAS_GPIOA
  gpio_init(GPIOA, &gpio_default_config.PAData);
 800200a:	4914      	ldr	r1, [pc, #80]	; (800205c <stm32_gpio_init+0x9c>)
 800200c:	4814      	ldr	r0, [pc, #80]	; (8002060 <stm32_gpio_init+0xa0>)
 800200e:	f7ff ffaf 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOB
  gpio_init(GPIOB, &gpio_default_config.PBData);
 8002012:	4914      	ldr	r1, [pc, #80]	; (8002064 <stm32_gpio_init+0xa4>)
 8002014:	4814      	ldr	r0, [pc, #80]	; (8002068 <stm32_gpio_init+0xa8>)
 8002016:	f7ff ffab 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOC
  gpio_init(GPIOC, &gpio_default_config.PCData);
 800201a:	4914      	ldr	r1, [pc, #80]	; (800206c <stm32_gpio_init+0xac>)
 800201c:	4814      	ldr	r0, [pc, #80]	; (8002070 <stm32_gpio_init+0xb0>)
 800201e:	f7ff ffa7 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOD
  gpio_init(GPIOD, &gpio_default_config.PDData);
 8002022:	4914      	ldr	r1, [pc, #80]	; (8002074 <stm32_gpio_init+0xb4>)
 8002024:	4814      	ldr	r0, [pc, #80]	; (8002078 <stm32_gpio_init+0xb8>)
 8002026:	f7ff ffa3 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOE
  gpio_init(GPIOE, &gpio_default_config.PEData);
 800202a:	4914      	ldr	r1, [pc, #80]	; (800207c <stm32_gpio_init+0xbc>)
 800202c:	4814      	ldr	r0, [pc, #80]	; (8002080 <stm32_gpio_init+0xc0>)
 800202e:	f7ff ff9f 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOF
  gpio_init(GPIOF, &gpio_default_config.PFData);
 8002032:	4914      	ldr	r1, [pc, #80]	; (8002084 <stm32_gpio_init+0xc4>)
 8002034:	4814      	ldr	r0, [pc, #80]	; (8002088 <stm32_gpio_init+0xc8>)
 8002036:	f7ff ff9b 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOG
  gpio_init(GPIOG, &gpio_default_config.PGData);
 800203a:	4914      	ldr	r1, [pc, #80]	; (800208c <stm32_gpio_init+0xcc>)
 800203c:	4814      	ldr	r0, [pc, #80]	; (8002090 <stm32_gpio_init+0xd0>)
 800203e:	f7ff ff97 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOH
  gpio_init(GPIOH, &gpio_default_config.PHData);
 8002042:	4914      	ldr	r1, [pc, #80]	; (8002094 <stm32_gpio_init+0xd4>)
 8002044:	4814      	ldr	r0, [pc, #80]	; (8002098 <stm32_gpio_init+0xd8>)
 8002046:	f7ff ff93 	bl	8001f70 <gpio_init>
#endif
#if STM32_HAS_GPIOI
  gpio_init(GPIOI, &gpio_default_config.PIData);
 800204a:	4914      	ldr	r1, [pc, #80]	; (800209c <stm32_gpio_init+0xdc>)
 800204c:	4814      	ldr	r0, [pc, #80]	; (80020a0 <stm32_gpio_init+0xe0>)
 800204e:	f7ff ff8f 	bl	8001f70 <gpio_init>
  gpio_init(GPIOJ, &gpio_default_config.PJData);
#endif
#if STM32_HAS_GPIOK
  gpio_init(GPIOK, &gpio_default_config.PKData);
#endif
}
 8002052:	bf00      	nop
 8002054:	bd08      	pop	{r3, pc}
 8002056:	bf00      	nop
 8002058:	40023800 	.word	0x40023800
 800205c:	08004514 	.word	0x08004514
 8002060:	40020000 	.word	0x40020000
 8002064:	08004530 	.word	0x08004530
 8002068:	40020400 	.word	0x40020400
 800206c:	0800454c 	.word	0x0800454c
 8002070:	40020800 	.word	0x40020800
 8002074:	08004568 	.word	0x08004568
 8002078:	40020c00 	.word	0x40020c00
 800207c:	08004584 	.word	0x08004584
 8002080:	40021000 	.word	0x40021000
 8002084:	080045a0 	.word	0x080045a0
 8002088:	40021400 	.word	0x40021400
 800208c:	080045bc 	.word	0x080045bc
 8002090:	40021800 	.word	0x40021800
 8002094:	080045d8 	.word	0x080045d8
 8002098:	40021c00 	.word	0x40021c00
 800209c:	080045f4 	.word	0x080045f4
 80020a0:	40022000 	.word	0x40022000
	...

080020b0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details GPIO ports and system clocks are initialized before everything
 *          else.
 */
void __early_init(void) {
 80020b0:	b508      	push	{r3, lr}

  stm32_gpio_init();
 80020b2:	f7ff ff85 	bl	8001fc0 <stm32_gpio_init>
  stm32_clock_init();
 80020b6:	f7ff f8a3 	bl	8001200 <stm32_clock_init>
}
 80020ba:	bf00      	nop
 80020bc:	bd08      	pop	{r3, pc}
 80020be:	bf00      	nop

080020c0 <boardInit>:
 * @brief   Board-specific initialization code.
 * @note    You can add your board-specific code here.
 */
void boardInit(void) {

}
 80020c0:	bf00      	nop
 80020c2:	4770      	bx	lr
	...

080020d0 <__tm_calibration_object_init>:
 *
 * @param[out] tcp      pointer to the @p tm_calibration_t structure
 *
 * @notapi
 */
static inline void __tm_calibration_object_init(tm_calibration_t *tcp) {
 80020d0:	b500      	push	{lr}
 80020d2:	b08b      	sub	sp, #44	; 0x2c
 80020d4:	9001      	str	r0, [sp, #4]
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  tcp->offset = (rtcnt_t)0;
 80020d6:	9b01      	ldr	r3, [sp, #4]
 80020d8:	2200      	movs	r2, #0
 80020da:	601a      	str	r2, [r3, #0]
  chTMObjectInit(&tm);
 80020dc:	ab02      	add	r3, sp, #8
 80020de:	4618      	mov	r0, r3
 80020e0:	f001 fd26 	bl	8003b30 <chTMObjectInit>
  i = TM_CALIBRATION_LOOP;
 80020e4:	2304      	movs	r3, #4
 80020e6:	9309      	str	r3, [sp, #36]	; 0x24
  do {
    chTMStartMeasurementX(&tm);
 80020e8:	ab02      	add	r3, sp, #8
 80020ea:	4618      	mov	r0, r3
 80020ec:	f001 fd40 	bl	8003b70 <chTMStartMeasurementX>
    chTMStopMeasurementX(&tm);
 80020f0:	ab02      	add	r3, sp, #8
 80020f2:	4618      	mov	r0, r3
 80020f4:	f001 fd4c 	bl	8003b90 <chTMStopMeasurementX>
    i--;
 80020f8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80020fa:	3b01      	subs	r3, #1
 80020fc:	9309      	str	r3, [sp, #36]	; 0x24
  } while (i > 0U);
 80020fe:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8002100:	2b00      	cmp	r3, #0
 8002102:	d1f1      	bne.n	80020e8 <__tm_calibration_object_init+0x18>
  tcp->offset = tm.best;
 8002104:	9a02      	ldr	r2, [sp, #8]
 8002106:	9b01      	ldr	r3, [sp, #4]
 8002108:	601a      	str	r2, [r3, #0]
}
 800210a:	bf00      	nop
 800210c:	b00b      	add	sp, #44	; 0x2c
 800210e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002112:	bf00      	nop
	...

08002120 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8002120:	b500      	push	{lr}
 8002122:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8002124:	f000 f8e4 	bl	80022f0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8002128:	4b12      	ldr	r3, [pc, #72]	; (8002174 <chSysUnlock+0x54>)
 800212a:	681b      	ldr	r3, [r3, #0]
 800212c:	4a11      	ldr	r2, [pc, #68]	; (8002174 <chSysUnlock+0x54>)
 800212e:	4293      	cmp	r3, r2
 8002130:	bf14      	ite	ne
 8002132:	2301      	movne	r3, #1
 8002134:	2300      	moveq	r3, #0
 8002136:	b2db      	uxtb	r3, r3
 8002138:	2b00      	cmp	r3, #0
 800213a:	d00f      	beq.n	800215c <chSysUnlock+0x3c>
 800213c:	4b0d      	ldr	r3, [pc, #52]	; (8002174 <chSysUnlock+0x54>)
 800213e:	68db      	ldr	r3, [r3, #12]
 8002140:	689a      	ldr	r2, [r3, #8]
 8002142:	4b0c      	ldr	r3, [pc, #48]	; (8002174 <chSysUnlock+0x54>)
 8002144:	681b      	ldr	r3, [r3, #0]
 8002146:	689b      	ldr	r3, [r3, #8]
 8002148:	429a      	cmp	r2, r3
 800214a:	bf34      	ite	cc
 800214c:	2301      	movcc	r3, #1
 800214e:	2300      	movcs	r3, #0
 8002150:	b2db      	uxtb	r3, r3
 8002152:	2b00      	cmp	r3, #0
 8002154:	d002      	beq.n	800215c <chSysUnlock+0x3c>
 8002156:	4808      	ldr	r0, [pc, #32]	; (8002178 <chSysUnlock+0x58>)
 8002158:	f000 f852 	bl	8002200 <chSysHalt>
 800215c:	2300      	movs	r3, #0
 800215e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002160:	9b01      	ldr	r3, [sp, #4]
 8002162:	f383 8811 	msr	BASEPRI, r3
}
 8002166:	bf00      	nop
}
 8002168:	bf00      	nop
}
 800216a:	bf00      	nop
 800216c:	b003      	add	sp, #12
 800216e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002172:	bf00      	nop
 8002174:	200008a0 	.word	0x200008a0
 8002178:	08004624 	.word	0x08004624
 800217c:	00000000 	.word	0x00000000

08002180 <__oslib_init>:
/**
 * @brief   Initialization of all library modules.
 *
 * @notapi
 */
static inline void __oslib_init(void) {
 8002180:	b508      	push	{r3, lr}

#if CH_CFG_USE_MEMCORE == TRUE
  __core_init();
 8002182:	f001 fd8d 	bl	8003ca0 <__core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  __heap_init();
 8002186:	f001 fdfb 	bl	8003d80 <__heap_init>
#endif
#if CH_CFG_USE_FACTORY == TRUE
  __factory_init();
 800218a:	f001 fe91 	bl	8003eb0 <__factory_init>
#endif
}
 800218e:	bf00      	nop
 8002190:	bd08      	pop	{r3, pc}
 8002192:	bf00      	nop
	...

080021a0 <chSysInit>:
 *          interrupts are enabled.
 * @post    the system is in @p ch_sys_running state.
 *
 * @special
 */
void chSysInit(void) {
 80021a0:	b500      	push	{lr}
 80021a2:	b083      	sub	sp, #12
  unsigned i;

  /* System object initialization.*/
  ch_system.state = ch_sys_initializing;
 80021a4:	4b11      	ldr	r3, [pc, #68]	; (80021ec <chSysInit+0x4c>)
 80021a6:	2201      	movs	r2, #1
 80021a8:	701a      	strb	r2, [r3, #0]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80021aa:	2300      	movs	r3, #0
 80021ac:	9301      	str	r3, [sp, #4]
 80021ae:	e008      	b.n	80021c2 <chSysInit+0x22>
    ch_system.instances[i] = NULL;
 80021b0:	4a0e      	ldr	r2, [pc, #56]	; (80021ec <chSysInit+0x4c>)
 80021b2:	9b01      	ldr	r3, [sp, #4]
 80021b4:	009b      	lsls	r3, r3, #2
 80021b6:	4413      	add	r3, r2
 80021b8:	2200      	movs	r2, #0
 80021ba:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)PORT_CORES_NUMBER; i++) {
 80021bc:	9b01      	ldr	r3, [sp, #4]
 80021be:	3301      	adds	r3, #1
 80021c0:	9301      	str	r3, [sp, #4]
 80021c2:	9b01      	ldr	r3, [sp, #4]
 80021c4:	2b00      	cmp	r3, #0
 80021c6:	d0f3      	beq.n	80021b0 <chSysInit+0x10>
  }

#if CH_CFG_USE_TM == TRUE
  /* Time Measurement calibration.*/
  __tm_calibration_object_init(&ch_system.tmc);
 80021c8:	4809      	ldr	r0, [pc, #36]	; (80021f0 <chSysInit+0x50>)
 80021ca:	f7ff ff81 	bl	80020d0 <__tm_calibration_object_init>

  /* User system initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* OS library modules.*/
  __oslib_init();
 80021ce:	f7ff ffd7 	bl	8002180 <__oslib_init>

  /* Initializing default OS instance.*/
  chInstanceObjectInit(&ch0, &ch_core0_cfg);
 80021d2:	4908      	ldr	r1, [pc, #32]	; (80021f4 <chSysInit+0x54>)
 80021d4:	4808      	ldr	r0, [pc, #32]	; (80021f8 <chSysInit+0x58>)
 80021d6:	f001 f9d3 	bl	8003580 <chInstanceObjectInit>

  /* It is alive now.*/
  ch_system.state = ch_sys_running;
 80021da:	4b04      	ldr	r3, [pc, #16]	; (80021ec <chSysInit+0x4c>)
 80021dc:	2202      	movs	r2, #2
 80021de:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 80021e0:	f7ff ff9e 	bl	8002120 <chSysUnlock>
}
 80021e4:	bf00      	nop
 80021e6:	b003      	add	sp, #12
 80021e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80021ec:	20000890 	.word	0x20000890
 80021f0:	20000898 	.word	0x20000898
 80021f4:	08004610 	.word	0x08004610
 80021f8:	200008a0 	.word	0x200008a0
 80021fc:	00000000 	.word	0x00000000

08002200 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8002200:	b500      	push	{lr}
 8002202:	b083      	sub	sp, #12
 8002204:	9001      	str	r0, [sp, #4]
  __ASM volatile ("cpsid i" : : : "memory");
 8002206:	b672      	cpsid	i
}
 8002208:	bf00      	nop
 *          the priority mask to level 0.
 */
__STATIC_FORCEINLINE void port_disable(void) {

  __disable_irq();
}
 800220a:	bf00      	nop

  port_disable();

  /* Logging the event.*/
  __trace_halt(reason);
 800220c:	9801      	ldr	r0, [sp, #4]
 800220e:	f000 faff 	bl	8002810 <__trace_halt>

  /* Pointing to the passed message.*/
  currcore->dbg.panic_msg = reason;
 8002212:	4a04      	ldr	r2, [pc, #16]	; (8002224 <chSysHalt+0x24>)
 8002214:	9b01      	ldr	r3, [sp, #4]
 8002216:	f8c2 3084 	str.w	r3, [r2, #132]	; 0x84
     via some inter-core messaging or other means.*/
  PORT_SYSTEM_HALT_HOOK();
#endif

  /* Entering the halted state.*/
  ch_system.state = ch_sys_halted;
 800221a:	4b03      	ldr	r3, [pc, #12]	; (8002228 <chSysHalt+0x28>)
 800221c:	2203      	movs	r2, #3
 800221e:	701a      	strb	r2, [r3, #0]

  /* Harmless infinite loop.*/
  while (true) {
 8002220:	e7fe      	b.n	8002220 <chSysHalt+0x20>
 8002222:	bf00      	nop
 8002224:	200008a0 	.word	0x200008a0
 8002228:	20000890 	.word	0x20000890
 800222c:	00000000 	.word	0x00000000

08002230 <chSysGetIdleThreadX>:
 *
 * @return              Pointer to the idle thread.
 *
 * @xclass
 */
thread_t *chSysGetIdleThreadX(void) {
 8002230:	b500      	push	{lr}
 8002232:	b083      	sub	sp, #12
  thread_t *tp = threadref(currcore->rlist.pqueue.prev);
 8002234:	4b09      	ldr	r3, [pc, #36]	; (800225c <chSysGetIdleThreadX+0x2c>)
 8002236:	685b      	ldr	r3, [r3, #4]
 8002238:	9301      	str	r3, [sp, #4]

  chDbgAssert(tp->hdr.pqueue.prio == IDLEPRIO, "not idle thread");
 800223a:	9b01      	ldr	r3, [sp, #4]
 800223c:	689b      	ldr	r3, [r3, #8]
 800223e:	2b01      	cmp	r3, #1
 8002240:	bf14      	ite	ne
 8002242:	2301      	movne	r3, #1
 8002244:	2300      	moveq	r3, #0
 8002246:	b2db      	uxtb	r3, r3
 8002248:	2b00      	cmp	r3, #0
 800224a:	d002      	beq.n	8002252 <chSysGetIdleThreadX+0x22>
 800224c:	4804      	ldr	r0, [pc, #16]	; (8002260 <chSysGetIdleThreadX+0x30>)
 800224e:	f7ff ffd7 	bl	8002200 <chSysHalt>

  return tp;
 8002252:	9b01      	ldr	r3, [sp, #4]
}
 8002254:	4618      	mov	r0, r3
 8002256:	b003      	add	sp, #12
 8002258:	f85d fb04 	ldr.w	pc, [sp], #4
 800225c:	200008a0 	.word	0x200008a0
 8002260:	08004630 	.word	0x08004630
	...

08002270 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8002270:	b508      	push	{r3, lr}
#if (CH_CFG_TIME_QUANTUM > 0) || (CH_DBG_THREADS_PROFILING == TRUE)
  thread_t *currtp = chThdGetSelfX();
#endif

  chDbgCheckClassI();
 8002272:	f000 f92d 	bl	80024d0 <chDbgCheckClassI>
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currtp->time++;
#endif
  chVTDoTickI();
 8002276:	f000 fdcb 	bl	8002e10 <chVTDoTickI>
  CH_CFG_SYSTEM_TICK_HOOK();
}
 800227a:	bf00      	nop
 800227c:	bd08      	pop	{r3, pc}
 800227e:	bf00      	nop

08002280 <chRFCUCollectFaultsI>:
/**
 * @brief   Adds fault flags to the current mask.
 *
 * @param[in] mask      fault flags to be added
 */
void chRFCUCollectFaultsI(rfcu_mask_t mask) {
 8002280:	b082      	sub	sp, #8
 8002282:	9001      	str	r0, [sp, #4]

#if CH_CFG_SMP_MODE == FALSE
  currcore->rfcu.mask |= mask;
 8002284:	4b04      	ldr	r3, [pc, #16]	; (8002298 <chRFCUCollectFaultsI+0x18>)
 8002286:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002288:	9b01      	ldr	r3, [sp, #4]
 800228a:	4313      	orrs	r3, r2
 800228c:	4a02      	ldr	r2, [pc, #8]	; (8002298 <chRFCUCollectFaultsI+0x18>)
 800228e:	6353      	str	r3, [r2, #52]	; 0x34
#else
  ch_system.rfcu.mask |= mask;
#endif

  CH_CFG_RUNTIME_FAULTS_HOOK(mask);
}
 8002290:	bf00      	nop
 8002292:	b002      	add	sp, #8
 8002294:	4770      	bx	lr
 8002296:	bf00      	nop
 8002298:	200008a0 	.word	0x200008a0
 800229c:	00000000 	.word	0x00000000

080022a0 <__dbg_check_lock>:
/**
 * @brief   Guard code for @p chSysLock().
 *
 * @notapi
 */
void __dbg_check_lock(void) {
 80022a0:	b500      	push	{lr}
 80022a2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80022a4:	4b10      	ldr	r3, [pc, #64]	; (80022e8 <__dbg_check_lock+0x48>)
 80022a6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80022a8:	9b01      	ldr	r3, [sp, #4]
 80022aa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80022ae:	2b00      	cmp	r3, #0
 80022b0:	bf14      	ite	ne
 80022b2:	2301      	movne	r3, #1
 80022b4:	2300      	moveq	r3, #0
 80022b6:	b2db      	uxtb	r3, r3
 80022b8:	2b00      	cmp	r3, #0
 80022ba:	d109      	bne.n	80022d0 <__dbg_check_lock+0x30>
 80022bc:	9b01      	ldr	r3, [sp, #4]
 80022be:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80022c2:	2b00      	cmp	r3, #0
 80022c4:	bf14      	ite	ne
 80022c6:	2301      	movne	r3, #1
 80022c8:	2300      	moveq	r3, #0
 80022ca:	b2db      	uxtb	r3, r3
 80022cc:	2b00      	cmp	r3, #0
 80022ce:	d002      	beq.n	80022d6 <__dbg_check_lock+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#4");
 80022d0:	4806      	ldr	r0, [pc, #24]	; (80022ec <__dbg_check_lock+0x4c>)
 80022d2:	f7ff ff95 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 80022d6:	9b01      	ldr	r3, [sp, #4]
 80022d8:	2201      	movs	r2, #1
 80022da:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 80022de:	bf00      	nop
 80022e0:	b003      	add	sp, #12
 80022e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80022e6:	bf00      	nop
 80022e8:	200008a0 	.word	0x200008a0
 80022ec:	080042c8 	.word	0x080042c8

080022f0 <__dbg_check_unlock>:
/**
 * @brief   Guard code for @p chSysUnlock().
 *
 * @notapi
 */
void __dbg_check_unlock(void) {
 80022f0:	b500      	push	{lr}
 80022f2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80022f4:	4b10      	ldr	r3, [pc, #64]	; (8002338 <__dbg_check_unlock+0x48>)
 80022f6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 80022f8:	9b01      	ldr	r3, [sp, #4]
 80022fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80022fe:	2b00      	cmp	r3, #0
 8002300:	bf14      	ite	ne
 8002302:	2301      	movne	r3, #1
 8002304:	2300      	moveq	r3, #0
 8002306:	b2db      	uxtb	r3, r3
 8002308:	2b00      	cmp	r3, #0
 800230a:	d109      	bne.n	8002320 <__dbg_check_unlock+0x30>
 800230c:	9b01      	ldr	r3, [sp, #4]
 800230e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002312:	2b00      	cmp	r3, #0
 8002314:	bfd4      	ite	le
 8002316:	2301      	movle	r3, #1
 8002318:	2300      	movgt	r3, #0
 800231a:	b2db      	uxtb	r3, r3
 800231c:	2b00      	cmp	r3, #0
 800231e:	d002      	beq.n	8002326 <__dbg_check_unlock+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#5");
 8002320:	4806      	ldr	r0, [pc, #24]	; (800233c <__dbg_check_unlock+0x4c>)
 8002322:	f7ff ff6d 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 8002326:	9b01      	ldr	r3, [sp, #4]
 8002328:	2200      	movs	r2, #0
 800232a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 800232e:	bf00      	nop
 8002330:	b003      	add	sp, #12
 8002332:	f85d fb04 	ldr.w	pc, [sp], #4
 8002336:	bf00      	nop
 8002338:	200008a0 	.word	0x200008a0
 800233c:	080042d0 	.word	0x080042d0

08002340 <__dbg_check_lock_from_isr>:
/**
 * @brief   Guard code for @p chSysLockFromIsr().
 *
 * @notapi
 */
void __dbg_check_lock_from_isr(void) {
 8002340:	b500      	push	{lr}
 8002342:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002344:	4b10      	ldr	r3, [pc, #64]	; (8002388 <__dbg_check_lock_from_isr+0x48>)
 8002346:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002348:	9b01      	ldr	r3, [sp, #4]
 800234a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800234e:	2b00      	cmp	r3, #0
 8002350:	bfd4      	ite	le
 8002352:	2301      	movle	r3, #1
 8002354:	2300      	movgt	r3, #0
 8002356:	b2db      	uxtb	r3, r3
 8002358:	2b00      	cmp	r3, #0
 800235a:	d109      	bne.n	8002370 <__dbg_check_lock_from_isr+0x30>
 800235c:	9b01      	ldr	r3, [sp, #4]
 800235e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002362:	2b00      	cmp	r3, #0
 8002364:	bf14      	ite	ne
 8002366:	2301      	movne	r3, #1
 8002368:	2300      	moveq	r3, #0
 800236a:	b2db      	uxtb	r3, r3
 800236c:	2b00      	cmp	r3, #0
 800236e:	d002      	beq.n	8002376 <__dbg_check_lock_from_isr+0x36>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#6");
 8002370:	4806      	ldr	r0, [pc, #24]	; (800238c <__dbg_check_lock_from_isr+0x4c>)
 8002372:	f7ff ff45 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)1;
 8002376:	9b01      	ldr	r3, [sp, #4]
 8002378:	2201      	movs	r2, #1
 800237a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 800237e:	bf00      	nop
 8002380:	b003      	add	sp, #12
 8002382:	f85d fb04 	ldr.w	pc, [sp], #4
 8002386:	bf00      	nop
 8002388:	200008a0 	.word	0x200008a0
 800238c:	080042d8 	.word	0x080042d8

08002390 <__dbg_check_unlock_from_isr>:
/**
 * @brief   Guard code for @p chSysUnlockFromIsr().
 *
 * @notapi
 */
void __dbg_check_unlock_from_isr(void) {
 8002390:	b500      	push	{lr}
 8002392:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002394:	4b10      	ldr	r3, [pc, #64]	; (80023d8 <__dbg_check_unlock_from_isr+0x48>)
 8002396:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002398:	9b01      	ldr	r3, [sp, #4]
 800239a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800239e:	2b00      	cmp	r3, #0
 80023a0:	bfd4      	ite	le
 80023a2:	2301      	movle	r3, #1
 80023a4:	2300      	movgt	r3, #0
 80023a6:	b2db      	uxtb	r3, r3
 80023a8:	2b00      	cmp	r3, #0
 80023aa:	d109      	bne.n	80023c0 <__dbg_check_unlock_from_isr+0x30>
 80023ac:	9b01      	ldr	r3, [sp, #4]
 80023ae:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80023b2:	2b00      	cmp	r3, #0
 80023b4:	bfd4      	ite	le
 80023b6:	2301      	movle	r3, #1
 80023b8:	2300      	movgt	r3, #0
 80023ba:	b2db      	uxtb	r3, r3
 80023bc:	2b00      	cmp	r3, #0
 80023be:	d002      	beq.n	80023c6 <__dbg_check_unlock_from_isr+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#7");
 80023c0:	4806      	ldr	r0, [pc, #24]	; (80023dc <__dbg_check_unlock_from_isr+0x4c>)
 80023c2:	f7ff ff1d 	bl	8002200 <chSysHalt>
  }
  oip->dbg.lock_cnt = (cnt_t)0;
 80023c6:	9b01      	ldr	r3, [sp, #4]
 80023c8:	2200      	movs	r2, #0
 80023ca:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
}
 80023ce:	bf00      	nop
 80023d0:	b003      	add	sp, #12
 80023d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80023d6:	bf00      	nop
 80023d8:	200008a0 	.word	0x200008a0
 80023dc:	080042e0 	.word	0x080042e0

080023e0 <__dbg_check_enter_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_PROLOGUE().
 *
 * @notapi
 */
void __dbg_check_enter_isr(void) {
 80023e0:	b500      	push	{lr}
 80023e2:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 80023e4:	4b18      	ldr	r3, [pc, #96]	; (8002448 <__dbg_check_enter_isr+0x68>)
 80023e6:	9303      	str	r3, [sp, #12]
 80023e8:	2330      	movs	r3, #48	; 0x30
 80023ea:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80023ec:	9b02      	ldr	r3, [sp, #8]
 80023ee:	f383 8811 	msr	BASEPRI, r3
}
 80023f2:	bf00      	nop
}
 80023f4:	bf00      	nop
}
 80023f6:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80023f8:	9b03      	ldr	r3, [sp, #12]
 80023fa:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80023fe:	0fdb      	lsrs	r3, r3, #31
 8002400:	b2db      	uxtb	r3, r3
 8002402:	2b00      	cmp	r3, #0
 8002404:	d109      	bne.n	800241a <__dbg_check_enter_isr+0x3a>
 8002406:	9b03      	ldr	r3, [sp, #12]
 8002408:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 800240c:	2b00      	cmp	r3, #0
 800240e:	bf14      	ite	ne
 8002410:	2301      	movne	r3, #1
 8002412:	2300      	moveq	r3, #0
 8002414:	b2db      	uxtb	r3, r3
 8002416:	2b00      	cmp	r3, #0
 8002418:	d002      	beq.n	8002420 <__dbg_check_enter_isr+0x40>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#8");
 800241a:	480c      	ldr	r0, [pc, #48]	; (800244c <__dbg_check_enter_isr+0x6c>)
 800241c:	f7ff fef0 	bl	8002200 <chSysHalt>
  }
  oip->dbg.isr_cnt++;
 8002420:	9b03      	ldr	r3, [sp, #12]
 8002422:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002426:	1c5a      	adds	r2, r3, #1
 8002428:	9b03      	ldr	r3, [sp, #12]
 800242a:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 800242e:	2300      	movs	r3, #0
 8002430:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002432:	9b01      	ldr	r3, [sp, #4]
 8002434:	f383 8811 	msr	BASEPRI, r3
}
 8002438:	bf00      	nop
}
 800243a:	bf00      	nop
}
 800243c:	bf00      	nop
  port_unlock_from_isr();
}
 800243e:	bf00      	nop
 8002440:	b005      	add	sp, #20
 8002442:	f85d fb04 	ldr.w	pc, [sp], #4
 8002446:	bf00      	nop
 8002448:	200008a0 	.word	0x200008a0
 800244c:	080042e8 	.word	0x080042e8

08002450 <__dbg_check_leave_isr>:
/**
 * @brief   Guard code for @p CH_IRQ_EPILOGUE().
 *
 * @notapi
 */
void __dbg_check_leave_isr(void) {
 8002450:	b500      	push	{lr}
 8002452:	b085      	sub	sp, #20
  os_instance_t *oip = currcore;
 8002454:	4b19      	ldr	r3, [pc, #100]	; (80024bc <__dbg_check_leave_isr+0x6c>)
 8002456:	9303      	str	r3, [sp, #12]
 8002458:	2330      	movs	r3, #48	; 0x30
 800245a:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800245c:	9b02      	ldr	r3, [sp, #8]
 800245e:	f383 8811 	msr	BASEPRI, r3
}
 8002462:	bf00      	nop
}
 8002464:	bf00      	nop
}
 8002466:	bf00      	nop

  port_lock_from_isr();
  if (unlikely((oip->dbg.isr_cnt <= (cnt_t)0) ||
 8002468:	9b03      	ldr	r3, [sp, #12]
 800246a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800246e:	2b00      	cmp	r3, #0
 8002470:	bfd4      	ite	le
 8002472:	2301      	movle	r3, #1
 8002474:	2300      	movgt	r3, #0
 8002476:	b2db      	uxtb	r3, r3
 8002478:	2b00      	cmp	r3, #0
 800247a:	d109      	bne.n	8002490 <__dbg_check_leave_isr+0x40>
 800247c:	9b03      	ldr	r3, [sp, #12]
 800247e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002482:	2b00      	cmp	r3, #0
 8002484:	bf14      	ite	ne
 8002486:	2301      	movne	r3, #1
 8002488:	2300      	moveq	r3, #0
 800248a:	b2db      	uxtb	r3, r3
 800248c:	2b00      	cmp	r3, #0
 800248e:	d002      	beq.n	8002496 <__dbg_check_leave_isr+0x46>
               (oip->dbg.lock_cnt != (cnt_t)0))) {
    chSysHalt("SV#9");
 8002490:	480b      	ldr	r0, [pc, #44]	; (80024c0 <__dbg_check_leave_isr+0x70>)
 8002492:	f7ff feb5 	bl	8002200 <chSysHalt>
  }
  oip->dbg.isr_cnt--;
 8002496:	9b03      	ldr	r3, [sp, #12]
 8002498:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800249c:	1e5a      	subs	r2, r3, #1
 800249e:	9b03      	ldr	r3, [sp, #12]
 80024a0:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
 80024a4:	2300      	movs	r3, #0
 80024a6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80024a8:	9b01      	ldr	r3, [sp, #4]
 80024aa:	f383 8811 	msr	BASEPRI, r3
}
 80024ae:	bf00      	nop
}
 80024b0:	bf00      	nop
}
 80024b2:	bf00      	nop
  port_unlock_from_isr();
}
 80024b4:	bf00      	nop
 80024b6:	b005      	add	sp, #20
 80024b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80024bc:	200008a0 	.word	0x200008a0
 80024c0:	080042f0 	.word	0x080042f0
	...

080024d0 <chDbgCheckClassI>:
 *          an I-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassI(void) {
 80024d0:	b500      	push	{lr}
 80024d2:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 80024d4:	4b0c      	ldr	r3, [pc, #48]	; (8002508 <chDbgCheckClassI+0x38>)
 80024d6:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt < (cnt_t)0) ||
 80024d8:	9b01      	ldr	r3, [sp, #4]
 80024da:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 80024de:	0fdb      	lsrs	r3, r3, #31
 80024e0:	b2db      	uxtb	r3, r3
 80024e2:	2b00      	cmp	r3, #0
 80024e4:	d109      	bne.n	80024fa <chDbgCheckClassI+0x2a>
 80024e6:	9b01      	ldr	r3, [sp, #4]
 80024e8:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 80024ec:	2b00      	cmp	r3, #0
 80024ee:	bfd4      	ite	le
 80024f0:	2301      	movle	r3, #1
 80024f2:	2300      	movgt	r3, #0
 80024f4:	b2db      	uxtb	r3, r3
 80024f6:	2b00      	cmp	r3, #0
 80024f8:	d002      	beq.n	8002500 <chDbgCheckClassI+0x30>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#10");
 80024fa:	4804      	ldr	r0, [pc, #16]	; (800250c <chDbgCheckClassI+0x3c>)
 80024fc:	f7ff fe80 	bl	8002200 <chSysHalt>
  }
}
 8002500:	bf00      	nop
 8002502:	b003      	add	sp, #12
 8002504:	f85d fb04 	ldr.w	pc, [sp], #4
 8002508:	200008a0 	.word	0x200008a0
 800250c:	080042f8 	.word	0x080042f8

08002510 <chDbgCheckClassS>:
 *          an S-class API function. A panic is generated if the state is
 *          not compatible.
 *
 * @api
 */
void chDbgCheckClassS(void) {
 8002510:	b500      	push	{lr}
 8002512:	b083      	sub	sp, #12
  os_instance_t *oip = currcore;
 8002514:	4b0e      	ldr	r3, [pc, #56]	; (8002550 <chDbgCheckClassS+0x40>)
 8002516:	9301      	str	r3, [sp, #4]

  if (unlikely((oip->dbg.isr_cnt != (cnt_t)0) ||
 8002518:	9b01      	ldr	r3, [sp, #4]
 800251a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 800251e:	2b00      	cmp	r3, #0
 8002520:	bf14      	ite	ne
 8002522:	2301      	movne	r3, #1
 8002524:	2300      	moveq	r3, #0
 8002526:	b2db      	uxtb	r3, r3
 8002528:	2b00      	cmp	r3, #0
 800252a:	d109      	bne.n	8002540 <chDbgCheckClassS+0x30>
 800252c:	9b01      	ldr	r3, [sp, #4]
 800252e:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8002532:	2b00      	cmp	r3, #0
 8002534:	bfd4      	ite	le
 8002536:	2301      	movle	r3, #1
 8002538:	2300      	movgt	r3, #0
 800253a:	b2db      	uxtb	r3, r3
 800253c:	2b00      	cmp	r3, #0
 800253e:	d002      	beq.n	8002546 <chDbgCheckClassS+0x36>
               (oip->dbg.lock_cnt <= (cnt_t)0))) {
    chSysHalt("SV#11");
 8002540:	4804      	ldr	r0, [pc, #16]	; (8002554 <chDbgCheckClassS+0x44>)
 8002542:	f7ff fe5d 	bl	8002200 <chSysHalt>
  }
}
 8002546:	bf00      	nop
 8002548:	b003      	add	sp, #12
 800254a:	f85d fb04 	ldr.w	pc, [sp], #4
 800254e:	bf00      	nop
 8002550:	200008a0 	.word	0x200008a0
 8002554:	08004300 	.word	0x08004300
	...

08002560 <port_timer_get_time>:
 *
 * @return              The system time.
 *
 * @notapi
 */
static inline systime_t port_timer_get_time(void) {
 8002560:	b508      	push	{r3, lr}

  return stGetCounter();
 8002562:	f7fd ff8d 	bl	8000480 <stGetCounter>
 8002566:	4603      	mov	r3, r0
}
 8002568:	4618      	mov	r0, r3
 800256a:	bd08      	pop	{r3, pc}
 800256c:	0000      	movs	r0, r0
	...

08002570 <chVTGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {
 8002570:	b508      	push	{r3, lr}

#if CH_CFG_ST_TIMEDELTA == 0
  return currcore->vtlist.systime;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
 8002572:	f7ff fff5 	bl	8002560 <port_timer_get_time>
 8002576:	4603      	mov	r3, r0
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002578:	4618      	mov	r0, r3
 800257a:	bd08      	pop	{r3, pc}
 800257c:	0000      	movs	r0, r0
	...

08002580 <trace_next>:
/**
 * @brief   Writes a time stamp and increases the trace buffer pointer.
 *
 * @notapi
 */
NOINLINE static void trace_next(os_instance_t *oip) {
 8002580:	b510      	push	{r4, lr}
 8002582:	b082      	sub	sp, #8
 8002584:	9001      	str	r0, [sp, #4]

  oip->trace_buffer.ptr->time    = chVTGetSystemTimeX();
 8002586:	9b01      	ldr	r3, [sp, #4]
 8002588:	f8d3 4094 	ldr.w	r4, [r3, #148]	; 0x94
 800258c:	f7ff fff0 	bl	8002570 <chVTGetSystemTimeX>
 8002590:	4603      	mov	r3, r0
 8002592:	6063      	str	r3, [r4, #4]
 *
 * @return              The realtime counter value.
 */
__STATIC_FORCEINLINE rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002594:	4b11      	ldr	r3, [pc, #68]	; (80025dc <trace_next+0x5c>)
 8002596:	685b      	ldr	r3, [r3, #4]
#if PORT_SUPPORTS_RT == TRUE
  oip->trace_buffer.ptr->rtstamp = chSysGetRealtimeCounterX();
 8002598:	9a01      	ldr	r2, [sp, #4]
 800259a:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 800259e:	f023 417f 	bic.w	r1, r3, #4278190080	; 0xff000000
 80025a2:	6813      	ldr	r3, [r2, #0]
 80025a4:	f361 231f 	bfi	r3, r1, #8, #24
 80025a8:	6013      	str	r3, [r2, #0]
#endif

  /* Trace hook, useful in order to interface debug tools.*/
  CH_CFG_TRACE_HOOK(oip->trace_buffer.ptr);

  if (++oip->trace_buffer.ptr >= &oip->trace_buffer.buffer[CH_DBG_TRACE_BUFFER_SIZE]) {
 80025aa:	9b01      	ldr	r3, [sp, #4]
 80025ac:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80025b0:	f103 0210 	add.w	r2, r3, #16
 80025b4:	9b01      	ldr	r3, [sp, #4]
 80025b6:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
 80025ba:	9b01      	ldr	r3, [sp, #4]
 80025bc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80025c0:	9b01      	ldr	r3, [sp, #4]
 80025c2:	f603 0398 	addw	r3, r3, #2200	; 0x898
 80025c6:	429a      	cmp	r2, r3
 80025c8:	d305      	bcc.n	80025d6 <trace_next+0x56>
    oip->trace_buffer.ptr = &oip->trace_buffer.buffer[0];
 80025ca:	9b01      	ldr	r3, [sp, #4]
 80025cc:	f103 0298 	add.w	r2, r3, #152	; 0x98
 80025d0:	9b01      	ldr	r3, [sp, #4]
 80025d2:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  }
}
 80025d6:	bf00      	nop
 80025d8:	b002      	add	sp, #8
 80025da:	bd10      	pop	{r4, pc}
 80025dc:	e0001000 	.word	0xe0001000

080025e0 <__trace_object_init>:
 *
 * @param[out] tbp      pointer to the @p trace_buffer_t structure
 *
 * @notapi
 */
void __trace_object_init(trace_buffer_t *tbp) {
 80025e0:	b084      	sub	sp, #16
 80025e2:	9001      	str	r0, [sp, #4]
  unsigned i;

  tbp->suspended = (uint16_t)~CH_DBG_TRACE_MASK;
 80025e4:	9b01      	ldr	r3, [sp, #4]
 80025e6:	f64f 72e0 	movw	r2, #65504	; 0xffe0
 80025ea:	801a      	strh	r2, [r3, #0]
  tbp->size      = CH_DBG_TRACE_BUFFER_SIZE;
 80025ec:	9b01      	ldr	r3, [sp, #4]
 80025ee:	2280      	movs	r2, #128	; 0x80
 80025f0:	805a      	strh	r2, [r3, #2]
  tbp->ptr       = &tbp->buffer[0];
 80025f2:	9b01      	ldr	r3, [sp, #4]
 80025f4:	f103 0208 	add.w	r2, r3, #8
 80025f8:	9b01      	ldr	r3, [sp, #4]
 80025fa:	605a      	str	r2, [r3, #4]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 80025fc:	2300      	movs	r3, #0
 80025fe:	9303      	str	r3, [sp, #12]
 8002600:	e00c      	b.n	800261c <__trace_object_init+0x3c>
    tbp->buffer[i].type = CH_TRACE_TYPE_UNUSED;
 8002602:	9a01      	ldr	r2, [sp, #4]
 8002604:	9b03      	ldr	r3, [sp, #12]
 8002606:	011b      	lsls	r3, r3, #4
 8002608:	4413      	add	r3, r2
 800260a:	f103 0208 	add.w	r2, r3, #8
 800260e:	7813      	ldrb	r3, [r2, #0]
 8002610:	f36f 0302 	bfc	r3, #0, #3
 8002614:	7013      	strb	r3, [r2, #0]
  for (i = 0U; i < (unsigned)CH_DBG_TRACE_BUFFER_SIZE; i++) {
 8002616:	9b03      	ldr	r3, [sp, #12]
 8002618:	3301      	adds	r3, #1
 800261a:	9303      	str	r3, [sp, #12]
 800261c:	9b03      	ldr	r3, [sp, #12]
 800261e:	2b7f      	cmp	r3, #127	; 0x7f
 8002620:	d9ef      	bls.n	8002602 <__trace_object_init+0x22>
  }
}
 8002622:	bf00      	nop
 8002624:	bf00      	nop
 8002626:	b004      	add	sp, #16
 8002628:	4770      	bx	lr
 800262a:	bf00      	nop
 800262c:	0000      	movs	r0, r0
	...

08002630 <__trace_ready>:
 * @param[in] tp        the thread that just become ready
 * @param[in] msg       the thread ready message
 *
 * @notapi
 */
void __trace_ready(thread_t *tp, msg_t msg) {
 8002630:	b500      	push	{lr}
 8002632:	b085      	sub	sp, #20
 8002634:	9001      	str	r0, [sp, #4]
 8002636:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 8002638:	4b17      	ldr	r3, [pc, #92]	; (8002698 <__trace_ready+0x68>)
 800263a:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_READY) == 0U) {
 800263c:	9b03      	ldr	r3, [sp, #12]
 800263e:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002642:	f003 0301 	and.w	r3, r3, #1
 8002646:	2b00      	cmp	r3, #0
 8002648:	d122      	bne.n	8002690 <__trace_ready+0x60>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_READY;
 800264a:	9b03      	ldr	r3, [sp, #12]
 800264c:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002650:	7813      	ldrb	r3, [r2, #0]
 8002652:	2101      	movs	r1, #1
 8002654:	f361 0302 	bfi	r3, r1, #0, #3
 8002658:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)tp->state;
 800265a:	9b01      	ldr	r3, [sp, #4]
 800265c:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 8002660:	9b03      	ldr	r3, [sp, #12]
 8002662:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 8002666:	460b      	mov	r3, r1
 8002668:	f003 031f 	and.w	r3, r3, #31
 800266c:	b2d9      	uxtb	r1, r3
 800266e:	7813      	ldrb	r3, [r2, #0]
 8002670:	f361 03c7 	bfi	r3, r1, #3, #5
 8002674:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.rdy.tp    = tp;
 8002676:	9b03      	ldr	r3, [sp, #12]
 8002678:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800267c:	9a01      	ldr	r2, [sp, #4]
 800267e:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.rdy.msg   = msg;
 8002680:	9b03      	ldr	r3, [sp, #12]
 8002682:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8002686:	9a00      	ldr	r2, [sp, #0]
 8002688:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 800268a:	9803      	ldr	r0, [sp, #12]
 800268c:	f7ff ff78 	bl	8002580 <trace_next>
  }
}
 8002690:	bf00      	nop
 8002692:	b005      	add	sp, #20
 8002694:	f85d fb04 	ldr.w	pc, [sp], #4
 8002698:	200008a0 	.word	0x200008a0
 800269c:	00000000 	.word	0x00000000

080026a0 <__trace_switch>:
 * @param[in] ntp       the thread being switched in
 * @param[in] otp       the thread being switched out
 *
 * @notapi
 */
void __trace_switch(thread_t *ntp, thread_t *otp) {
 80026a0:	b500      	push	{lr}
 80026a2:	b085      	sub	sp, #20
 80026a4:	9001      	str	r0, [sp, #4]
 80026a6:	9100      	str	r1, [sp, #0]
  os_instance_t *oip = currcore;
 80026a8:	4b18      	ldr	r3, [pc, #96]	; (800270c <__trace_switch+0x6c>)
 80026aa:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_SWITCH) == 0U) {
 80026ac:	9b03      	ldr	r3, [sp, #12]
 80026ae:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 80026b2:	f003 0302 	and.w	r3, r3, #2
 80026b6:	2b00      	cmp	r3, #0
 80026b8:	d123      	bne.n	8002702 <__trace_switch+0x62>
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_SWITCH;
 80026ba:	9b03      	ldr	r3, [sp, #12]
 80026bc:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80026c0:	7813      	ldrb	r3, [r2, #0]
 80026c2:	2102      	movs	r1, #2
 80026c4:	f361 0302 	bfi	r3, r1, #0, #3
 80026c8:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = (uint8_t)otp->state;
 80026ca:	9b00      	ldr	r3, [sp, #0]
 80026cc:	f893 1024 	ldrb.w	r1, [r3, #36]	; 0x24
 80026d0:	9b03      	ldr	r3, [sp, #12]
 80026d2:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80026d6:	460b      	mov	r3, r1
 80026d8:	f003 031f 	and.w	r3, r3, #31
 80026dc:	b2d9      	uxtb	r1, r3
 80026de:	7813      	ldrb	r3, [r2, #0]
 80026e0:	f361 03c7 	bfi	r3, r1, #3, #5
 80026e4:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.sw.ntp    = ntp;
 80026e6:	9b03      	ldr	r3, [sp, #12]
 80026e8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80026ec:	9a01      	ldr	r2, [sp, #4]
 80026ee:	609a      	str	r2, [r3, #8]
    oip->trace_buffer.ptr->u.sw.wtobjp = otp->u.wtobjp;
 80026f0:	9b03      	ldr	r3, [sp, #12]
 80026f2:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80026f6:	9a00      	ldr	r2, [sp, #0]
 80026f8:	6a92      	ldr	r2, [r2, #40]	; 0x28
 80026fa:	60da      	str	r2, [r3, #12]
    trace_next(oip);
 80026fc:	9803      	ldr	r0, [sp, #12]
 80026fe:	f7ff ff3f 	bl	8002580 <trace_next>
  }
}
 8002702:	bf00      	nop
 8002704:	b005      	add	sp, #20
 8002706:	f85d fb04 	ldr.w	pc, [sp], #4
 800270a:	bf00      	nop
 800270c:	200008a0 	.word	0x200008a0

08002710 <__trace_isr_enter>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_enter(const char *isr) {
 8002710:	b500      	push	{lr}
 8002712:	b087      	sub	sp, #28
 8002714:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002716:	4b1a      	ldr	r3, [pc, #104]	; (8002780 <__trace_isr_enter+0x70>)
 8002718:	9305      	str	r3, [sp, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800271a:	9b05      	ldr	r3, [sp, #20]
 800271c:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002720:	f003 0304 	and.w	r3, r3, #4
 8002724:	2b00      	cmp	r3, #0
 8002726:	d126      	bne.n	8002776 <__trace_isr_enter+0x66>
 8002728:	2330      	movs	r3, #48	; 0x30
 800272a:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800272c:	9b03      	ldr	r3, [sp, #12]
 800272e:	f383 8811 	msr	BASEPRI, r3
}
 8002732:	bf00      	nop
}
 8002734:	bf00      	nop
}
 8002736:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_ENTER;
 8002738:	9b05      	ldr	r3, [sp, #20]
 800273a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800273e:	7813      	ldrb	r3, [r2, #0]
 8002740:	2103      	movs	r1, #3
 8002742:	f361 0302 	bfi	r3, r1, #0, #3
 8002746:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 8002748:	9b05      	ldr	r3, [sp, #20]
 800274a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800274e:	7813      	ldrb	r3, [r2, #0]
 8002750:	f36f 03c7 	bfc	r3, #3, #5
 8002754:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 8002756:	9b05      	ldr	r3, [sp, #20]
 8002758:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800275c:	9a01      	ldr	r2, [sp, #4]
 800275e:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002760:	9805      	ldr	r0, [sp, #20]
 8002762:	f7ff ff0d 	bl	8002580 <trace_next>
 8002766:	2300      	movs	r3, #0
 8002768:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800276a:	9b04      	ldr	r3, [sp, #16]
 800276c:	f383 8811 	msr	BASEPRI, r3
}
 8002770:	bf00      	nop
}
 8002772:	bf00      	nop
}
 8002774:	bf00      	nop
    port_unlock_from_isr();
  }
}
 8002776:	bf00      	nop
 8002778:	b007      	add	sp, #28
 800277a:	f85d fb04 	ldr.w	pc, [sp], #4
 800277e:	bf00      	nop
 8002780:	200008a0 	.word	0x200008a0
	...

08002790 <__trace_isr_leave>:
 *
 * @param[in] isr       name of the isr
 *
 * @notapi
 */
void __trace_isr_leave(const char *isr) {
 8002790:	b500      	push	{lr}
 8002792:	b087      	sub	sp, #28
 8002794:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002796:	4b1a      	ldr	r3, [pc, #104]	; (8002800 <__trace_isr_leave+0x70>)
 8002798:	9305      	str	r3, [sp, #20]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_ISR) == 0U) {
 800279a:	9b05      	ldr	r3, [sp, #20]
 800279c:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 80027a0:	f003 0304 	and.w	r3, r3, #4
 80027a4:	2b00      	cmp	r3, #0
 80027a6:	d126      	bne.n	80027f6 <__trace_isr_leave+0x66>
 80027a8:	2330      	movs	r3, #48	; 0x30
 80027aa:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80027ac:	9b03      	ldr	r3, [sp, #12]
 80027ae:	f383 8811 	msr	BASEPRI, r3
}
 80027b2:	bf00      	nop
}
 80027b4:	bf00      	nop
}
 80027b6:	bf00      	nop
    port_lock_from_isr();
    oip->trace_buffer.ptr->type        = CH_TRACE_TYPE_ISR_LEAVE;
 80027b8:	9b05      	ldr	r3, [sp, #20]
 80027ba:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80027be:	7813      	ldrb	r3, [r2, #0]
 80027c0:	2104      	movs	r1, #4
 80027c2:	f361 0302 	bfi	r3, r1, #0, #3
 80027c6:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state       = 0U;
 80027c8:	9b05      	ldr	r3, [sp, #20]
 80027ca:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 80027ce:	7813      	ldrb	r3, [r2, #0]
 80027d0:	f36f 03c7 	bfc	r3, #3, #5
 80027d4:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.isr.name  = isr;
 80027d6:	9b05      	ldr	r3, [sp, #20]
 80027d8:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80027dc:	9a01      	ldr	r2, [sp, #4]
 80027de:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 80027e0:	9805      	ldr	r0, [sp, #20]
 80027e2:	f7ff fecd 	bl	8002580 <trace_next>
 80027e6:	2300      	movs	r3, #0
 80027e8:	9304      	str	r3, [sp, #16]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80027ea:	9b04      	ldr	r3, [sp, #16]
 80027ec:	f383 8811 	msr	BASEPRI, r3
}
 80027f0:	bf00      	nop
}
 80027f2:	bf00      	nop
}
 80027f4:	bf00      	nop
    port_unlock_from_isr();
  }
}
 80027f6:	bf00      	nop
 80027f8:	b007      	add	sp, #28
 80027fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80027fe:	bf00      	nop
 8002800:	200008a0 	.word	0x200008a0
	...

08002810 <__trace_halt>:
 *
 * @param[in] reason    the halt error string
 *
 * @notapi
 */
void __trace_halt(const char *reason) {
 8002810:	b500      	push	{lr}
 8002812:	b085      	sub	sp, #20
 8002814:	9001      	str	r0, [sp, #4]
  os_instance_t *oip = currcore;
 8002816:	4b12      	ldr	r3, [pc, #72]	; (8002860 <__trace_halt+0x50>)
 8002818:	9303      	str	r3, [sp, #12]

  if ((oip->trace_buffer.suspended & CH_DBG_TRACE_MASK_HALT) == 0U) {
 800281a:	9b03      	ldr	r3, [sp, #12]
 800281c:	f8b3 3090 	ldrh.w	r3, [r3, #144]	; 0x90
 8002820:	f003 0308 	and.w	r3, r3, #8
 8002824:	2b00      	cmp	r3, #0
 8002826:	d116      	bne.n	8002856 <__trace_halt+0x46>
    oip->trace_buffer.ptr->type          = CH_TRACE_TYPE_HALT;
 8002828:	9b03      	ldr	r3, [sp, #12]
 800282a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800282e:	7813      	ldrb	r3, [r2, #0]
 8002830:	2105      	movs	r1, #5
 8002832:	f361 0302 	bfi	r3, r1, #0, #3
 8002836:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->state         = 0;
 8002838:	9b03      	ldr	r3, [sp, #12]
 800283a:	f8d3 2094 	ldr.w	r2, [r3, #148]	; 0x94
 800283e:	7813      	ldrb	r3, [r2, #0]
 8002840:	f36f 03c7 	bfc	r3, #3, #5
 8002844:	7013      	strb	r3, [r2, #0]
    oip->trace_buffer.ptr->u.halt.reason = reason;
 8002846:	9b03      	ldr	r3, [sp, #12]
 8002848:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 800284c:	9a01      	ldr	r2, [sp, #4]
 800284e:	609a      	str	r2, [r3, #8]
    trace_next(oip);
 8002850:	9803      	ldr	r0, [sp, #12]
 8002852:	f7ff fe95 	bl	8002580 <trace_next>
  }
}
 8002856:	bf00      	nop
 8002858:	b005      	add	sp, #20
 800285a:	f85d fb04 	ldr.w	pc, [sp], #4
 800285e:	bf00      	nop
 8002860:	200008a0 	.word	0x200008a0
	...

08002870 <chTimeAddX>:
 * @return              The new system time.
 *
 * @xclass
 */
static inline systime_t chTimeAddX(systime_t systime,
                                   sysinterval_t interval) {
 8002870:	b082      	sub	sp, #8
 8002872:	9001      	str	r0, [sp, #4]
 8002874:	9100      	str	r1, [sp, #0]

#if CH_CFG_ST_RESOLUTION != CH_CFG_INTERVALS_SIZE
  chDbgCheck(interval <= (sysinterval_t)TIME_MAX_SYSTIME);
#endif

  return systime + (systime_t)interval;
 8002876:	9a01      	ldr	r2, [sp, #4]
 8002878:	9b00      	ldr	r3, [sp, #0]
 800287a:	4413      	add	r3, r2
}
 800287c:	4618      	mov	r0, r3
 800287e:	b002      	add	sp, #8
 8002880:	4770      	bx	lr
 8002882:	bf00      	nop
	...

08002890 <chTimeDiffX>:
 * @param[in] end       second system time
 * @return              The interval representing the time difference.
 *
 * @xclass
 */
static inline sysinterval_t chTimeDiffX(systime_t start, systime_t end) {
 8002890:	b082      	sub	sp, #8
 8002892:	9001      	str	r0, [sp, #4]
 8002894:	9100      	str	r1, [sp, #0]

  /*lint -save -e9033 [10.8] This cast is required by the operation, it is
    known that the destination type can be wider.*/
  return (sysinterval_t)((systime_t)(end - start));
 8002896:	9a00      	ldr	r2, [sp, #0]
 8002898:	9b01      	ldr	r3, [sp, #4]
 800289a:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 800289c:	4618      	mov	r0, r3
 800289e:	b002      	add	sp, #8
 80028a0:	4770      	bx	lr
 80028a2:	bf00      	nop
	...

080028b0 <ch_dlist_isempty>:
 * @param[in] dlhp      pointer to the delta list header
 * @return              The status of the delta list.
 *
 * @notapi
 */
static inline bool ch_dlist_isempty(ch_delta_list_t *dlhp) {
 80028b0:	b082      	sub	sp, #8
 80028b2:	9001      	str	r0, [sp, #4]

  return (bool)(dlhp == dlhp->next);
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	681b      	ldr	r3, [r3, #0]
 80028b8:	9a01      	ldr	r2, [sp, #4]
 80028ba:	429a      	cmp	r2, r3
 80028bc:	bf0c      	ite	eq
 80028be:	2301      	moveq	r3, #1
 80028c0:	2300      	movne	r3, #0
 80028c2:	b2db      	uxtb	r3, r3
}
 80028c4:	4618      	mov	r0, r3
 80028c6:	b002      	add	sp, #8
 80028c8:	4770      	bx	lr
 80028ca:	bf00      	nop
 80028cc:	0000      	movs	r0, r0
	...

080028d0 <ch_dlist_isfirst>:
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline bool ch_dlist_isfirst(ch_delta_list_t *dlhp,
                                    ch_delta_list_t *dlp) {
 80028d0:	b082      	sub	sp, #8
 80028d2:	9001      	str	r0, [sp, #4]
 80028d4:	9100      	str	r1, [sp, #0]

  return (bool)(dlhp->next == dlp);
 80028d6:	9b01      	ldr	r3, [sp, #4]
 80028d8:	681b      	ldr	r3, [r3, #0]
 80028da:	9a00      	ldr	r2, [sp, #0]
 80028dc:	429a      	cmp	r2, r3
 80028de:	bf0c      	ite	eq
 80028e0:	2301      	moveq	r3, #1
 80028e2:	2300      	movne	r3, #0
 80028e4:	b2db      	uxtb	r3, r3
}
 80028e6:	4618      	mov	r0, r3
 80028e8:	b002      	add	sp, #8
 80028ea:	4770      	bx	lr
 80028ec:	0000      	movs	r0, r0
	...

080028f0 <ch_dlist_insert_after>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_after(ch_delta_list_t *dlhp,
                                         ch_delta_list_t *dlp,
                                         sysinterval_t delta) {
 80028f0:	b084      	sub	sp, #16
 80028f2:	9003      	str	r0, [sp, #12]
 80028f4:	9102      	str	r1, [sp, #8]
 80028f6:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 80028f8:	9b02      	ldr	r3, [sp, #8]
 80028fa:	9a01      	ldr	r2, [sp, #4]
 80028fc:	609a      	str	r2, [r3, #8]
  dlp->prev       = dlhp;
 80028fe:	9b02      	ldr	r3, [sp, #8]
 8002900:	9a03      	ldr	r2, [sp, #12]
 8002902:	605a      	str	r2, [r3, #4]
  dlp->next       = dlp->prev->next;
 8002904:	9b02      	ldr	r3, [sp, #8]
 8002906:	685b      	ldr	r3, [r3, #4]
 8002908:	681a      	ldr	r2, [r3, #0]
 800290a:	9b02      	ldr	r3, [sp, #8]
 800290c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp;
 800290e:	9b02      	ldr	r3, [sp, #8]
 8002910:	681b      	ldr	r3, [r3, #0]
 8002912:	9a02      	ldr	r2, [sp, #8]
 8002914:	605a      	str	r2, [r3, #4]
  dlhp->next      = dlp;
 8002916:	9b03      	ldr	r3, [sp, #12]
 8002918:	9a02      	ldr	r2, [sp, #8]
 800291a:	601a      	str	r2, [r3, #0]
}
 800291c:	bf00      	nop
 800291e:	b004      	add	sp, #16
 8002920:	4770      	bx	lr
 8002922:	bf00      	nop
	...

08002930 <ch_dlist_insert_before>:
 *
 * @notapi
 */
static inline void ch_dlist_insert_before(ch_delta_list_t *dlhp,
                                          ch_delta_list_t *dlp,
                                          sysinterval_t delta) {
 8002930:	b084      	sub	sp, #16
 8002932:	9003      	str	r0, [sp, #12]
 8002934:	9102      	str	r1, [sp, #8]
 8002936:	9201      	str	r2, [sp, #4]

  dlp->delta      = delta;
 8002938:	9b02      	ldr	r3, [sp, #8]
 800293a:	9a01      	ldr	r2, [sp, #4]
 800293c:	609a      	str	r2, [r3, #8]
  dlp->next       = dlhp;
 800293e:	9b02      	ldr	r3, [sp, #8]
 8002940:	9a03      	ldr	r2, [sp, #12]
 8002942:	601a      	str	r2, [r3, #0]
  dlp->prev       = dlp->next->prev;
 8002944:	9b02      	ldr	r3, [sp, #8]
 8002946:	681b      	ldr	r3, [r3, #0]
 8002948:	685a      	ldr	r2, [r3, #4]
 800294a:	9b02      	ldr	r3, [sp, #8]
 800294c:	605a      	str	r2, [r3, #4]
  dlp->prev->next = dlp;
 800294e:	9b02      	ldr	r3, [sp, #8]
 8002950:	685b      	ldr	r3, [r3, #4]
 8002952:	9a02      	ldr	r2, [sp, #8]
 8002954:	601a      	str	r2, [r3, #0]
  dlhp->prev      = dlp;
 8002956:	9b03      	ldr	r3, [sp, #12]
 8002958:	9a02      	ldr	r2, [sp, #8]
 800295a:	605a      	str	r2, [r3, #4]
}
 800295c:	bf00      	nop
 800295e:	b004      	add	sp, #16
 8002960:	4770      	bx	lr
 8002962:	bf00      	nop
	...

08002970 <ch_dlist_insert>:
 *
 * @notapi
 */
static inline void ch_dlist_insert(ch_delta_list_t *dlhp,
                                   ch_delta_list_t *dlep,
                                   sysinterval_t delta) {
 8002970:	b500      	push	{lr}
 8002972:	b087      	sub	sp, #28
 8002974:	9003      	str	r0, [sp, #12]
 8002976:	9102      	str	r1, [sp, #8]
 8002978:	9201      	str	r2, [sp, #4]
  ch_delta_list_t *dlp;

  /* The delta list is scanned in order to find the correct position for
     this element. */
  dlp = dlhp->next;
 800297a:	9b03      	ldr	r3, [sp, #12]
 800297c:	681b      	ldr	r3, [r3, #0]
 800297e:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 8002980:	e013      	b.n	80029aa <ch_dlist_insert+0x3a>
    /* Debug assert if the element is already in the list.*/
    chDbgAssert(dlp != dlep, "element already in list");
 8002982:	9a05      	ldr	r2, [sp, #20]
 8002984:	9b02      	ldr	r3, [sp, #8]
 8002986:	429a      	cmp	r2, r3
 8002988:	bf0c      	ite	eq
 800298a:	2301      	moveq	r3, #1
 800298c:	2300      	movne	r3, #0
 800298e:	b2db      	uxtb	r3, r3
 8002990:	2b00      	cmp	r3, #0
 8002992:	d002      	beq.n	800299a <ch_dlist_insert+0x2a>
 8002994:	4813      	ldr	r0, [pc, #76]	; (80029e4 <ch_dlist_insert+0x74>)
 8002996:	f7ff fc33 	bl	8002200 <chSysHalt>

    delta -= dlp->delta;
 800299a:	9b05      	ldr	r3, [sp, #20]
 800299c:	689b      	ldr	r3, [r3, #8]
 800299e:	9a01      	ldr	r2, [sp, #4]
 80029a0:	1ad3      	subs	r3, r2, r3
 80029a2:	9301      	str	r3, [sp, #4]
    dlp = dlp->next;
 80029a4:	9b05      	ldr	r3, [sp, #20]
 80029a6:	681b      	ldr	r3, [r3, #0]
 80029a8:	9305      	str	r3, [sp, #20]
  while (likely(dlp->delta < delta)) {
 80029aa:	9b05      	ldr	r3, [sp, #20]
 80029ac:	689b      	ldr	r3, [r3, #8]
 80029ae:	9a01      	ldr	r2, [sp, #4]
 80029b0:	429a      	cmp	r2, r3
 80029b2:	bf8c      	ite	hi
 80029b4:	2301      	movhi	r3, #1
 80029b6:	2300      	movls	r3, #0
 80029b8:	b2db      	uxtb	r3, r3
 80029ba:	2b00      	cmp	r3, #0
 80029bc:	d1e1      	bne.n	8002982 <ch_dlist_insert+0x12>
  }

  /* The timer is inserted in the delta list.*/
  ch_dlist_insert_before(dlp, dlep, delta);
 80029be:	9a01      	ldr	r2, [sp, #4]
 80029c0:	9902      	ldr	r1, [sp, #8]
 80029c2:	9805      	ldr	r0, [sp, #20]
 80029c4:	f7ff ffb4 	bl	8002930 <ch_dlist_insert_before>

  /* Adjusting delta for the following element.*/
  dlp->delta -= delta;
 80029c8:	9b05      	ldr	r3, [sp, #20]
 80029ca:	689a      	ldr	r2, [r3, #8]
 80029cc:	9b01      	ldr	r3, [sp, #4]
 80029ce:	1ad2      	subs	r2, r2, r3
 80029d0:	9b05      	ldr	r3, [sp, #20]
 80029d2:	609a      	str	r2, [r3, #8]

  /* Special case when the inserted element is in last position in the list,
     the value in the header must be restored, just doing it is faster than
     checking then doing.*/
  dlhp->delta = (sysinterval_t)-1;
 80029d4:	9b03      	ldr	r3, [sp, #12]
 80029d6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80029da:	609a      	str	r2, [r3, #8]
}
 80029dc:	bf00      	nop
 80029de:	b007      	add	sp, #28
 80029e0:	f85d fb04 	ldr.w	pc, [sp], #4
 80029e4:	08004644 	.word	0x08004644
	...

080029f0 <ch_dlist_remove_first>:
 *
 * @param[in] dlhp      pointer to the delta list header
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_remove_first(ch_delta_list_t *dlhp) {
 80029f0:	b084      	sub	sp, #16
 80029f2:	9001      	str	r0, [sp, #4]
  ch_delta_list_t *dlp = dlhp->next;
 80029f4:	9b01      	ldr	r3, [sp, #4]
 80029f6:	681b      	ldr	r3, [r3, #0]
 80029f8:	9303      	str	r3, [sp, #12]

  dlhp->next       = dlp->next;
 80029fa:	9b03      	ldr	r3, [sp, #12]
 80029fc:	681a      	ldr	r2, [r3, #0]
 80029fe:	9b01      	ldr	r3, [sp, #4]
 8002a00:	601a      	str	r2, [r3, #0]
  dlhp->next->prev = dlhp;
 8002a02:	9b01      	ldr	r3, [sp, #4]
 8002a04:	681b      	ldr	r3, [r3, #0]
 8002a06:	9a01      	ldr	r2, [sp, #4]
 8002a08:	605a      	str	r2, [r3, #4]

  return dlp;
 8002a0a:	9b03      	ldr	r3, [sp, #12]
}
 8002a0c:	4618      	mov	r0, r3
 8002a0e:	b004      	add	sp, #16
 8002a10:	4770      	bx	lr
 8002a12:	bf00      	nop
	...

08002a20 <ch_dlist_dequeue>:
 *
 * @param[in] dlp       pointer to the delta list element
 *
 * @notapi
 */
static inline ch_delta_list_t *ch_dlist_dequeue(ch_delta_list_t *dlp) {
 8002a20:	b082      	sub	sp, #8
 8002a22:	9001      	str	r0, [sp, #4]

  dlp->prev->next = dlp->next;
 8002a24:	9b01      	ldr	r3, [sp, #4]
 8002a26:	685b      	ldr	r3, [r3, #4]
 8002a28:	9a01      	ldr	r2, [sp, #4]
 8002a2a:	6812      	ldr	r2, [r2, #0]
 8002a2c:	601a      	str	r2, [r3, #0]
  dlp->next->prev = dlp->prev;
 8002a2e:	9b01      	ldr	r3, [sp, #4]
 8002a30:	681b      	ldr	r3, [r3, #0]
 8002a32:	9a01      	ldr	r2, [sp, #4]
 8002a34:	6852      	ldr	r2, [r2, #4]
 8002a36:	605a      	str	r2, [r3, #4]

  return dlp;
 8002a38:	9b01      	ldr	r3, [sp, #4]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	b002      	add	sp, #8
 8002a3e:	4770      	bx	lr

08002a40 <port_timer_start_alarm>:
static inline void port_timer_start_alarm(systime_t time) {
 8002a40:	b500      	push	{lr}
 8002a42:	b083      	sub	sp, #12
 8002a44:	9001      	str	r0, [sp, #4]
  stStartAlarm(time);
 8002a46:	9801      	ldr	r0, [sp, #4]
 8002a48:	f7fd fd22 	bl	8000490 <stStartAlarm>
}
 8002a4c:	bf00      	nop
 8002a4e:	b003      	add	sp, #12
 8002a50:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002a60 <port_timer_stop_alarm>:
static inline void port_timer_stop_alarm(void) {
 8002a60:	b508      	push	{r3, lr}
  stStopAlarm();
 8002a62:	f7fd fd2d 	bl	80004c0 <stStopAlarm>
}
 8002a66:	bf00      	nop
 8002a68:	bd08      	pop	{r3, pc}
 8002a6a:	bf00      	nop
 8002a6c:	0000      	movs	r0, r0
	...

08002a70 <port_timer_set_alarm>:
static inline void port_timer_set_alarm(systime_t time) {
 8002a70:	b500      	push	{lr}
 8002a72:	b083      	sub	sp, #12
 8002a74:	9001      	str	r0, [sp, #4]
  stSetAlarm(time);
 8002a76:	9801      	ldr	r0, [sp, #4]
 8002a78:	f7fd fd2a 	bl	80004d0 <stSetAlarm>
}
 8002a7c:	bf00      	nop
 8002a7e:	b003      	add	sp, #12
 8002a80:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002a90 <port_timer_get_time>:
static inline systime_t port_timer_get_time(void) {
 8002a90:	b508      	push	{r3, lr}
  return stGetCounter();
 8002a92:	f7fd fcf5 	bl	8000480 <stGetCounter>
 8002a96:	4603      	mov	r3, r0
}
 8002a98:	4618      	mov	r0, r3
 8002a9a:	bd08      	pop	{r3, pc}
 8002a9c:	0000      	movs	r0, r0
	...

08002aa0 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8002aa0:	b500      	push	{lr}
 8002aa2:	b083      	sub	sp, #12
 8002aa4:	2330      	movs	r3, #48	; 0x30
 8002aa6:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002aa8:	9b01      	ldr	r3, [sp, #4]
 8002aaa:	f383 8811 	msr	BASEPRI, r3
}
 8002aae:	bf00      	nop
}
 8002ab0:	bf00      	nop
}
 8002ab2:	bf00      	nop
  __dbg_check_lock_from_isr();
 8002ab4:	f7ff fc44 	bl	8002340 <__dbg_check_lock_from_isr>
}
 8002ab8:	bf00      	nop
 8002aba:	b003      	add	sp, #12
 8002abc:	f85d fb04 	ldr.w	pc, [sp], #4

08002ac0 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8002ac0:	b500      	push	{lr}
 8002ac2:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8002ac4:	f7ff fc64 	bl	8002390 <__dbg_check_unlock_from_isr>
 8002ac8:	2300      	movs	r3, #0
 8002aca:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8002acc:	9b01      	ldr	r3, [sp, #4]
 8002ace:	f383 8811 	msr	BASEPRI, r3
}
 8002ad2:	bf00      	nop
}
 8002ad4:	bf00      	nop
}
 8002ad6:	bf00      	nop
}
 8002ad8:	bf00      	nop
 8002ada:	b003      	add	sp, #12
 8002adc:	f85d fb04 	ldr.w	pc, [sp], #4

08002ae0 <chVTGetSystemTimeX>:
static inline systime_t chVTGetSystemTimeX(void) {
 8002ae0:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8002ae2:	f7ff ffd5 	bl	8002a90 <port_timer_get_time>
 8002ae6:	4603      	mov	r3, r0
}
 8002ae8:	4618      	mov	r0, r3
 8002aea:	bd08      	pop	{r3, pc}
 8002aec:	0000      	movs	r0, r0
	...

08002af0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8002af0:	b500      	push	{lr}
 8002af2:	b083      	sub	sp, #12
 8002af4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8002af6:	f7ff fceb 	bl	80024d0 <chDbgCheckClassI>

  return (bool)(vtp->dlist.next != NULL);
 8002afa:	9b01      	ldr	r3, [sp, #4]
 8002afc:	681b      	ldr	r3, [r3, #0]
 8002afe:	2b00      	cmp	r3, #0
 8002b00:	bf14      	ite	ne
 8002b02:	2301      	movne	r3, #1
 8002b04:	2300      	moveq	r3, #0
 8002b06:	b2db      	uxtb	r3, r3
}
 8002b08:	4618      	mov	r0, r3
 8002b0a:	b003      	add	sp, #12
 8002b0c:	f85d fb04 	ldr.w	pc, [sp], #4

08002b10 <vt_set_alarm>:
 *          in order to compensate for the event.
 *
 * @param[in] now       last known system time
 * @param[in] delay     delay over @p now
 */
static void vt_set_alarm(systime_t now, sysinterval_t delay) {
 8002b10:	b500      	push	{lr}
 8002b12:	b087      	sub	sp, #28
 8002b14:	9001      	str	r0, [sp, #4]
 8002b16:	9100      	str	r1, [sp, #0]
  sysinterval_t currdelta;

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002b18:	2302      	movs	r3, #2
 8002b1a:	9305      	str	r3, [sp, #20]

  if (delay < currdelta) {
 8002b1c:	9a00      	ldr	r2, [sp, #0]
 8002b1e:	9b05      	ldr	r3, [sp, #20]
 8002b20:	429a      	cmp	r2, r3
 8002b22:	d201      	bcs.n	8002b28 <vt_set_alarm+0x18>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002b24:	9b05      	ldr	r3, [sp, #20]
 8002b26:	9300      	str	r3, [sp, #0]
  while (true) {
    sysinterval_t nowdelta;
    systime_t newnow;

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, delay));
 8002b28:	9900      	ldr	r1, [sp, #0]
 8002b2a:	9801      	ldr	r0, [sp, #4]
 8002b2c:	f7ff fea0 	bl	8002870 <chTimeAddX>
 8002b30:	4603      	mov	r3, r0
 8002b32:	4618      	mov	r0, r3
 8002b34:	f7ff ff9c 	bl	8002a70 <port_timer_set_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002b38:	f7ff ffd2 	bl	8002ae0 <chVTGetSystemTimeX>
 8002b3c:	9004      	str	r0, [sp, #16]
    nowdelta = chTimeDiffX(now, newnow);
 8002b3e:	9904      	ldr	r1, [sp, #16]
 8002b40:	9801      	ldr	r0, [sp, #4]
 8002b42:	f7ff fea5 	bl	8002890 <chTimeDiffX>
 8002b46:	9003      	str	r0, [sp, #12]
    if (likely(nowdelta < delay)) {
 8002b48:	9a03      	ldr	r2, [sp, #12]
 8002b4a:	9b00      	ldr	r3, [sp, #0]
 8002b4c:	429a      	cmp	r2, r3
 8002b4e:	bf34      	ite	cc
 8002b50:	2301      	movcc	r3, #1
 8002b52:	2300      	movcs	r3, #0
 8002b54:	b2db      	uxtb	r3, r3
 8002b56:	2b00      	cmp	r3, #0
 8002b58:	d107      	bne.n	8002b6a <vt_set_alarm+0x5a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002b5a:	9b05      	ldr	r3, [sp, #20]
 8002b5c:	3301      	adds	r3, #1
 8002b5e:	9305      	str	r3, [sp, #20]

    /* Current time becomes the new "base" time.*/
    now = newnow;
 8002b60:	9b04      	ldr	r3, [sp, #16]
 8002b62:	9301      	str	r3, [sp, #4]
    delay = currdelta;
 8002b64:	9b05      	ldr	r3, [sp, #20]
 8002b66:	9300      	str	r3, [sp, #0]
  while (true) {
 8002b68:	e7de      	b.n	8002b28 <vt_set_alarm+0x18>
      break;
 8002b6a:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002b6c:	9b05      	ldr	r3, [sp, #20]
 8002b6e:	2b02      	cmp	r3, #2
 8002b70:	d902      	bls.n	8002b78 <vt_set_alarm+0x68>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002b72:	2001      	movs	r0, #1
 8002b74:	f7ff fb84 	bl	8002280 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002b78:	bf00      	nop
 8002b7a:	b007      	add	sp, #28
 8002b7c:	f85d fb04 	ldr.w	pc, [sp], #4

08002b80 <vt_insert_first>:
 * @note    This is the special case when the delta list is initially empty.
 */
static void vt_insert_first(virtual_timers_list_t *vtlp,
                            virtual_timer_t *vtp,
                            systime_t now,
                            sysinterval_t delay) {
 8002b80:	b500      	push	{lr}
 8002b82:	b087      	sub	sp, #28
 8002b84:	9003      	str	r0, [sp, #12]
 8002b86:	9102      	str	r1, [sp, #8]
 8002b88:	9201      	str	r2, [sp, #4]
 8002b8a:	9300      	str	r3, [sp, #0]
  sysinterval_t currdelta;

  /* The delta list is empty, the current time becomes the new
     delta list base time, the timer is inserted.*/
  vtlp->lasttime = now;
 8002b8c:	9b03      	ldr	r3, [sp, #12]
 8002b8e:	9a01      	ldr	r2, [sp, #4]
 8002b90:	60da      	str	r2, [r3, #12]
  ch_dlist_insert_after(&vtlp->dlist, &vtp->dlist, delay);
 8002b92:	9b03      	ldr	r3, [sp, #12]
 8002b94:	9902      	ldr	r1, [sp, #8]
 8002b96:	9a00      	ldr	r2, [sp, #0]
 8002b98:	4618      	mov	r0, r3
 8002b9a:	f7ff fea9 	bl	80028f0 <ch_dlist_insert_after>

  /* Initial delta is what is configured statically.*/
  currdelta = (sysinterval_t)CH_CFG_ST_TIMEDELTA;
 8002b9e:	2302      	movs	r3, #2
 8002ba0:	9305      	str	r3, [sp, #20]

  /* If the requested delay is lower than the minimum safe delta then it
     is raised to the minimum safe value.*/
  if (delay < currdelta) {
 8002ba2:	9a00      	ldr	r2, [sp, #0]
 8002ba4:	9b05      	ldr	r3, [sp, #20]
 8002ba6:	429a      	cmp	r2, r3
 8002ba8:	d201      	bcs.n	8002bae <vt_insert_first+0x2e>
    /* We need to avoid that the system time goes past the alarm we are
       going to set before the alarm is actually set.*/
    delay = currdelta;
 8002baa:	9b05      	ldr	r3, [sp, #20]
 8002bac:	9300      	str	r3, [sp, #0]
  }
#endif

  /* Being the first element inserted in the list the alarm timer
     is started.*/
  port_timer_start_alarm(chTimeAddX(vtlp->lasttime, delay));
 8002bae:	9b03      	ldr	r3, [sp, #12]
 8002bb0:	68db      	ldr	r3, [r3, #12]
 8002bb2:	9900      	ldr	r1, [sp, #0]
 8002bb4:	4618      	mov	r0, r3
 8002bb6:	f7ff fe5b 	bl	8002870 <chTimeAddX>
 8002bba:	4603      	mov	r3, r0
 8002bbc:	4618      	mov	r0, r3
 8002bbe:	f7ff ff3f 	bl	8002a40 <port_timer_start_alarm>
       current time skipped past the calculated deadline.
       Note that the "<" condition is intentional, we want to make sure
       that the alarm is set before the deadline is reached because the
       comparison could happen on the transition depending on the timer
       architecture.*/
    newnow = chVTGetSystemTimeX();
 8002bc2:	f7ff ff8d 	bl	8002ae0 <chVTGetSystemTimeX>
 8002bc6:	9004      	str	r0, [sp, #16]
    if (likely(chTimeDiffX(now, newnow) < delay)) {
 8002bc8:	9904      	ldr	r1, [sp, #16]
 8002bca:	9801      	ldr	r0, [sp, #4]
 8002bcc:	f7ff fe60 	bl	8002890 <chTimeDiffX>
 8002bd0:	4602      	mov	r2, r0
 8002bd2:	9b00      	ldr	r3, [sp, #0]
 8002bd4:	4293      	cmp	r3, r2
 8002bd6:	bf8c      	ite	hi
 8002bd8:	2301      	movhi	r3, #1
 8002bda:	2300      	movls	r3, #0
 8002bdc:	b2db      	uxtb	r3, r3
 8002bde:	2b00      	cmp	r3, #0
 8002be0:	d10b      	bne.n	8002bfa <vt_insert_first+0x7a>
      break;
    }

    /* Trying again with a more relaxed minimum delta.*/
    currdelta += (sysinterval_t)1;
 8002be2:	9b05      	ldr	r3, [sp, #20]
 8002be4:	3301      	adds	r3, #1
 8002be6:	9305      	str	r3, [sp, #20]

    /* Setting up the alarm on the next deadline.*/
    port_timer_set_alarm(chTimeAddX(now, currdelta));
 8002be8:	9905      	ldr	r1, [sp, #20]
 8002bea:	9801      	ldr	r0, [sp, #4]
 8002bec:	f7ff fe40 	bl	8002870 <chTimeAddX>
 8002bf0:	4603      	mov	r3, r0
 8002bf2:	4618      	mov	r0, r3
 8002bf4:	f7ff ff3c 	bl	8002a70 <port_timer_set_alarm>
  while (true) {
 8002bf8:	e7e3      	b.n	8002bc2 <vt_insert_first+0x42>
      break;
 8002bfa:	bf00      	nop
  }

#if !defined(CH_VT_RFCU_DISABLED)
  /* Checking if a skip occurred.*/
  if (currdelta > CH_CFG_ST_TIMEDELTA) {
 8002bfc:	9b05      	ldr	r3, [sp, #20]
 8002bfe:	2b02      	cmp	r3, #2
 8002c00:	d902      	bls.n	8002c08 <vt_insert_first+0x88>
    chRFCUCollectFaultsI(CH_RFCU_VT_INSUFFICIENT_DELTA);
 8002c02:	2001      	movs	r0, #1
 8002c04:	f7ff fb3c 	bl	8002280 <chRFCUCollectFaultsI>
  }
#else
  /* Assertions as fallback.*/
  chDbgAssert(currdelta <= CH_CFG_ST_TIMEDELTA, "insufficient delta");
#endif
}
 8002c08:	bf00      	nop
 8002c0a:	b007      	add	sp, #28
 8002c0c:	f85d fb04 	ldr.w	pc, [sp], #4

08002c10 <vt_enqueue>:
/**
 * @brief   Enqueues a virtual timer in a virtual timers list.
 */
static void vt_enqueue(virtual_timers_list_t *vtlp,
                       virtual_timer_t *vtp,
                       sysinterval_t delay) {
 8002c10:	b500      	push	{lr}
 8002c12:	b089      	sub	sp, #36	; 0x24
 8002c14:	9003      	str	r0, [sp, #12]
 8002c16:	9102      	str	r1, [sp, #8]
 8002c18:	9201      	str	r2, [sp, #4]
  sysinterval_t delta;

#if CH_CFG_ST_TIMEDELTA > 0
  {
    sysinterval_t nowdelta;
    systime_t now = chVTGetSystemTimeX();
 8002c1a:	f7ff ff61 	bl	8002ae0 <chVTGetSystemTimeX>
 8002c1e:	9006      	str	r0, [sp, #24]

    /* Special case where the timers list is empty.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002c20:	9b03      	ldr	r3, [sp, #12]
 8002c22:	4618      	mov	r0, r3
 8002c24:	f7ff fe44 	bl	80028b0 <ch_dlist_isempty>
 8002c28:	4603      	mov	r3, r0
 8002c2a:	2b00      	cmp	r3, #0
 8002c2c:	d006      	beq.n	8002c3c <vt_enqueue+0x2c>

      vt_insert_first(vtlp, vtp, now, delay);
 8002c2e:	9b01      	ldr	r3, [sp, #4]
 8002c30:	9a06      	ldr	r2, [sp, #24]
 8002c32:	9902      	ldr	r1, [sp, #8]
 8002c34:	9803      	ldr	r0, [sp, #12]
 8002c36:	f7ff ffa3 	bl	8002b80 <vt_insert_first>

      return;
 8002c3a:	e020      	b.n	8002c7e <vt_enqueue+0x6e>
    }

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'deltanow'.*/
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002c3c:	9b03      	ldr	r3, [sp, #12]
 8002c3e:	68db      	ldr	r3, [r3, #12]
 8002c40:	9906      	ldr	r1, [sp, #24]
 8002c42:	4618      	mov	r0, r3
 8002c44:	f7ff fe24 	bl	8002890 <chTimeDiffX>
 8002c48:	9005      	str	r0, [sp, #20]
    delta    = nowdelta + delay;
 8002c4a:	9a05      	ldr	r2, [sp, #20]
 8002c4c:	9b01      	ldr	r3, [sp, #4]
 8002c4e:	4413      	add	r3, r2
 8002c50:	9307      	str	r3, [sp, #28]

    /* Scenario where a very large delay exceeded the numeric range, the
       delta is shortened to make it fit the numeric range, the timer
       will be triggered "deltanow" cycles earlier.*/
    if (delta < nowdelta) {
 8002c52:	9a07      	ldr	r2, [sp, #28]
 8002c54:	9b05      	ldr	r3, [sp, #20]
 8002c56:	429a      	cmp	r2, r3
 8002c58:	d201      	bcs.n	8002c5e <vt_enqueue+0x4e>
      delta = delay;
 8002c5a:	9b01      	ldr	r3, [sp, #4]
 8002c5c:	9307      	str	r3, [sp, #28]
    }

    /* Checking if this timer would become the first in the delta list, this
       requires changing the current alarm setting.*/
    if (delta < vtlp->dlist.next->delta) {
 8002c5e:	9b03      	ldr	r3, [sp, #12]
 8002c60:	681b      	ldr	r3, [r3, #0]
 8002c62:	689b      	ldr	r3, [r3, #8]
 8002c64:	9a07      	ldr	r2, [sp, #28]
 8002c66:	429a      	cmp	r2, r3
 8002c68:	d203      	bcs.n	8002c72 <vt_enqueue+0x62>

      vt_set_alarm(now, delay);
 8002c6a:	9901      	ldr	r1, [sp, #4]
 8002c6c:	9806      	ldr	r0, [sp, #24]
 8002c6e:	f7ff ff4f 	bl	8002b10 <vt_set_alarm>

  /* Delta is initially equal to the specified delay.*/
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002c72:	9b03      	ldr	r3, [sp, #12]
 8002c74:	9902      	ldr	r1, [sp, #8]
 8002c76:	9a07      	ldr	r2, [sp, #28]
 8002c78:	4618      	mov	r0, r3
 8002c7a:	f7ff fe79 	bl	8002970 <ch_dlist_insert>
}
 8002c7e:	b009      	add	sp, #36	; 0x24
 8002c80:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08002c90 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, sysinterval_t delay,
                vtfunc_t vtfunc, void *par) {
 8002c90:	b500      	push	{lr}
 8002c92:	b087      	sub	sp, #28
 8002c94:	9003      	str	r0, [sp, #12]
 8002c96:	9102      	str	r1, [sp, #8]
 8002c98:	9201      	str	r2, [sp, #4]
 8002c9a:	9300      	str	r3, [sp, #0]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002c9c:	4b1a      	ldr	r3, [pc, #104]	; (8002d08 <chVTDoSetI+0x78>)
 8002c9e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002ca0:	f7ff fc16 	bl	80024d0 <chDbgCheckClassI>
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));
 8002ca4:	9b03      	ldr	r3, [sp, #12]
 8002ca6:	2b00      	cmp	r3, #0
 8002ca8:	bf0c      	ite	eq
 8002caa:	2301      	moveq	r3, #1
 8002cac:	2300      	movne	r3, #0
 8002cae:	b2db      	uxtb	r3, r3
 8002cb0:	2b00      	cmp	r3, #0
 8002cb2:	d107      	bne.n	8002cc4 <chVTDoSetI+0x34>
 8002cb4:	9b01      	ldr	r3, [sp, #4]
 8002cb6:	2b00      	cmp	r3, #0
 8002cb8:	bf0c      	ite	eq
 8002cba:	2301      	moveq	r3, #1
 8002cbc:	2300      	movne	r3, #0
 8002cbe:	b2db      	uxtb	r3, r3
 8002cc0:	2b00      	cmp	r3, #0
 8002cc2:	d001      	beq.n	8002cc8 <chVTDoSetI+0x38>
 8002cc4:	2301      	movs	r3, #1
 8002cc6:	e000      	b.n	8002cca <chVTDoSetI+0x3a>
 8002cc8:	2300      	movs	r3, #0
 8002cca:	2b00      	cmp	r3, #0
 8002ccc:	d107      	bne.n	8002cde <chVTDoSetI+0x4e>
 8002cce:	9b02      	ldr	r3, [sp, #8]
 8002cd0:	2b00      	cmp	r3, #0
 8002cd2:	bf0c      	ite	eq
 8002cd4:	2301      	moveq	r3, #1
 8002cd6:	2300      	movne	r3, #0
 8002cd8:	b2db      	uxtb	r3, r3
 8002cda:	2b00      	cmp	r3, #0
 8002cdc:	d002      	beq.n	8002ce4 <chVTDoSetI+0x54>
 8002cde:	480b      	ldr	r0, [pc, #44]	; (8002d0c <chVTDoSetI+0x7c>)
 8002ce0:	f7ff fa8e 	bl	8002200 <chSysHalt>

  /* Timer initialization.*/
  vtp->par     = par;
 8002ce4:	9b03      	ldr	r3, [sp, #12]
 8002ce6:	9a00      	ldr	r2, [sp, #0]
 8002ce8:	611a      	str	r2, [r3, #16]
  vtp->func    = vtfunc;
 8002cea:	9b03      	ldr	r3, [sp, #12]
 8002cec:	9a01      	ldr	r2, [sp, #4]
 8002cee:	60da      	str	r2, [r3, #12]
  vtp->reload  = (sysinterval_t)0;
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	2200      	movs	r2, #0
 8002cf4:	615a      	str	r2, [r3, #20]

  /* Inserting the timer in the delta list.*/
  vt_enqueue(vtlp, vtp, delay);
 8002cf6:	9a02      	ldr	r2, [sp, #8]
 8002cf8:	9903      	ldr	r1, [sp, #12]
 8002cfa:	9805      	ldr	r0, [sp, #20]
 8002cfc:	f7ff ff88 	bl	8002c10 <vt_enqueue>
}
 8002d00:	bf00      	nop
 8002d02:	b007      	add	sp, #28
 8002d04:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d08:	200008b0 	.word	0x200008b0
 8002d0c:	08004654 	.word	0x08004654

08002d10 <chVTDoResetI>:
 *
 * @param[in] vtp       pointer to a @p virtual_timer_t structure
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8002d10:	b500      	push	{lr}
 8002d12:	b087      	sub	sp, #28
 8002d14:	9001      	str	r0, [sp, #4]
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002d16:	4b3a      	ldr	r3, [pc, #232]	; (8002e00 <chVTDoResetI+0xf0>)
 8002d18:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002d1a:	f7ff fbd9 	bl	80024d0 <chDbgCheckClassI>
  chDbgCheck(vtp != NULL);
 8002d1e:	9b01      	ldr	r3, [sp, #4]
 8002d20:	2b00      	cmp	r3, #0
 8002d22:	bf0c      	ite	eq
 8002d24:	2301      	moveq	r3, #1
 8002d26:	2300      	movne	r3, #0
 8002d28:	b2db      	uxtb	r3, r3
 8002d2a:	2b00      	cmp	r3, #0
 8002d2c:	d002      	beq.n	8002d34 <chVTDoResetI+0x24>
 8002d2e:	4835      	ldr	r0, [pc, #212]	; (8002e04 <chVTDoResetI+0xf4>)
 8002d30:	f7ff fa66 	bl	8002200 <chSysHalt>
  chDbgAssert(chVTIsArmedI(vtp), "timer not armed");
 8002d34:	9801      	ldr	r0, [sp, #4]
 8002d36:	f7ff fedb 	bl	8002af0 <chVTIsArmedI>
 8002d3a:	4603      	mov	r3, r0
 8002d3c:	f083 0301 	eor.w	r3, r3, #1
 8002d40:	b2db      	uxtb	r3, r3
 8002d42:	2b00      	cmp	r3, #0
 8002d44:	d002      	beq.n	8002d4c <chVTDoResetI+0x3c>
 8002d46:	482f      	ldr	r0, [pc, #188]	; (8002e04 <chVTDoResetI+0xf4>)
 8002d48:	f7ff fa5a 	bl	8002200 <chSysHalt>
  systime_t now;
  sysinterval_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (!ch_dlist_isfirst(&vtlp->dlist, &vtp->dlist)) {
 8002d4c:	9b05      	ldr	r3, [sp, #20]
 8002d4e:	9a01      	ldr	r2, [sp, #4]
 8002d50:	4611      	mov	r1, r2
 8002d52:	4618      	mov	r0, r3
 8002d54:	f7ff fdbc 	bl	80028d0 <ch_dlist_isfirst>
 8002d58:	4603      	mov	r3, r0
 8002d5a:	f083 0301 	eor.w	r3, r3, #1
 8002d5e:	b2db      	uxtb	r3, r3
 8002d60:	2b00      	cmp	r3, #0
 8002d62:	d014      	beq.n	8002d8e <chVTDoResetI+0x7e>

    /* Removing the element from the delta list.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002d64:	9b01      	ldr	r3, [sp, #4]
 8002d66:	4618      	mov	r0, r3
 8002d68:	f7ff fe5a 	bl	8002a20 <ch_dlist_dequeue>

    /* Adding delta to the next element, if it is not the last one.*/
    vtp->dlist.next->delta += vtp->dlist.delta;
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	681b      	ldr	r3, [r3, #0]
 8002d70:	6899      	ldr	r1, [r3, #8]
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	689a      	ldr	r2, [r3, #8]
 8002d76:	9b01      	ldr	r3, [sp, #4]
 8002d78:	681b      	ldr	r3, [r3, #0]
 8002d7a:	440a      	add	r2, r1
 8002d7c:	609a      	str	r2, [r3, #8]

    /* Marking timer as not armed.*/
    vtp->dlist.next = NULL;
 8002d7e:	9b01      	ldr	r3, [sp, #4]
 8002d80:	2200      	movs	r2, #0
 8002d82:	601a      	str	r2, [r3, #0]

    /* Special case when the removed element from the last position in the list,
       the value in the header must be restored, just doing it is faster than
       checking then doing.*/
    vtlp->dlist.delta = (sysinterval_t)-1;
 8002d84:	9b05      	ldr	r3, [sp, #20]
 8002d86:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8002d8a:	609a      	str	r2, [r3, #8]

    return;
 8002d8c:	e035      	b.n	8002dfa <chVTDoResetI+0xea>
  }

  /* Removing the first timer from the list, marking it as not armed.*/
  ch_dlist_remove_first(&vtlp->dlist);
 8002d8e:	9b05      	ldr	r3, [sp, #20]
 8002d90:	4618      	mov	r0, r3
 8002d92:	f7ff fe2d 	bl	80029f0 <ch_dlist_remove_first>
  vtp->dlist.next = NULL;
 8002d96:	9b01      	ldr	r3, [sp, #4]
 8002d98:	2200      	movs	r2, #0
 8002d9a:	601a      	str	r2, [r3, #0]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002d9c:	9b05      	ldr	r3, [sp, #20]
 8002d9e:	4618      	mov	r0, r3
 8002da0:	f7ff fd86 	bl	80028b0 <ch_dlist_isempty>
 8002da4:	4603      	mov	r3, r0
 8002da6:	2b00      	cmp	r3, #0
 8002da8:	d002      	beq.n	8002db0 <chVTDoResetI+0xa0>

    port_timer_stop_alarm();
 8002daa:	f7ff fe59 	bl	8002a60 <port_timer_stop_alarm>

    return;
 8002dae:	e024      	b.n	8002dfa <chVTDoResetI+0xea>
  }

  /* The delta of the removed timer is added to the new first timer.*/
  vtlp->dlist.next->delta += vtp->dlist.delta;
 8002db0:	9b05      	ldr	r3, [sp, #20]
 8002db2:	681b      	ldr	r3, [r3, #0]
 8002db4:	6899      	ldr	r1, [r3, #8]
 8002db6:	9b01      	ldr	r3, [sp, #4]
 8002db8:	689a      	ldr	r2, [r3, #8]
 8002dba:	9b05      	ldr	r3, [sp, #20]
 8002dbc:	681b      	ldr	r3, [r3, #0]
 8002dbe:	440a      	add	r2, r1
 8002dc0:	609a      	str	r2, [r3, #8]

  /* Distance in ticks between the last alarm event and current time.*/
  now = chVTGetSystemTimeX();
 8002dc2:	f7ff fe8d 	bl	8002ae0 <chVTGetSystemTimeX>
 8002dc6:	9004      	str	r0, [sp, #16]
  nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002dc8:	9b05      	ldr	r3, [sp, #20]
 8002dca:	68db      	ldr	r3, [r3, #12]
 8002dcc:	9904      	ldr	r1, [sp, #16]
 8002dce:	4618      	mov	r0, r3
 8002dd0:	f7ff fd5e 	bl	8002890 <chTimeDiffX>
 8002dd4:	9003      	str	r0, [sp, #12]

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= vtlp->dlist.next->delta) {
 8002dd6:	9b05      	ldr	r3, [sp, #20]
 8002dd8:	681b      	ldr	r3, [r3, #0]
 8002dda:	689b      	ldr	r3, [r3, #8]
 8002ddc:	9a03      	ldr	r2, [sp, #12]
 8002dde:	429a      	cmp	r2, r3
 8002de0:	d20a      	bcs.n	8002df8 <chVTDoResetI+0xe8>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = vtlp->dlist.next->delta - nowdelta;
 8002de2:	9b05      	ldr	r3, [sp, #20]
 8002de4:	681b      	ldr	r3, [r3, #0]
 8002de6:	689a      	ldr	r2, [r3, #8]
 8002de8:	9b03      	ldr	r3, [sp, #12]
 8002dea:	1ad3      	subs	r3, r2, r3
 8002dec:	9302      	str	r3, [sp, #8]

  /* Setting up the alarm.*/
  vt_set_alarm(now, delta);
 8002dee:	9902      	ldr	r1, [sp, #8]
 8002df0:	9804      	ldr	r0, [sp, #16]
 8002df2:	f7ff fe8d 	bl	8002b10 <vt_set_alarm>
 8002df6:	e000      	b.n	8002dfa <chVTDoResetI+0xea>
    return;
 8002df8:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002dfa:	b007      	add	sp, #28
 8002dfc:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e00:	200008b0 	.word	0x200008b0
 8002e04:	08004660 	.word	0x08004660
	...

08002e10 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
void chVTDoTickI(void) {
 8002e10:	b500      	push	{lr}
 8002e12:	b089      	sub	sp, #36	; 0x24
  virtual_timers_list_t *vtlp = &currcore->vtlist;
 8002e14:	4b4f      	ldr	r3, [pc, #316]	; (8002f54 <chVTDoTickI+0x144>)
 8002e16:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
 8002e18:	f7ff fb5a 	bl	80024d0 <chDbgCheckClassI>
     than the interval between "now" and "lasttime".*/
  while (true) {
    systime_t lasttime;

    /* First timer in the delta list.*/
    vtp = (virtual_timer_t *)vtlp->dlist.next;
 8002e1c:	9b05      	ldr	r3, [sp, #20]
 8002e1e:	681b      	ldr	r3, [r3, #0]
 8002e20:	9304      	str	r3, [sp, #16]

    /* Delta between current time and last execution time.*/
    now = chVTGetSystemTimeX();
 8002e22:	f7ff fe5d 	bl	8002ae0 <chVTGetSystemTimeX>
 8002e26:	9003      	str	r0, [sp, #12]
    nowdelta = chTimeDiffX(vtlp->lasttime, now);
 8002e28:	9b05      	ldr	r3, [sp, #20]
 8002e2a:	68db      	ldr	r3, [r3, #12]
 8002e2c:	9903      	ldr	r1, [sp, #12]
 8002e2e:	4618      	mov	r0, r3
 8002e30:	f7ff fd2e 	bl	8002890 <chTimeDiffX>
 8002e34:	9002      	str	r0, [sp, #8]

    /* Loop break condition.
       Note that the list scan is limited by the delta list header having
       "vtlp->dlist.delta == (sysinterval_t)-1" which is greater than all
       deltas*/
    if (nowdelta < vtp->dlist.delta) {
 8002e36:	9b04      	ldr	r3, [sp, #16]
 8002e38:	689b      	ldr	r3, [r3, #8]
 8002e3a:	9a02      	ldr	r2, [sp, #8]
 8002e3c:	429a      	cmp	r2, r3
 8002e3e:	d369      	bcc.n	8002f14 <chVTDoTickI+0x104>
      break;
    }

    /* Last time deadline is updated to the next timer's time.*/
    lasttime = chTimeAddX(vtlp->lasttime, vtp->dlist.delta);
 8002e40:	9b05      	ldr	r3, [sp, #20]
 8002e42:	68da      	ldr	r2, [r3, #12]
 8002e44:	9b04      	ldr	r3, [sp, #16]
 8002e46:	689b      	ldr	r3, [r3, #8]
 8002e48:	4619      	mov	r1, r3
 8002e4a:	4610      	mov	r0, r2
 8002e4c:	f7ff fd10 	bl	8002870 <chTimeAddX>
 8002e50:	9001      	str	r0, [sp, #4]
    vtlp->lasttime = lasttime;
 8002e52:	9b05      	ldr	r3, [sp, #20]
 8002e54:	9a01      	ldr	r2, [sp, #4]
 8002e56:	60da      	str	r2, [r3, #12]

    /* Removing the timer from the list, marking it as not armed.*/
    (void) ch_dlist_dequeue(&vtp->dlist);
 8002e58:	9b04      	ldr	r3, [sp, #16]
 8002e5a:	4618      	mov	r0, r3
 8002e5c:	f7ff fde0 	bl	8002a20 <ch_dlist_dequeue>
    vtp->dlist.next = NULL;
 8002e60:	9b04      	ldr	r3, [sp, #16]
 8002e62:	2200      	movs	r2, #0
 8002e64:	601a      	str	r2, [r3, #0]

    /* If the list becomes empty then the alarm is disabled.*/
    if (ch_dlist_isempty(&vtlp->dlist)) {
 8002e66:	9b05      	ldr	r3, [sp, #20]
 8002e68:	4618      	mov	r0, r3
 8002e6a:	f7ff fd21 	bl	80028b0 <ch_dlist_isempty>
 8002e6e:	4603      	mov	r3, r0
 8002e70:	2b00      	cmp	r3, #0
 8002e72:	d001      	beq.n	8002e78 <chVTDoTickI+0x68>
      port_timer_stop_alarm();
 8002e74:	f7ff fdf4 	bl	8002a60 <port_timer_stop_alarm>
    }

    /* The callback is invoked outside the kernel critical section, it
       is re-entered on the callback return. Note that "lasttime" can be
       modified within the callback if some timer function is called.*/
    chSysUnlockFromISR();
 8002e78:	f7ff fe22 	bl	8002ac0 <chSysUnlockFromISR>

    vtp->func(vtp, vtp->par);
 8002e7c:	9b04      	ldr	r3, [sp, #16]
 8002e7e:	68db      	ldr	r3, [r3, #12]
 8002e80:	9a04      	ldr	r2, [sp, #16]
 8002e82:	6912      	ldr	r2, [r2, #16]
 8002e84:	4611      	mov	r1, r2
 8002e86:	9804      	ldr	r0, [sp, #16]
 8002e88:	4798      	blx	r3

    chSysLockFromISR();
 8002e8a:	f7ff fe09 	bl	8002aa0 <chSysLockFromISR>

    /* If a reload is defined the timer needs to be restarted.*/
    if (unlikely(vtp->reload > (sysinterval_t)0)) {
 8002e8e:	9b04      	ldr	r3, [sp, #16]
 8002e90:	695b      	ldr	r3, [r3, #20]
 8002e92:	2b00      	cmp	r3, #0
 8002e94:	bf14      	ite	ne
 8002e96:	2301      	movne	r3, #1
 8002e98:	2300      	moveq	r3, #0
 8002e9a:	b2db      	uxtb	r3, r3
 8002e9c:	2b00      	cmp	r3, #0
 8002e9e:	d0bd      	beq.n	8002e1c <chVTDoTickI+0xc>
      sysinterval_t delta, delay;

      /* Refreshing the now delta after spending time in the callback for
         a more accurate detection of too fast reloads.*/
      now = chVTGetSystemTimeX();
 8002ea0:	f7ff fe1e 	bl	8002ae0 <chVTGetSystemTimeX>
 8002ea4:	9003      	str	r0, [sp, #12]
      nowdelta = chTimeDiffX(lasttime, now);
 8002ea6:	9903      	ldr	r1, [sp, #12]
 8002ea8:	9801      	ldr	r0, [sp, #4]
 8002eaa:	f7ff fcf1 	bl	8002890 <chTimeDiffX>
 8002eae:	9002      	str	r0, [sp, #8]

#if !defined(CH_VT_RFCU_DISABLED)
      /* Checking if the required reload is feasible.*/
      if (nowdelta > vtp->reload) {
 8002eb0:	9b04      	ldr	r3, [sp, #16]
 8002eb2:	695b      	ldr	r3, [r3, #20]
 8002eb4:	9a02      	ldr	r2, [sp, #8]
 8002eb6:	429a      	cmp	r2, r3
 8002eb8:	d908      	bls.n	8002ecc <chVTDoTickI+0xbc>
        /* System time is already past the deadline, logging the fault and
           proceeding with a minimum delay.*/

        chDbgAssert(false, "skipped deadline");
 8002eba:	4827      	ldr	r0, [pc, #156]	; (8002f58 <chVTDoTickI+0x148>)
 8002ebc:	f7ff f9a0 	bl	8002200 <chSysHalt>
        chRFCUCollectFaultsI(CH_RFCU_VT_SKIPPED_DEADLINE);
 8002ec0:	2002      	movs	r0, #2
 8002ec2:	f7ff f9dd 	bl	8002280 <chRFCUCollectFaultsI>

        delay = (sysinterval_t)0;
 8002ec6:	2300      	movs	r3, #0
 8002ec8:	9306      	str	r3, [sp, #24]
 8002eca:	e004      	b.n	8002ed6 <chVTDoTickI+0xc6>
      }
      else {
        /* Enqueuing the timer again using the calculated delta.*/
        delay = vtp->reload - nowdelta;
 8002ecc:	9b04      	ldr	r3, [sp, #16]
 8002ece:	695a      	ldr	r2, [r3, #20]
 8002ed0:	9b02      	ldr	r3, [sp, #8]
 8002ed2:	1ad3      	subs	r3, r2, r3
 8002ed4:	9306      	str	r3, [sp, #24]
      /* Enqueuing the timer again using the calculated delta.*/
      delay = vtp->reload - nowdelta;
#endif

      /* Special case where the timers list is empty.*/
      if (ch_dlist_isempty(&vtlp->dlist)) {
 8002ed6:	9b05      	ldr	r3, [sp, #20]
 8002ed8:	4618      	mov	r0, r3
 8002eda:	f7ff fce9 	bl	80028b0 <ch_dlist_isempty>
 8002ede:	4603      	mov	r3, r0
 8002ee0:	2b00      	cmp	r3, #0
 8002ee2:	d006      	beq.n	8002ef2 <chVTDoTickI+0xe2>

        vt_insert_first(vtlp, vtp, now, delay);
 8002ee4:	9b06      	ldr	r3, [sp, #24]
 8002ee6:	9a03      	ldr	r2, [sp, #12]
 8002ee8:	9904      	ldr	r1, [sp, #16]
 8002eea:	9805      	ldr	r0, [sp, #20]
 8002eec:	f7ff fe48 	bl	8002b80 <vt_insert_first>

        return;
 8002ef0:	e02c      	b.n	8002f4c <chVTDoTickI+0x13c>

      /* Delay as delta from 'lasttime'. Note, it can overflow and the value
         becomes lower than 'nowdelta'. In that case the delta is shortened
         to make it fit the numeric range and the timer will be triggered
         "nowdelta" cycles earlier.*/
      delta = nowdelta + delay;
 8002ef2:	9a02      	ldr	r2, [sp, #8]
 8002ef4:	9b06      	ldr	r3, [sp, #24]
 8002ef6:	4413      	add	r3, r2
 8002ef8:	9307      	str	r3, [sp, #28]
      if (delta < nowdelta) {
 8002efa:	9a07      	ldr	r2, [sp, #28]
 8002efc:	9b02      	ldr	r3, [sp, #8]
 8002efe:	429a      	cmp	r2, r3
 8002f00:	d201      	bcs.n	8002f06 <chVTDoTickI+0xf6>
        delta = delay;
 8002f02:	9b06      	ldr	r3, [sp, #24]
 8002f04:	9307      	str	r3, [sp, #28]
      }

      /* Insert into delta list. */
      ch_dlist_insert(&vtlp->dlist, &vtp->dlist, delta);
 8002f06:	9b05      	ldr	r3, [sp, #20]
 8002f08:	9904      	ldr	r1, [sp, #16]
 8002f0a:	9a07      	ldr	r2, [sp, #28]
 8002f0c:	4618      	mov	r0, r3
 8002f0e:	f7ff fd2f 	bl	8002970 <ch_dlist_insert>
  while (true) {
 8002f12:	e783      	b.n	8002e1c <chVTDoTickI+0xc>
      break;
 8002f14:	bf00      	nop
    }
  }

  /* If the list is empty, nothing else to do.*/
  if (ch_dlist_isempty(&vtlp->dlist)) {
 8002f16:	9b05      	ldr	r3, [sp, #20]
 8002f18:	4618      	mov	r0, r3
 8002f1a:	f7ff fcc9 	bl	80028b0 <ch_dlist_isempty>
 8002f1e:	4603      	mov	r3, r0
 8002f20:	2b00      	cmp	r3, #0
 8002f22:	d112      	bne.n	8002f4a <chVTDoTickI+0x13a>
    return;
  }

  /* The "unprocessed nowdelta" time slice is added to "last time"
     and subtracted to next timer's delta.*/
  vtlp->lasttime += nowdelta;
 8002f24:	9b05      	ldr	r3, [sp, #20]
 8002f26:	68da      	ldr	r2, [r3, #12]
 8002f28:	9b02      	ldr	r3, [sp, #8]
 8002f2a:	441a      	add	r2, r3
 8002f2c:	9b05      	ldr	r3, [sp, #20]
 8002f2e:	60da      	str	r2, [r3, #12]
  vtp->dlist.delta -= nowdelta;
 8002f30:	9b04      	ldr	r3, [sp, #16]
 8002f32:	689a      	ldr	r2, [r3, #8]
 8002f34:	9b02      	ldr	r3, [sp, #8]
 8002f36:	1ad2      	subs	r2, r2, r3
 8002f38:	9b04      	ldr	r3, [sp, #16]
 8002f3a:	609a      	str	r2, [r3, #8]

  /* Update alarm time to next timer.*/
  vt_set_alarm(now, vtp->dlist.delta);
 8002f3c:	9b04      	ldr	r3, [sp, #16]
 8002f3e:	689b      	ldr	r3, [r3, #8]
 8002f40:	4619      	mov	r1, r3
 8002f42:	9803      	ldr	r0, [sp, #12]
 8002f44:	f7ff fde4 	bl	8002b10 <vt_set_alarm>
 8002f48:	e000      	b.n	8002f4c <chVTDoTickI+0x13c>
    return;
 8002f4a:	bf00      	nop
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8002f4c:	b009      	add	sp, #36	; 0x24
 8002f4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f52:	bf00      	nop
 8002f54:	200008b0 	.word	0x200008b0
 8002f58:	08004670 	.word	0x08004670
 8002f5c:	00000000 	.word	0x00000000

08002f60 <ch_queue_dequeue>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8002f60:	b082      	sub	sp, #8
 8002f62:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	685b      	ldr	r3, [r3, #4]
 8002f68:	9a01      	ldr	r2, [sp, #4]
 8002f6a:	6812      	ldr	r2, [r2, #0]
 8002f6c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 8002f6e:	9b01      	ldr	r3, [sp, #4]
 8002f70:	681b      	ldr	r3, [r3, #0]
 8002f72:	9a01      	ldr	r2, [sp, #4]
 8002f74:	6852      	ldr	r2, [r2, #4]
 8002f76:	605a      	str	r2, [r3, #4]
  return p;
 8002f78:	9b01      	ldr	r3, [sp, #4]
}
 8002f7a:	4618      	mov	r0, r3
 8002f7c:	b002      	add	sp, #8
 8002f7e:	4770      	bx	lr

08002f80 <ch_pqueue_remove_highest>:
static inline ch_priority_queue_t *ch_pqueue_remove_highest(ch_priority_queue_t *pqp) {
 8002f80:	b084      	sub	sp, #16
 8002f82:	9001      	str	r0, [sp, #4]
  ch_priority_queue_t *p = pqp->next;
 8002f84:	9b01      	ldr	r3, [sp, #4]
 8002f86:	681b      	ldr	r3, [r3, #0]
 8002f88:	9303      	str	r3, [sp, #12]
  pqp->next       = p->next;
 8002f8a:	9b03      	ldr	r3, [sp, #12]
 8002f8c:	681a      	ldr	r2, [r3, #0]
 8002f8e:	9b01      	ldr	r3, [sp, #4]
 8002f90:	601a      	str	r2, [r3, #0]
  pqp->next->prev = pqp;
 8002f92:	9b01      	ldr	r3, [sp, #4]
 8002f94:	681b      	ldr	r3, [r3, #0]
 8002f96:	9a01      	ldr	r2, [sp, #4]
 8002f98:	605a      	str	r2, [r3, #4]
  return p;
 8002f9a:	9b03      	ldr	r3, [sp, #12]
}
 8002f9c:	4618      	mov	r0, r3
 8002f9e:	b004      	add	sp, #16
 8002fa0:	4770      	bx	lr
 8002fa2:	bf00      	nop
	...

08002fb0 <ch_pqueue_insert_behind>:
                                                           ch_priority_queue_t *p) {
 8002fb0:	b082      	sub	sp, #8
 8002fb2:	9001      	str	r0, [sp, #4]
 8002fb4:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8002fb6:	9b01      	ldr	r3, [sp, #4]
 8002fb8:	681b      	ldr	r3, [r3, #0]
 8002fba:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio >= p->prio));
 8002fbc:	9b01      	ldr	r3, [sp, #4]
 8002fbe:	689a      	ldr	r2, [r3, #8]
 8002fc0:	9b00      	ldr	r3, [sp, #0]
 8002fc2:	689b      	ldr	r3, [r3, #8]
 8002fc4:	429a      	cmp	r2, r3
 8002fc6:	bf2c      	ite	cs
 8002fc8:	2301      	movcs	r3, #1
 8002fca:	2300      	movcc	r3, #0
 8002fcc:	b2db      	uxtb	r3, r3
 8002fce:	2b00      	cmp	r3, #0
 8002fd0:	d1f1      	bne.n	8002fb6 <ch_pqueue_insert_behind+0x6>
  p->next       = pqp;
 8002fd2:	9b00      	ldr	r3, [sp, #0]
 8002fd4:	9a01      	ldr	r2, [sp, #4]
 8002fd6:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8002fd8:	9b01      	ldr	r3, [sp, #4]
 8002fda:	685a      	ldr	r2, [r3, #4]
 8002fdc:	9b00      	ldr	r3, [sp, #0]
 8002fde:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8002fe0:	9b00      	ldr	r3, [sp, #0]
 8002fe2:	685b      	ldr	r3, [r3, #4]
 8002fe4:	9a00      	ldr	r2, [sp, #0]
 8002fe6:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8002fe8:	9b01      	ldr	r3, [sp, #4]
 8002fea:	9a00      	ldr	r2, [sp, #0]
 8002fec:	605a      	str	r2, [r3, #4]
  return p;
 8002fee:	9b00      	ldr	r3, [sp, #0]
}
 8002ff0:	4618      	mov	r0, r3
 8002ff2:	b002      	add	sp, #8
 8002ff4:	4770      	bx	lr
 8002ff6:	bf00      	nop
	...

08003000 <ch_pqueue_insert_ahead>:
                                                          ch_priority_queue_t *p) {
 8003000:	b082      	sub	sp, #8
 8003002:	9001      	str	r0, [sp, #4]
 8003004:	9100      	str	r1, [sp, #0]
    pqp = pqp->next;
 8003006:	9b01      	ldr	r3, [sp, #4]
 8003008:	681b      	ldr	r3, [r3, #0]
 800300a:	9301      	str	r3, [sp, #4]
  } while (unlikely(pqp->prio > p->prio));
 800300c:	9b01      	ldr	r3, [sp, #4]
 800300e:	689a      	ldr	r2, [r3, #8]
 8003010:	9b00      	ldr	r3, [sp, #0]
 8003012:	689b      	ldr	r3, [r3, #8]
 8003014:	429a      	cmp	r2, r3
 8003016:	bf8c      	ite	hi
 8003018:	2301      	movhi	r3, #1
 800301a:	2300      	movls	r3, #0
 800301c:	b2db      	uxtb	r3, r3
 800301e:	2b00      	cmp	r3, #0
 8003020:	d1f1      	bne.n	8003006 <ch_pqueue_insert_ahead+0x6>
  p->next       = pqp;
 8003022:	9b00      	ldr	r3, [sp, #0]
 8003024:	9a01      	ldr	r2, [sp, #4]
 8003026:	601a      	str	r2, [r3, #0]
  p->prev       = pqp->prev;
 8003028:	9b01      	ldr	r3, [sp, #4]
 800302a:	685a      	ldr	r2, [r3, #4]
 800302c:	9b00      	ldr	r3, [sp, #0]
 800302e:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003030:	9b00      	ldr	r3, [sp, #0]
 8003032:	685b      	ldr	r3, [r3, #4]
 8003034:	9a00      	ldr	r2, [sp, #0]
 8003036:	601a      	str	r2, [r3, #0]
  pqp->prev     = p;
 8003038:	9b01      	ldr	r3, [sp, #4]
 800303a:	9a00      	ldr	r2, [sp, #0]
 800303c:	605a      	str	r2, [r3, #4]
  return p;
 800303e:	9b00      	ldr	r3, [sp, #0]
}
 8003040:	4618      	mov	r0, r3
 8003042:	b002      	add	sp, #8
 8003044:	4770      	bx	lr
 8003046:	bf00      	nop
	...

08003050 <chSysLockFromISR>:
static inline void chSysLockFromISR(void) {
 8003050:	b500      	push	{lr}
 8003052:	b083      	sub	sp, #12
 8003054:	2330      	movs	r3, #48	; 0x30
 8003056:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003058:	9b01      	ldr	r3, [sp, #4]
 800305a:	f383 8811 	msr	BASEPRI, r3
}
 800305e:	bf00      	nop
}
 8003060:	bf00      	nop
}
 8003062:	bf00      	nop
  __dbg_check_lock_from_isr();
 8003064:	f7ff f96c 	bl	8002340 <__dbg_check_lock_from_isr>
}
 8003068:	bf00      	nop
 800306a:	b003      	add	sp, #12
 800306c:	f85d fb04 	ldr.w	pc, [sp], #4

08003070 <chSysUnlockFromISR>:
static inline void chSysUnlockFromISR(void) {
 8003070:	b500      	push	{lr}
 8003072:	b083      	sub	sp, #12
  __dbg_check_unlock_from_isr();
 8003074:	f7ff f98c 	bl	8002390 <__dbg_check_unlock_from_isr>
 8003078:	2300      	movs	r3, #0
 800307a:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 800307c:	9b01      	ldr	r3, [sp, #4]
 800307e:	f383 8811 	msr	BASEPRI, r3
}
 8003082:	bf00      	nop
}
 8003084:	bf00      	nop
}
 8003086:	bf00      	nop
}
 8003088:	bf00      	nop
 800308a:	b003      	add	sp, #12
 800308c:	f85d fb04 	ldr.w	pc, [sp], #4

08003090 <chVTIsArmedI>:
static inline bool chVTIsArmedI(const virtual_timer_t *vtp) {
 8003090:	b500      	push	{lr}
 8003092:	b083      	sub	sp, #12
 8003094:	9001      	str	r0, [sp, #4]
  chDbgCheckClassI();
 8003096:	f7ff fa1b 	bl	80024d0 <chDbgCheckClassI>
  return (bool)(vtp->dlist.next != NULL);
 800309a:	9b01      	ldr	r3, [sp, #4]
 800309c:	681b      	ldr	r3, [r3, #0]
 800309e:	2b00      	cmp	r3, #0
 80030a0:	bf14      	ite	ne
 80030a2:	2301      	movne	r3, #1
 80030a4:	2300      	moveq	r3, #0
 80030a6:	b2db      	uxtb	r3, r3
}
 80030a8:	4618      	mov	r0, r3
 80030aa:	b003      	add	sp, #12
 80030ac:	f85d fb04 	ldr.w	pc, [sp], #4

080030b0 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 80030b0:	b500      	push	{lr}
 80030b2:	b083      	sub	sp, #12
 80030b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 80030b6:	f7ff fa0b 	bl	80024d0 <chDbgCheckClassI>

  sp->cnt++;
 80030ba:	9b01      	ldr	r3, [sp, #4]
 80030bc:	689b      	ldr	r3, [r3, #8]
 80030be:	1c5a      	adds	r2, r3, #1
 80030c0:	9b01      	ldr	r3, [sp, #4]
 80030c2:	609a      	str	r2, [r3, #8]
}
 80030c4:	bf00      	nop
 80030c6:	b003      	add	sp, #12
 80030c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80030cc:	0000      	movs	r0, r0
	...

080030d0 <__sch_ready_behind>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_behind(thread_t *tp) {
 80030d0:	b500      	push	{lr}
 80030d2:	b083      	sub	sp, #12
 80030d4:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 80030d6:	9b01      	ldr	r3, [sp, #4]
 80030d8:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80030dc:	2b00      	cmp	r3, #0
 80030de:	bf0c      	ite	eq
 80030e0:	2301      	moveq	r3, #1
 80030e2:	2300      	movne	r3, #0
 80030e4:	b2db      	uxtb	r3, r3
 80030e6:	2b00      	cmp	r3, #0
 80030e8:	d109      	bne.n	80030fe <__sch_ready_behind+0x2e>
 80030ea:	9b01      	ldr	r3, [sp, #4]
 80030ec:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80030f0:	2b0f      	cmp	r3, #15
 80030f2:	bf0c      	ite	eq
 80030f4:	2301      	moveq	r3, #1
 80030f6:	2300      	movne	r3, #0
 80030f8:	b2db      	uxtb	r3, r3
 80030fa:	2b00      	cmp	r3, #0
 80030fc:	d002      	beq.n	8003104 <__sch_ready_behind+0x34>
 80030fe:	480d      	ldr	r0, [pc, #52]	; (8003134 <__sch_ready_behind+0x64>)
 8003100:	f7ff f87e 	bl	8002200 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003108:	4619      	mov	r1, r3
 800310a:	9801      	ldr	r0, [sp, #4]
 800310c:	f7ff fa90 	bl	8002630 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003110:	9b01      	ldr	r3, [sp, #4]
 8003112:	2200      	movs	r2, #0
 8003114:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_behind(&tp->owner->rlist.pqueue,
 8003118:	9b01      	ldr	r3, [sp, #4]
 800311a:	699b      	ldr	r3, [r3, #24]
 800311c:	461a      	mov	r2, r3
 800311e:	9b01      	ldr	r3, [sp, #4]
 8003120:	4619      	mov	r1, r3
 8003122:	4610      	mov	r0, r2
 8003124:	f7ff ff44 	bl	8002fb0 <ch_pqueue_insert_behind>
 8003128:	4603      	mov	r3, r0
                                           &tp->hdr.pqueue));
}
 800312a:	4618      	mov	r0, r3
 800312c:	b003      	add	sp, #12
 800312e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003132:	bf00      	nop
 8003134:	0800467c 	.word	0x0800467c
	...

08003140 <__sch_ready_ahead>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @notapi
 */
static thread_t *__sch_ready_ahead(thread_t *tp) {
 8003140:	b500      	push	{lr}
 8003142:	b083      	sub	sp, #12
 8003144:	9001      	str	r0, [sp, #4]

  chDbgAssert((tp->state != CH_STATE_READY) &&
 8003146:	9b01      	ldr	r3, [sp, #4]
 8003148:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 800314c:	2b00      	cmp	r3, #0
 800314e:	bf0c      	ite	eq
 8003150:	2301      	moveq	r3, #1
 8003152:	2300      	movne	r3, #0
 8003154:	b2db      	uxtb	r3, r3
 8003156:	2b00      	cmp	r3, #0
 8003158:	d109      	bne.n	800316e <__sch_ready_ahead+0x2e>
 800315a:	9b01      	ldr	r3, [sp, #4]
 800315c:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 8003160:	2b0f      	cmp	r3, #15
 8003162:	bf0c      	ite	eq
 8003164:	2301      	moveq	r3, #1
 8003166:	2300      	movne	r3, #0
 8003168:	b2db      	uxtb	r3, r3
 800316a:	2b00      	cmp	r3, #0
 800316c:	d002      	beq.n	8003174 <__sch_ready_ahead+0x34>
 800316e:	480d      	ldr	r0, [pc, #52]	; (80031a4 <__sch_ready_ahead+0x64>)
 8003170:	f7ff f846 	bl	8002200 <chSysHalt>
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  /* Tracing the event.*/
  __trace_ready(tp, tp->u.rdymsg);
 8003174:	9b01      	ldr	r3, [sp, #4]
 8003176:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003178:	4619      	mov	r1, r3
 800317a:	9801      	ldr	r0, [sp, #4]
 800317c:	f7ff fa58 	bl	8002630 <__trace_ready>

  /* The thread is marked ready.*/
  tp->state = CH_STATE_READY;
 8003180:	9b01      	ldr	r3, [sp, #4]
 8003182:	2200      	movs	r2, #0
 8003184:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24

  /* Insertion in the priority queue.*/
  return threadref(ch_pqueue_insert_ahead(&tp->owner->rlist.pqueue,
 8003188:	9b01      	ldr	r3, [sp, #4]
 800318a:	699b      	ldr	r3, [r3, #24]
 800318c:	461a      	mov	r2, r3
 800318e:	9b01      	ldr	r3, [sp, #4]
 8003190:	4619      	mov	r1, r3
 8003192:	4610      	mov	r0, r2
 8003194:	f7ff ff34 	bl	8003000 <ch_pqueue_insert_ahead>
 8003198:	4603      	mov	r3, r0
                                          &tp->hdr.pqueue));
}
 800319a:	4618      	mov	r0, r3
 800319c:	b003      	add	sp, #12
 800319e:	f85d fb04 	ldr.w	pc, [sp], #4
 80031a2:	bf00      	nop
 80031a4:	08004690 	.word	0x08004690
	...

080031b0 <__sch_wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void __sch_wakeup(virtual_timer_t *vtp, void *p) {
 80031b0:	b500      	push	{lr}
 80031b2:	b085      	sub	sp, #20
 80031b4:	9001      	str	r0, [sp, #4]
 80031b6:	9100      	str	r1, [sp, #0]
  thread_t *tp = threadref(p);
 80031b8:	9b00      	ldr	r3, [sp, #0]
 80031ba:	9303      	str	r3, [sp, #12]

  (void)vtp;

  chSysLockFromISR();
 80031bc:	f7ff ff48 	bl	8003050 <chSysLockFromISR>
  switch (tp->state) {
 80031c0:	9b03      	ldr	r3, [sp, #12]
 80031c2:	f893 3024 	ldrb.w	r3, [r3, #36]	; 0x24
 80031c6:	2b0c      	cmp	r3, #12
 80031c8:	d82e      	bhi.n	8003228 <__sch_wakeup+0x78>
 80031ca:	a201      	add	r2, pc, #4	; (adr r2, 80031d0 <__sch_wakeup+0x20>)
 80031cc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80031d0:	08003205 	.word	0x08003205
 80031d4:	08003229 	.word	0x08003229
 80031d8:	08003229 	.word	0x08003229
 80031dc:	0800320b 	.word	0x0800320b
 80031e0:	0800321f 	.word	0x0800321f
 80031e4:	08003215 	.word	0x08003215
 80031e8:	08003229 	.word	0x08003229
 80031ec:	0800321f 	.word	0x0800321f
 80031f0:	08003229 	.word	0x08003229
 80031f4:	08003229 	.word	0x08003229
 80031f8:	08003229 	.word	0x08003229
 80031fc:	08003229 	.word	0x08003229
 8003200:	0800321f 	.word	0x0800321f
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8003204:	f7ff ff34 	bl	8003070 <chSysUnlockFromISR>
    return;
 8003208:	e019      	b.n	800323e <__sch_wakeup+0x8e>
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 800320a:	9b03      	ldr	r3, [sp, #12]
 800320c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800320e:	2200      	movs	r2, #0
 8003210:	601a      	str	r2, [r3, #0]
    break;
 8003212:	e00a      	b.n	800322a <__sch_wakeup+0x7a>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8003214:	9b03      	ldr	r3, [sp, #12]
 8003216:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8003218:	4618      	mov	r0, r3
 800321a:	f7ff ff49 	bl	80030b0 <chSemFastSignalI>
#endif
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
    /* States requiring dequeuing.*/
    (void) ch_queue_dequeue(&tp->hdr.queue);
 800321e:	9b03      	ldr	r3, [sp, #12]
 8003220:	4618      	mov	r0, r3
 8003222:	f7ff fe9d 	bl	8002f60 <ch_queue_dequeue>
    break;
 8003226:	e000      	b.n	800322a <__sch_wakeup+0x7a>
  default:
    /* Any other state, nothing to do.*/
    break;
 8003228:	bf00      	nop
  }

  /* Standard message for timeout conditions.*/
  tp->u.rdymsg = MSG_TIMEOUT;
 800322a:	9b03      	ldr	r3, [sp, #12]
 800322c:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003230:	629a      	str	r2, [r3, #40]	; 0x28

  /* Goes behind peers because it went to sleep voluntarily.*/
  (void) __sch_ready_behind(tp);
 8003232:	9803      	ldr	r0, [sp, #12]
 8003234:	f7ff ff4c 	bl	80030d0 <__sch_ready_behind>
  chSysUnlockFromISR();
 8003238:	f7ff ff1a 	bl	8003070 <chSysUnlockFromISR>

  return;
 800323c:	bf00      	nop
}
 800323e:	b005      	add	sp, #20
 8003240:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003250 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8003250:	b500      	push	{lr}
 8003252:	b083      	sub	sp, #12
 8003254:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
 8003256:	f7ff f93b 	bl	80024d0 <chDbgCheckClassI>
  chDbgCheck(tp != NULL);
 800325a:	9b01      	ldr	r3, [sp, #4]
 800325c:	2b00      	cmp	r3, #0
 800325e:	bf0c      	ite	eq
 8003260:	2301      	moveq	r3, #1
 8003262:	2300      	movne	r3, #0
 8003264:	b2db      	uxtb	r3, r3
 8003266:	2b00      	cmp	r3, #0
 8003268:	d002      	beq.n	8003270 <chSchReadyI+0x20>
 800326a:	4805      	ldr	r0, [pc, #20]	; (8003280 <chSchReadyI+0x30>)
 800326c:	f7fe ffc8 	bl	8002200 <chSysHalt>
       the other core.*/
    chSysNotifyInstance(tp->owner);
  }
#endif

  return __sch_ready_behind(tp);
 8003270:	9801      	ldr	r0, [sp, #4]
 8003272:	f7ff ff2d 	bl	80030d0 <__sch_ready_behind>
 8003276:	4603      	mov	r3, r0
}
 8003278:	4618      	mov	r0, r3
 800327a:	b003      	add	sp, #12
 800327c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003280:	080046a4 	.word	0x080046a4
	...

08003290 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8003290:	b500      	push	{lr}
 8003292:	b089      	sub	sp, #36	; 0x24
 8003294:	4603      	mov	r3, r0
 8003296:	f88d 3007 	strb.w	r3, [sp, #7]
  os_instance_t *oip = currcore;
 800329a:	4b27      	ldr	r3, [pc, #156]	; (8003338 <chSchGoSleepS+0xa8>)
 800329c:	9307      	str	r3, [sp, #28]
  thread_t *otp = __instance_get_currthread(oip);
 800329e:	9b07      	ldr	r3, [sp, #28]
 80032a0:	68db      	ldr	r3, [r3, #12]
 80032a2:	9306      	str	r3, [sp, #24]
  thread_t *ntp;

  chDbgCheckClassS();
 80032a4:	f7ff f934 	bl	8002510 <chDbgCheckClassS>

  chDbgAssert(otp != chSysGetIdleThreadX(), "sleeping in idle thread");
 80032a8:	f7fe ffc2 	bl	8002230 <chSysGetIdleThreadX>
 80032ac:	4602      	mov	r2, r0
 80032ae:	9b06      	ldr	r3, [sp, #24]
 80032b0:	4293      	cmp	r3, r2
 80032b2:	bf0c      	ite	eq
 80032b4:	2301      	moveq	r3, #1
 80032b6:	2300      	movne	r3, #0
 80032b8:	b2db      	uxtb	r3, r3
 80032ba:	2b00      	cmp	r3, #0
 80032bc:	d002      	beq.n	80032c4 <chSchGoSleepS+0x34>
 80032be:	481f      	ldr	r0, [pc, #124]	; (800333c <chSchGoSleepS+0xac>)
 80032c0:	f7fe ff9e 	bl	8002200 <chSysHalt>
  chDbgAssert(otp->owner == oip, "invalid core");
 80032c4:	9b06      	ldr	r3, [sp, #24]
 80032c6:	699b      	ldr	r3, [r3, #24]
 80032c8:	9a07      	ldr	r2, [sp, #28]
 80032ca:	429a      	cmp	r2, r3
 80032cc:	bf14      	ite	ne
 80032ce:	2301      	movne	r3, #1
 80032d0:	2300      	moveq	r3, #0
 80032d2:	b2db      	uxtb	r3, r3
 80032d4:	2b00      	cmp	r3, #0
 80032d6:	d002      	beq.n	80032de <chSchGoSleepS+0x4e>
 80032d8:	4818      	ldr	r0, [pc, #96]	; (800333c <chSchGoSleepS+0xac>)
 80032da:	f7fe ff91 	bl	8002200 <chSysHalt>

  /* New state.*/
  otp->state = newstate;
 80032de:	9b06      	ldr	r3, [sp, #24]
 80032e0:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80032e4:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
     time quantum when it will wakeup.*/
  otp->ticks = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 80032e8:	9b07      	ldr	r3, [sp, #28]
 80032ea:	4618      	mov	r0, r3
 80032ec:	f7ff fe48 	bl	8002f80 <ch_pqueue_remove_highest>
 80032f0:	9005      	str	r0, [sp, #20]
  ntp->state = CH_STATE_CURRENT;
 80032f2:	9b05      	ldr	r3, [sp, #20]
 80032f4:	2201      	movs	r2, #1
 80032f6:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 80032fa:	9b07      	ldr	r3, [sp, #28]
 80032fc:	9a05      	ldr	r2, [sp, #20]
 80032fe:	60da      	str	r2, [r3, #12]
  if (ntp->hdr.pqueue.prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 8003300:	9906      	ldr	r1, [sp, #24]
 8003302:	9805      	ldr	r0, [sp, #20]
 8003304:	f7ff f9cc 	bl	80026a0 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003308:	f3ef 8309 	mrs	r3, PSP
 800330c:	9303      	str	r3, [sp, #12]
  return(result);
 800330e:	9b03      	ldr	r3, [sp, #12]
 8003310:	9304      	str	r3, [sp, #16]
 8003312:	9b04      	ldr	r3, [sp, #16]
 8003314:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003318:	9b06      	ldr	r3, [sp, #24]
 800331a:	6a1b      	ldr	r3, [r3, #32]
 800331c:	429a      	cmp	r2, r3
 800331e:	d202      	bcs.n	8003326 <chSchGoSleepS+0x96>
 8003320:	4807      	ldr	r0, [pc, #28]	; (8003340 <chSchGoSleepS+0xb0>)
 8003322:	f7fe ff6d 	bl	8002200 <chSysHalt>
 8003326:	9906      	ldr	r1, [sp, #24]
 8003328:	9805      	ldr	r0, [sp, #20]
 800332a:	f7fc ffc9 	bl	80002c0 <__port_switch>
}
 800332e:	bf00      	nop
 8003330:	b009      	add	sp, #36	; 0x24
 8003332:	f85d fb04 	ldr.w	pc, [sp], #4
 8003336:	bf00      	nop
 8003338:	200008a0 	.word	0x200008a0
 800333c:	080046b0 	.word	0x080046b0
 8003340:	08004308 	.word	0x08004308
	...

08003350 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, sysinterval_t timeout) {
 8003350:	b500      	push	{lr}
 8003352:	b08b      	sub	sp, #44	; 0x2c
 8003354:	4603      	mov	r3, r0
 8003356:	9100      	str	r1, [sp, #0]
 8003358:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *tp = __instance_get_currthread(currcore);
 800335c:	4b15      	ldr	r3, [pc, #84]	; (80033b4 <chSchGoSleepTimeoutS+0x64>)
 800335e:	68db      	ldr	r3, [r3, #12]
 8003360:	9309      	str	r3, [sp, #36]	; 0x24

  chDbgCheckClassS();
 8003362:	f7ff f8d5 	bl	8002510 <chDbgCheckClassS>

  if (TIME_INFINITE != timeout) {
 8003366:	9b00      	ldr	r3, [sp, #0]
 8003368:	f1b3 3fff 	cmp.w	r3, #4294967295	; 0xffffffff
 800336c:	d016      	beq.n	800339c <chSchGoSleepTimeoutS+0x4c>
    virtual_timer_t vt;

    chVTDoSetI(&vt, timeout, __sch_wakeup, (void *)tp);
 800336e:	a803      	add	r0, sp, #12
 8003370:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003372:	4a11      	ldr	r2, [pc, #68]	; (80033b8 <chSchGoSleepTimeoutS+0x68>)
 8003374:	9900      	ldr	r1, [sp, #0]
 8003376:	f7ff fc8b 	bl	8002c90 <chVTDoSetI>
    chSchGoSleepS(newstate);
 800337a:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800337e:	4618      	mov	r0, r3
 8003380:	f7ff ff86 	bl	8003290 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8003384:	ab03      	add	r3, sp, #12
 8003386:	4618      	mov	r0, r3
 8003388:	f7ff fe82 	bl	8003090 <chVTIsArmedI>
 800338c:	4603      	mov	r3, r0
 800338e:	2b00      	cmp	r3, #0
 8003390:	d009      	beq.n	80033a6 <chSchGoSleepTimeoutS+0x56>
      chVTDoResetI(&vt);
 8003392:	ab03      	add	r3, sp, #12
 8003394:	4618      	mov	r0, r3
 8003396:	f7ff fcbb 	bl	8002d10 <chVTDoResetI>
 800339a:	e004      	b.n	80033a6 <chSchGoSleepTimeoutS+0x56>
    }
  }
  else {
    chSchGoSleepS(newstate);
 800339c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80033a0:	4618      	mov	r0, r3
 80033a2:	f7ff ff75 	bl	8003290 <chSchGoSleepS>
  }

  return tp->u.rdymsg;
 80033a6:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80033a8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
}
 80033aa:	4618      	mov	r0, r3
 80033ac:	b00b      	add	sp, #44	; 0x2c
 80033ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80033b2:	bf00      	nop
 80033b4:	200008a0 	.word	0x200008a0
 80033b8:	080031b1 	.word	0x080031b1
 80033bc:	00000000 	.word	0x00000000

080033c0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 80033c0:	b084      	sub	sp, #16
  os_instance_t *oip = currcore;
 80033c2:	4b0b      	ldr	r3, [pc, #44]	; (80033f0 <chSchIsPreemptionRequired+0x30>)
 80033c4:	9303      	str	r3, [sp, #12]
  thread_t *tp = __instance_get_currthread(oip);
 80033c6:	9b03      	ldr	r3, [sp, #12]
 80033c8:	68db      	ldr	r3, [r3, #12]
 80033ca:	9302      	str	r3, [sp, #8]

  tprio_t p1 = firstprio(&oip->rlist.pqueue);
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	681b      	ldr	r3, [r3, #0]
 80033d0:	689b      	ldr	r3, [r3, #8]
 80033d2:	9301      	str	r3, [sp, #4]
  tprio_t p2 = tp->hdr.pqueue.prio;
 80033d4:	9b02      	ldr	r3, [sp, #8]
 80033d6:	689b      	ldr	r3, [r3, #8]
 80033d8:	9300      	str	r3, [sp, #0]
     if the first thread on the ready queue has equal or higher priority.*/
  return (tp->ticks > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
 80033da:	9a01      	ldr	r2, [sp, #4]
 80033dc:	9b00      	ldr	r3, [sp, #0]
 80033de:	429a      	cmp	r2, r3
 80033e0:	bf8c      	ite	hi
 80033e2:	2301      	movhi	r3, #1
 80033e4:	2300      	movls	r3, #0
 80033e6:	b2db      	uxtb	r3, r3
#endif
}
 80033e8:	4618      	mov	r0, r3
 80033ea:	b004      	add	sp, #16
 80033ec:	4770      	bx	lr
 80033ee:	bf00      	nop
 80033f0:	200008a0 	.word	0x200008a0
	...

08003400 <chSchDoPreemption>:
 * @note    Not a user function, it is meant to be invoked from within
 *          the port layer in the IRQ-related preemption code.
 *
 * @special
 */
void chSchDoPreemption(void) {
 8003400:	b500      	push	{lr}
 8003402:	b087      	sub	sp, #28
  os_instance_t *oip = currcore;
 8003404:	4b17      	ldr	r3, [pc, #92]	; (8003464 <chSchDoPreemption+0x64>)
 8003406:	9305      	str	r3, [sp, #20]
  thread_t *otp = __instance_get_currthread(oip);
 8003408:	9b05      	ldr	r3, [sp, #20]
 800340a:	68db      	ldr	r3, [r3, #12]
 800340c:	9304      	str	r3, [sp, #16]
  thread_t *ntp;

  /* Picks the first thread from the ready queue and makes it current.*/
  ntp = threadref(ch_pqueue_remove_highest(&oip->rlist.pqueue));
 800340e:	9b05      	ldr	r3, [sp, #20]
 8003410:	4618      	mov	r0, r3
 8003412:	f7ff fdb5 	bl	8002f80 <ch_pqueue_remove_highest>
 8003416:	9003      	str	r0, [sp, #12]
  ntp->state = CH_STATE_CURRENT;
 8003418:	9b03      	ldr	r3, [sp, #12]
 800341a:	2201      	movs	r2, #1
 800341c:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  __instance_set_currthread(oip, ntp);
 8003420:	9b05      	ldr	r3, [sp, #20]
 8003422:	9a03      	ldr	r2, [sp, #12]
 8003424:	60da      	str	r2, [r3, #12]
    otp = __sch_ready_ahead(otp);
  }
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  otp = __sch_ready_ahead(otp);
 8003426:	9804      	ldr	r0, [sp, #16]
 8003428:	f7ff fe8a 	bl	8003140 <__sch_ready_ahead>
 800342c:	9004      	str	r0, [sp, #16]
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(ntp, otp);
 800342e:	9904      	ldr	r1, [sp, #16]
 8003430:	9803      	ldr	r0, [sp, #12]
 8003432:	f7ff f935 	bl	80026a0 <__trace_switch>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003436:	f3ef 8309 	mrs	r3, PSP
 800343a:	9301      	str	r3, [sp, #4]
  return(result);
 800343c:	9b01      	ldr	r3, [sp, #4]
 800343e:	9302      	str	r3, [sp, #8]
 8003440:	9b02      	ldr	r3, [sp, #8]
 8003442:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003446:	9b04      	ldr	r3, [sp, #16]
 8003448:	6a1b      	ldr	r3, [r3, #32]
 800344a:	429a      	cmp	r2, r3
 800344c:	d202      	bcs.n	8003454 <chSchDoPreemption+0x54>
 800344e:	4806      	ldr	r0, [pc, #24]	; (8003468 <chSchDoPreemption+0x68>)
 8003450:	f7fe fed6 	bl	8002200 <chSysHalt>
 8003454:	9904      	ldr	r1, [sp, #16]
 8003456:	9803      	ldr	r0, [sp, #12]
 8003458:	f7fc ff32 	bl	80002c0 <__port_switch>
}
 800345c:	bf00      	nop
 800345e:	b007      	add	sp, #28
 8003460:	f85d fb04 	ldr.w	pc, [sp], #4
 8003464:	200008a0 	.word	0x200008a0
 8003468:	08004308 	.word	0x08004308
 800346c:	00000000 	.word	0x00000000

08003470 <__rfcu_object_init>:
 *
 * @param[out] rfcup    pointer to the @p rfcu_t structure
 *
 * @notapi
 */
static inline void __rfcu_object_init(rfcu_t *rfcup) {
 8003470:	b082      	sub	sp, #8
 8003472:	9001      	str	r0, [sp, #4]

  rfcup->mask = (rfcu_mask_t)0;
 8003474:	9b01      	ldr	r3, [sp, #4]
 8003476:	2200      	movs	r2, #0
 8003478:	601a      	str	r2, [r3, #0]
}
 800347a:	bf00      	nop
 800347c:	b002      	add	sp, #8
 800347e:	4770      	bx	lr

08003480 <__dbg_object_init>:
 *
 * @param[out] sdp      pointer to the @p system_debug_t structure
 *
 * @notapi
 */
static inline void __dbg_object_init(system_debug_t *sdp) {
 8003480:	b082      	sub	sp, #8
 8003482:	9001      	str	r0, [sp, #4]

  sdp->panic_msg = NULL;
 8003484:	9b01      	ldr	r3, [sp, #4]
 8003486:	2200      	movs	r2, #0
 8003488:	601a      	str	r2, [r3, #0]

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  /* The initial state is assumed to be within a critical zone.*/
  sdp->isr_cnt  = (cnt_t)0;
 800348a:	9b01      	ldr	r3, [sp, #4]
 800348c:	2200      	movs	r2, #0
 800348e:	605a      	str	r2, [r3, #4]
  sdp->lock_cnt = (cnt_t)1;
 8003490:	9b01      	ldr	r3, [sp, #4]
 8003492:	2201      	movs	r2, #1
 8003494:	609a      	str	r2, [r3, #8]
#endif
}
 8003496:	bf00      	nop
 8003498:	b002      	add	sp, #8
 800349a:	4770      	bx	lr
 800349c:	0000      	movs	r0, r0
	...

080034a0 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80034a0:	b082      	sub	sp, #8
 80034a2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80034a4:	9b01      	ldr	r3, [sp, #4]
 80034a6:	9a01      	ldr	r2, [sp, #4]
 80034a8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80034aa:	9b01      	ldr	r3, [sp, #4]
 80034ac:	9a01      	ldr	r2, [sp, #4]
 80034ae:	605a      	str	r2, [r3, #4]
}
 80034b0:	bf00      	nop
 80034b2:	b002      	add	sp, #8
 80034b4:	4770      	bx	lr
 80034b6:	bf00      	nop
	...

080034c0 <ch_pqueue_init>:
static inline void ch_pqueue_init(ch_priority_queue_t *pqp) {
 80034c0:	b082      	sub	sp, #8
 80034c2:	9001      	str	r0, [sp, #4]
  pqp->next = pqp;
 80034c4:	9b01      	ldr	r3, [sp, #4]
 80034c6:	9a01      	ldr	r2, [sp, #4]
 80034c8:	601a      	str	r2, [r3, #0]
  pqp->prev = pqp;
 80034ca:	9b01      	ldr	r3, [sp, #4]
 80034cc:	9a01      	ldr	r2, [sp, #4]
 80034ce:	605a      	str	r2, [r3, #4]
  pqp->prio = (tprio_t)0;
 80034d0:	9b01      	ldr	r3, [sp, #4]
 80034d2:	2200      	movs	r2, #0
 80034d4:	609a      	str	r2, [r3, #8]
}
 80034d6:	bf00      	nop
 80034d8:	b002      	add	sp, #8
 80034da:	4770      	bx	lr
 80034dc:	0000      	movs	r0, r0
	...

080034e0 <ch_dlist_init>:
static inline void ch_dlist_init(ch_delta_list_t *dlhp) {
 80034e0:	b082      	sub	sp, #8
 80034e2:	9001      	str	r0, [sp, #4]
  dlhp->next  = dlhp;
 80034e4:	9b01      	ldr	r3, [sp, #4]
 80034e6:	9a01      	ldr	r2, [sp, #4]
 80034e8:	601a      	str	r2, [r3, #0]
  dlhp->prev  = dlhp;
 80034ea:	9b01      	ldr	r3, [sp, #4]
 80034ec:	9a01      	ldr	r2, [sp, #4]
 80034ee:	605a      	str	r2, [r3, #4]
  dlhp->delta = (sysinterval_t)-1;
 80034f0:	9b01      	ldr	r3, [sp, #4]
 80034f2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80034f6:	609a      	str	r2, [r3, #8]
}
 80034f8:	bf00      	nop
 80034fa:	b002      	add	sp, #8
 80034fc:	4770      	bx	lr
 80034fe:	bf00      	nop

08003500 <port_timer_get_time>:
static inline systime_t port_timer_get_time(void) {
 8003500:	b508      	push	{r3, lr}
  return stGetCounter();
 8003502:	f7fc ffbd 	bl	8000480 <stGetCounter>
 8003506:	4603      	mov	r3, r0
}
 8003508:	4618      	mov	r0, r3
 800350a:	bd08      	pop	{r3, pc}
 800350c:	0000      	movs	r0, r0
	...

08003510 <chVTGetSystemTimeX>:
static inline systime_t chVTGetSystemTimeX(void) {
 8003510:	b508      	push	{r3, lr}
  return port_timer_get_time();
 8003512:	f7ff fff5 	bl	8003500 <port_timer_get_time>
 8003516:	4603      	mov	r3, r0
}
 8003518:	4618      	mov	r0, r3
 800351a:	bd08      	pop	{r3, pc}
 800351c:	0000      	movs	r0, r0
	...

08003520 <__vt_object_init>:
 *
 * @param[out] vtlp     pointer to the @p virtual_timers_list_t structure
 *
 * @notapi
 */
static inline void __vt_object_init(virtual_timers_list_t *vtlp) {
 8003520:	b530      	push	{r4, r5, lr}
 8003522:	b083      	sub	sp, #12
 8003524:	9001      	str	r0, [sp, #4]

  ch_dlist_init(&vtlp->dlist);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	4618      	mov	r0, r3
 800352a:	f7ff ffd9 	bl	80034e0 <ch_dlist_init>
#if CH_CFG_ST_TIMEDELTA == 0
  vtlp->systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  vtlp->lasttime = (systime_t)0;
 800352e:	9b01      	ldr	r3, [sp, #4]
 8003530:	2200      	movs	r2, #0
 8003532:	60da      	str	r2, [r3, #12]
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
#if CH_CFG_USE_TIMESTAMP == TRUE
  vtlp->laststamp = (systimestamp_t)chVTGetSystemTimeX();
 8003534:	f7ff ffec 	bl	8003510 <chVTGetSystemTimeX>
 8003538:	4603      	mov	r3, r0
 800353a:	2200      	movs	r2, #0
 800353c:	461c      	mov	r4, r3
 800353e:	4615      	mov	r5, r2
 8003540:	9b01      	ldr	r3, [sp, #4]
 8003542:	e9c3 4504 	strd	r4, r5, [r3, #16]
#endif
}
 8003546:	bf00      	nop
 8003548:	b003      	add	sp, #12
 800354a:	bd30      	pop	{r4, r5, pc}
 800354c:	0000      	movs	r0, r0
	...

08003550 <__reg_object_init>:
 *
 * @param[out] rp       pointer to a @p registry_t structure
 *
 * @init
 */
static inline void __reg_object_init(registry_t *rp) {
 8003550:	b500      	push	{lr}
 8003552:	b083      	sub	sp, #12
 8003554:	9001      	str	r0, [sp, #4]

  ch_queue_init(&rp->queue);
 8003556:	9b01      	ldr	r3, [sp, #4]
 8003558:	4618      	mov	r0, r3
 800355a:	f7ff ffa1 	bl	80034a0 <ch_queue_init>
}
 800355e:	bf00      	nop
 8003560:	b003      	add	sp, #12
 8003562:	f85d fb04 	ldr.w	pc, [sp], #4
 8003566:	bf00      	nop
	...

08003570 <__idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void __idle_thread(void *p) {
 8003570:	b082      	sub	sp, #8
 8003572:	9001      	str	r0, [sp, #4]
}
 8003574:	bf00      	nop
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8003576:	e7fd      	b.n	8003574 <__idle_thread+0x4>
	...

08003580 <chInstanceObjectInit>:
 * @param[in] oicp      pointer to the @p os_instance_config_t structure
 *
 * @special
 */
void chInstanceObjectInit(os_instance_t *oip,
                          const os_instance_config_t *oicp) {
 8003580:	b500      	push	{lr}
 8003582:	b08b      	sub	sp, #44	; 0x2c
 8003584:	9001      	str	r0, [sp, #4]
 8003586:	9100      	str	r1, [sp, #0]

  /* Registering into the global system structure.*/
#if CH_CFG_SMP_MODE == TRUE
  core_id = port_get_core_id();
#else
  core_id = 0U;
 8003588:	2300      	movs	r3, #0
 800358a:	9309      	str	r3, [sp, #36]	; 0x24
#endif
  chDbgAssert(ch_system.instances[core_id] == NULL, "instance already registered");
 800358c:	4a35      	ldr	r2, [pc, #212]	; (8003664 <chInstanceObjectInit+0xe4>)
 800358e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003590:	009b      	lsls	r3, r3, #2
 8003592:	4413      	add	r3, r2
 8003594:	685b      	ldr	r3, [r3, #4]
 8003596:	2b00      	cmp	r3, #0
 8003598:	bf14      	ite	ne
 800359a:	2301      	movne	r3, #1
 800359c:	2300      	moveq	r3, #0
 800359e:	b2db      	uxtb	r3, r3
 80035a0:	2b00      	cmp	r3, #0
 80035a2:	d002      	beq.n	80035aa <chInstanceObjectInit+0x2a>
 80035a4:	4830      	ldr	r0, [pc, #192]	; (8003668 <chInstanceObjectInit+0xe8>)
 80035a6:	f7fe fe2b 	bl	8002200 <chSysHalt>
  ch_system.instances[core_id] = oip;
 80035aa:	4a2e      	ldr	r2, [pc, #184]	; (8003664 <chInstanceObjectInit+0xe4>)
 80035ac:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80035ae:	009b      	lsls	r3, r3, #2
 80035b0:	4413      	add	r3, r2
 80035b2:	9a01      	ldr	r2, [sp, #4]
 80035b4:	605a      	str	r2, [r3, #4]

  /* Core associated to this instance.*/
  oip->core_id = core_id;
 80035b6:	9b01      	ldr	r3, [sp, #4]
 80035b8:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80035ba:	631a      	str	r2, [r3, #48]	; 0x30

  /* Keeping a reference to the configuration data.*/
  oip->config = oicp;
 80035bc:	9b01      	ldr	r3, [sp, #4]
 80035be:	9a00      	ldr	r2, [sp, #0]
 80035c0:	639a      	str	r2, [r3, #56]	; 0x38

  /* Port initialization for the current instance.*/
  port_init(oip);
 80035c2:	9801      	ldr	r0, [sp, #4]
 80035c4:	f000 fd14 	bl	8003ff0 <port_init>

  /* Ready list initialization.*/
  ch_pqueue_init(&oip->rlist.pqueue);
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	4618      	mov	r0, r3
 80035cc:	f7ff ff78 	bl	80034c0 <ch_pqueue_init>

#if (CH_CFG_USE_REGISTRY == TRUE) && (CH_CFG_SMP_MODE == FALSE)
  /* Registry initialization when SMP mode is disabled.*/
  __reg_object_init(&oip->reglist);
 80035d0:	9b01      	ldr	r3, [sp, #4]
 80035d2:	3328      	adds	r3, #40	; 0x28
 80035d4:	4618      	mov	r0, r3
 80035d6:	f7ff ffbb 	bl	8003550 <__reg_object_init>
#endif

#if CH_CFG_SMP_MODE == FALSE
  /* RFCU initialization when SMP mode is disabled.*/
  __rfcu_object_init(&oip->rfcu);
 80035da:	9b01      	ldr	r3, [sp, #4]
 80035dc:	3334      	adds	r3, #52	; 0x34
 80035de:	4618      	mov	r0, r3
 80035e0:	f7ff ff46 	bl	8003470 <__rfcu_object_init>
#endif

  /* Virtual timers list initialization.*/
  __vt_object_init(&oip->vtlist);
 80035e4:	9b01      	ldr	r3, [sp, #4]
 80035e6:	3310      	adds	r3, #16
 80035e8:	4618      	mov	r0, r3
 80035ea:	f7ff ff99 	bl	8003520 <__vt_object_init>

  /* Debug support initialization.*/
  __dbg_object_init(&oip->dbg);
 80035ee:	9b01      	ldr	r3, [sp, #4]
 80035f0:	3384      	adds	r3, #132	; 0x84
 80035f2:	4618      	mov	r0, r3
 80035f4:	f7ff ff44 	bl	8003480 <__dbg_object_init>

#if CH_DBG_TRACE_MASK != CH_DBG_TRACE_MASK_DISABLED
  /* Trace buffer initialization.*/
  __trace_object_init(&oip->trace_buffer);
 80035f8:	9b01      	ldr	r3, [sp, #4]
 80035fa:	3390      	adds	r3, #144	; 0x90
 80035fc:	4618      	mov	r0, r3
 80035fe:	f7fe ffef 	bl	80025e0 <__trace_object_init>
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
 8003602:	9b01      	ldr	r3, [sp, #4]
 8003604:	f103 013c 	add.w	r1, r3, #60	; 0x3c
 8003608:	2380      	movs	r3, #128	; 0x80
 800360a:	4a18      	ldr	r2, [pc, #96]	; (800366c <chInstanceObjectInit+0xec>)
 800360c:	9801      	ldr	r0, [sp, #4]
 800360e:	f000 f8f7 	bl	8003800 <__thd_object_init>
 8003612:	4602      	mov	r2, r0
 8003614:	9b01      	ldr	r3, [sp, #4]
 8003616:	60da      	str	r2, [r3, #12]
  oip->rlist.current = __thd_object_init(oip, &oip->mainthread,
                                         "idle", IDLEPRIO);
#endif

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  oip->rlist.current->wabase = oicp->mainthread_base;
 8003618:	9b01      	ldr	r3, [sp, #4]
 800361a:	68db      	ldr	r3, [r3, #12]
 800361c:	9a00      	ldr	r2, [sp, #0]
 800361e:	6852      	ldr	r2, [r2, #4]
 8003620:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the caller as current thread.*/
  oip->rlist.current->state = CH_STATE_CURRENT;
 8003622:	9b01      	ldr	r3, [sp, #4]
 8003624:	68db      	ldr	r3, [r3, #12]
 8003626:	2201      	movs	r2, #1
 8003628:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  /* User instance initialization hook.*/
  CH_CFG_OS_INSTANCE_INIT_HOOK(oip);

#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
    thread_descriptor_t idle_descriptor = {
 800362c:	4b10      	ldr	r3, [pc, #64]	; (8003670 <chInstanceObjectInit+0xf0>)
 800362e:	9303      	str	r3, [sp, #12]
      .name     = "idle",
      .wbase    = oicp->idlethread_base,
 8003630:	9b00      	ldr	r3, [sp, #0]
 8003632:	68db      	ldr	r3, [r3, #12]
    thread_descriptor_t idle_descriptor = {
 8003634:	9304      	str	r3, [sp, #16]
      .wend     = oicp->idlethread_end,
 8003636:	9b00      	ldr	r3, [sp, #0]
 8003638:	691b      	ldr	r3, [r3, #16]
    thread_descriptor_t idle_descriptor = {
 800363a:	9305      	str	r3, [sp, #20]
 800363c:	2301      	movs	r3, #1
 800363e:	9306      	str	r3, [sp, #24]
 8003640:	4b0c      	ldr	r3, [pc, #48]	; (8003674 <chInstanceObjectInit+0xf4>)
 8003642:	9307      	str	r3, [sp, #28]
 8003644:	2300      	movs	r3, #0
 8003646:	9308      	str	r3, [sp, #32]
      .funcp    = __idle_thread,
      .arg      = NULL
    };

#if CH_DBG_FILL_THREADS == TRUE
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 8003648:	9b04      	ldr	r3, [sp, #16]
                    (uint8_t *)idle_descriptor.wend);
 800364a:	9a05      	ldr	r2, [sp, #20]
    __thd_stackfill((uint8_t *)idle_descriptor.wbase,
 800364c:	4611      	mov	r1, r2
 800364e:	4618      	mov	r0, r3
 8003650:	f000 f916 	bl	8003880 <__thd_stackfill>
#endif

    /* This thread has the lowest priority in the system, its role is just to
       serve interrupts in its context while keeping the lowest energy saving
       mode compatible with the system status.*/
    (void) chThdCreateI(&idle_descriptor);
 8003654:	ab03      	add	r3, sp, #12
 8003656:	4618      	mov	r0, r3
 8003658:	f000 f9ba 	bl	80039d0 <chThdCreateI>
  }
#endif
}
 800365c:	bf00      	nop
 800365e:	b00b      	add	sp, #44	; 0x2c
 8003660:	f85d fb04 	ldr.w	pc, [sp], #4
 8003664:	20000890 	.word	0x20000890
 8003668:	080046c0 	.word	0x080046c0
 800366c:	08004714 	.word	0x08004714
 8003670:	08004318 	.word	0x08004318
 8003674:	08003571 	.word	0x08003571
	...

08003680 <ch_list_init>:
static inline void ch_list_init(ch_list_t *lp) {
 8003680:	b082      	sub	sp, #8
 8003682:	9001      	str	r0, [sp, #4]
  lp->next = lp;
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	9a01      	ldr	r2, [sp, #4]
 8003688:	601a      	str	r2, [r3, #0]
}
 800368a:	bf00      	nop
 800368c:	b002      	add	sp, #8
 800368e:	4770      	bx	lr

08003690 <ch_list_notempty>:
static inline bool ch_list_notempty(ch_list_t *lp) {
 8003690:	b082      	sub	sp, #8
 8003692:	9001      	str	r0, [sp, #4]
  return (bool)(lp->next != lp);
 8003694:	9b01      	ldr	r3, [sp, #4]
 8003696:	681b      	ldr	r3, [r3, #0]
 8003698:	9a01      	ldr	r2, [sp, #4]
 800369a:	429a      	cmp	r2, r3
 800369c:	bf14      	ite	ne
 800369e:	2301      	movne	r3, #1
 80036a0:	2300      	moveq	r3, #0
 80036a2:	b2db      	uxtb	r3, r3
}
 80036a4:	4618      	mov	r0, r3
 80036a6:	b002      	add	sp, #8
 80036a8:	4770      	bx	lr
 80036aa:	bf00      	nop
 80036ac:	0000      	movs	r0, r0
	...

080036b0 <ch_list_unlink>:
static inline ch_list_t *ch_list_unlink(ch_list_t *lp) {
 80036b0:	b084      	sub	sp, #16
 80036b2:	9001      	str	r0, [sp, #4]
  ch_list_t *p = lp->next;
 80036b4:	9b01      	ldr	r3, [sp, #4]
 80036b6:	681b      	ldr	r3, [r3, #0]
 80036b8:	9303      	str	r3, [sp, #12]
  lp->next = p->next;
 80036ba:	9b03      	ldr	r3, [sp, #12]
 80036bc:	681a      	ldr	r2, [r3, #0]
 80036be:	9b01      	ldr	r3, [sp, #4]
 80036c0:	601a      	str	r2, [r3, #0]
  return p;
 80036c2:	9b03      	ldr	r3, [sp, #12]
}
 80036c4:	4618      	mov	r0, r3
 80036c6:	b004      	add	sp, #16
 80036c8:	4770      	bx	lr
 80036ca:	bf00      	nop
 80036cc:	0000      	movs	r0, r0
	...

080036d0 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 80036d0:	b082      	sub	sp, #8
 80036d2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 80036d4:	9b01      	ldr	r3, [sp, #4]
 80036d6:	9a01      	ldr	r2, [sp, #4]
 80036d8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 80036da:	9b01      	ldr	r3, [sp, #4]
 80036dc:	9a01      	ldr	r2, [sp, #4]
 80036de:	605a      	str	r2, [r3, #4]
}
 80036e0:	bf00      	nop
 80036e2:	b002      	add	sp, #8
 80036e4:	4770      	bx	lr
 80036e6:	bf00      	nop
	...

080036f0 <ch_queue_insert>:
static inline void ch_queue_insert(ch_queue_t *qp, ch_queue_t *p) {
 80036f0:	b082      	sub	sp, #8
 80036f2:	9001      	str	r0, [sp, #4]
 80036f4:	9100      	str	r1, [sp, #0]
  p->next       = qp;
 80036f6:	9b00      	ldr	r3, [sp, #0]
 80036f8:	9a01      	ldr	r2, [sp, #4]
 80036fa:	601a      	str	r2, [r3, #0]
  p->prev       = qp->prev;
 80036fc:	9b01      	ldr	r3, [sp, #4]
 80036fe:	685a      	ldr	r2, [r3, #4]
 8003700:	9b00      	ldr	r3, [sp, #0]
 8003702:	605a      	str	r2, [r3, #4]
  p->prev->next = p;
 8003704:	9b00      	ldr	r3, [sp, #0]
 8003706:	685b      	ldr	r3, [r3, #4]
 8003708:	9a00      	ldr	r2, [sp, #0]
 800370a:	601a      	str	r2, [r3, #0]
  qp->prev      = p;
 800370c:	9b01      	ldr	r3, [sp, #4]
 800370e:	9a00      	ldr	r2, [sp, #0]
 8003710:	605a      	str	r2, [r3, #4]
}
 8003712:	bf00      	nop
 8003714:	b002      	add	sp, #8
 8003716:	4770      	bx	lr
	...

08003720 <ch_queue_dequeue>:
static inline ch_queue_t *ch_queue_dequeue(ch_queue_t *p) {
 8003720:	b082      	sub	sp, #8
 8003722:	9001      	str	r0, [sp, #4]
  p->prev->next = p->next;
 8003724:	9b01      	ldr	r3, [sp, #4]
 8003726:	685b      	ldr	r3, [r3, #4]
 8003728:	9a01      	ldr	r2, [sp, #4]
 800372a:	6812      	ldr	r2, [r2, #0]
 800372c:	601a      	str	r2, [r3, #0]
  p->next->prev = p->prev;
 800372e:	9b01      	ldr	r3, [sp, #4]
 8003730:	681b      	ldr	r3, [r3, #0]
 8003732:	9a01      	ldr	r2, [sp, #4]
 8003734:	6852      	ldr	r2, [r2, #4]
 8003736:	605a      	str	r2, [r3, #4]
  return p;
 8003738:	9b01      	ldr	r3, [sp, #4]
}
 800373a:	4618      	mov	r0, r3
 800373c:	b002      	add	sp, #8
 800373e:	4770      	bx	lr

08003740 <chSysLock>:
static inline void chSysLock(void) {
 8003740:	b500      	push	{lr}
 8003742:	b083      	sub	sp, #12
 8003744:	2330      	movs	r3, #48	; 0x30
 8003746:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003748:	9b01      	ldr	r3, [sp, #4]
 800374a:	f383 8811 	msr	BASEPRI, r3
}
 800374e:	bf00      	nop
}
 8003750:	bf00      	nop
  __dbg_check_lock();
 8003752:	f7fe fda5 	bl	80022a0 <__dbg_check_lock>
}
 8003756:	bf00      	nop
 8003758:	b003      	add	sp, #12
 800375a:	f85d fb04 	ldr.w	pc, [sp], #4
 800375e:	bf00      	nop

08003760 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8003760:	b500      	push	{lr}
 8003762:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003764:	f7fe fdc4 	bl	80022f0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003768:	4b12      	ldr	r3, [pc, #72]	; (80037b4 <chSysUnlock+0x54>)
 800376a:	681b      	ldr	r3, [r3, #0]
 800376c:	4a11      	ldr	r2, [pc, #68]	; (80037b4 <chSysUnlock+0x54>)
 800376e:	4293      	cmp	r3, r2
 8003770:	bf14      	ite	ne
 8003772:	2301      	movne	r3, #1
 8003774:	2300      	moveq	r3, #0
 8003776:	b2db      	uxtb	r3, r3
 8003778:	2b00      	cmp	r3, #0
 800377a:	d00f      	beq.n	800379c <chSysUnlock+0x3c>
 800377c:	4b0d      	ldr	r3, [pc, #52]	; (80037b4 <chSysUnlock+0x54>)
 800377e:	68db      	ldr	r3, [r3, #12]
 8003780:	689a      	ldr	r2, [r3, #8]
 8003782:	4b0c      	ldr	r3, [pc, #48]	; (80037b4 <chSysUnlock+0x54>)
 8003784:	681b      	ldr	r3, [r3, #0]
 8003786:	689b      	ldr	r3, [r3, #8]
 8003788:	429a      	cmp	r2, r3
 800378a:	bf34      	ite	cc
 800378c:	2301      	movcc	r3, #1
 800378e:	2300      	movcs	r3, #0
 8003790:	b2db      	uxtb	r3, r3
 8003792:	2b00      	cmp	r3, #0
 8003794:	d002      	beq.n	800379c <chSysUnlock+0x3c>
 8003796:	4808      	ldr	r0, [pc, #32]	; (80037b8 <chSysUnlock+0x58>)
 8003798:	f7fe fd32 	bl	8002200 <chSysHalt>
 800379c:	2300      	movs	r3, #0
 800379e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80037a0:	9b01      	ldr	r3, [sp, #4]
 80037a2:	f383 8811 	msr	BASEPRI, r3
}
 80037a6:	bf00      	nop
}
 80037a8:	bf00      	nop
}
 80037aa:	bf00      	nop
 80037ac:	b003      	add	sp, #12
 80037ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80037b2:	bf00      	nop
 80037b4:	200008a0 	.word	0x200008a0
 80037b8:	080046f0 	.word	0x080046f0
 80037bc:	00000000 	.word	0x00000000

080037c0 <chThdGetSelfX>:
 *
 * @xclass
 */
static inline thread_t *chThdGetSelfX(void) {

  return __sch_get_currthread();
 80037c0:	4b01      	ldr	r3, [pc, #4]	; (80037c8 <chThdGetSelfX+0x8>)
 80037c2:	68db      	ldr	r3, [r3, #12]
}
 80037c4:	4618      	mov	r0, r3
 80037c6:	4770      	bx	lr
 80037c8:	200008a0 	.word	0x200008a0
 80037cc:	00000000 	.word	0x00000000

080037d0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(sysinterval_t ticks) {
 80037d0:	b500      	push	{lr}
 80037d2:	b083      	sub	sp, #12
 80037d4:	9001      	str	r0, [sp, #4]

  chDbgCheck(ticks != TIME_IMMEDIATE);
 80037d6:	9b01      	ldr	r3, [sp, #4]
 80037d8:	2b00      	cmp	r3, #0
 80037da:	bf0c      	ite	eq
 80037dc:	2301      	moveq	r3, #1
 80037de:	2300      	movne	r3, #0
 80037e0:	b2db      	uxtb	r3, r3
 80037e2:	2b00      	cmp	r3, #0
 80037e4:	d002      	beq.n	80037ec <chThdSleepS+0x1c>
 80037e6:	4805      	ldr	r0, [pc, #20]	; (80037fc <chThdSleepS+0x2c>)
 80037e8:	f7fe fd0a 	bl	8002200 <chSysHalt>

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, ticks);
 80037ec:	9901      	ldr	r1, [sp, #4]
 80037ee:	2008      	movs	r0, #8
 80037f0:	f7ff fdae 	bl	8003350 <chSchGoSleepTimeoutS>
}
 80037f4:	bf00      	nop
 80037f6:	b003      	add	sp, #12
 80037f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80037fc:	08004708 	.word	0x08004708

08003800 <__thd_object_init>:
 * @notapi
 */
thread_t *__thd_object_init(os_instance_t *oip,
                            thread_t *tp,
                            const char *name,
                            tprio_t prio) {
 8003800:	b500      	push	{lr}
 8003802:	b085      	sub	sp, #20
 8003804:	9003      	str	r0, [sp, #12]
 8003806:	9102      	str	r1, [sp, #8]
 8003808:	9201      	str	r2, [sp, #4]
 800380a:	9300      	str	r3, [sp, #0]

  tp->hdr.pqueue.prio   = prio;
 800380c:	9b02      	ldr	r3, [sp, #8]
 800380e:	9a00      	ldr	r2, [sp, #0]
 8003810:	609a      	str	r2, [r3, #8]
  tp->state             = CH_STATE_WTSTART;
 8003812:	9b02      	ldr	r3, [sp, #8]
 8003814:	2202      	movs	r2, #2
 8003816:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  tp->flags             = CH_FLAG_MODE_STATIC;
 800381a:	9b02      	ldr	r3, [sp, #8]
 800381c:	2200      	movs	r2, #0
 800381e:	f883 2025 	strb.w	r2, [r3, #37]	; 0x25
  tp->owner             = oip;
 8003822:	9b02      	ldr	r3, [sp, #8]
 8003824:	9a03      	ldr	r2, [sp, #12]
 8003826:	619a      	str	r2, [r3, #24]
#if CH_CFG_TIME_QUANTUM > 0
  tp->ticks             = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio          = prio;
 8003828:	9b02      	ldr	r3, [sp, #8]
 800382a:	9a00      	ldr	r2, [sp, #0]
 800382c:	641a      	str	r2, [r3, #64]	; 0x40
  tp->mtxlist           = NULL;
 800382e:	9b02      	ldr	r3, [sp, #8]
 8003830:	2200      	movs	r2, #0
 8003832:	63da      	str	r2, [r3, #60]	; 0x3c
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending          = (eventmask_t)0;
 8003834:	9b02      	ldr	r3, [sp, #8]
 8003836:	2200      	movs	r2, #0
 8003838:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time              = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs              = (trefs_t)1;
 800383a:	9b02      	ldr	r3, [sp, #8]
 800383c:	2201      	movs	r2, #1
 800383e:	f883 2026 	strb.w	r2, [r3, #38]	; 0x26
  tp->name              = name;
 8003842:	9b02      	ldr	r3, [sp, #8]
 8003844:	9a01      	ldr	r2, [sp, #4]
 8003846:	61da      	str	r2, [r3, #28]
  REG_INSERT(oip, tp);
 8003848:	9b03      	ldr	r3, [sp, #12]
 800384a:	f103 0228 	add.w	r2, r3, #40	; 0x28
 800384e:	9b02      	ldr	r3, [sp, #8]
 8003850:	3310      	adds	r3, #16
 8003852:	4619      	mov	r1, r3
 8003854:	4610      	mov	r0, r2
 8003856:	f7ff ff4b 	bl	80036f0 <ch_queue_insert>
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  ch_list_init(&tp->waiting);
 800385a:	9b02      	ldr	r3, [sp, #8]
 800385c:	332c      	adds	r3, #44	; 0x2c
 800385e:	4618      	mov	r0, r3
 8003860:	f7ff ff0e 	bl	8003680 <ch_list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  ch_queue_init(&tp->msgqueue);
 8003864:	9b02      	ldr	r3, [sp, #8]
 8003866:	3330      	adds	r3, #48	; 0x30
 8003868:	4618      	mov	r0, r3
 800386a:	f7ff ff31 	bl	80036d0 <ch_queue_init>
#endif
#if CH_DBG_STATISTICS == TRUE
  chTMObjectInit(&tp->stats);
#endif
  CH_CFG_THREAD_INIT_HOOK(tp);
  return tp;
 800386e:	9b02      	ldr	r3, [sp, #8]
}
 8003870:	4618      	mov	r0, r3
 8003872:	b005      	add	sp, #20
 8003874:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003880 <__thd_stackfill>:
 * @param[in] startp    first address to fill
 * @param[in] endp      last address to fill +1
 *
 * @notapi
 */
void __thd_stackfill(uint8_t *startp, uint8_t *endp) {
 8003880:	b082      	sub	sp, #8
 8003882:	9001      	str	r0, [sp, #4]
 8003884:	9100      	str	r1, [sp, #0]

  do {
    *startp++ = CH_DBG_STACK_FILL_VALUE;
 8003886:	9b01      	ldr	r3, [sp, #4]
 8003888:	1c5a      	adds	r2, r3, #1
 800388a:	9201      	str	r2, [sp, #4]
 800388c:	2255      	movs	r2, #85	; 0x55
 800388e:	701a      	strb	r2, [r3, #0]
  } while (likely(startp < endp));
 8003890:	9a01      	ldr	r2, [sp, #4]
 8003892:	9b00      	ldr	r3, [sp, #0]
 8003894:	429a      	cmp	r2, r3
 8003896:	bf34      	ite	cc
 8003898:	2301      	movcc	r3, #1
 800389a:	2300      	movcs	r3, #0
 800389c:	b2db      	uxtb	r3, r3
 800389e:	2b00      	cmp	r3, #0
 80038a0:	d1f1      	bne.n	8003886 <__thd_stackfill+0x6>
}
 80038a2:	bf00      	nop
 80038a4:	bf00      	nop
 80038a6:	b002      	add	sp, #8
 80038a8:	4770      	bx	lr
 80038aa:	bf00      	nop
 80038ac:	0000      	movs	r0, r0
	...

080038b0 <chThdCreateSuspendedI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80038b0:	b500      	push	{lr}
 80038b2:	b085      	sub	sp, #20
 80038b4:	9001      	str	r0, [sp, #4]
  thread_t *tp;

  chDbgCheckClassI();
 80038b6:	f7fe fe0b 	bl	80024d0 <chDbgCheckClassI>
  chDbgCheck(tdp != NULL);
 80038ba:	9b01      	ldr	r3, [sp, #4]
 80038bc:	2b00      	cmp	r3, #0
 80038be:	bf0c      	ite	eq
 80038c0:	2301      	moveq	r3, #1
 80038c2:	2300      	movne	r3, #0
 80038c4:	b2db      	uxtb	r3, r3
 80038c6:	2b00      	cmp	r3, #0
 80038c8:	d002      	beq.n	80038d0 <chThdCreateSuspendedI+0x20>
 80038ca:	483d      	ldr	r0, [pc, #244]	; (80039c0 <chThdCreateSuspendedI+0x110>)
 80038cc:	f7fe fc98 	bl	8002200 <chSysHalt>
  chDbgCheck(MEM_IS_ALIGNED(tdp->wbase, PORT_WORKING_AREA_ALIGN) &&
 80038d0:	9b01      	ldr	r3, [sp, #4]
 80038d2:	685b      	ldr	r3, [r3, #4]
 80038d4:	f003 0307 	and.w	r3, r3, #7
 80038d8:	2b00      	cmp	r3, #0
 80038da:	bf14      	ite	ne
 80038dc:	2301      	movne	r3, #1
 80038de:	2300      	moveq	r3, #0
 80038e0:	b2db      	uxtb	r3, r3
 80038e2:	2b00      	cmp	r3, #0
 80038e4:	d10a      	bne.n	80038fc <chThdCreateSuspendedI+0x4c>
 80038e6:	9b01      	ldr	r3, [sp, #4]
 80038e8:	689b      	ldr	r3, [r3, #8]
 80038ea:	f003 0307 	and.w	r3, r3, #7
 80038ee:	2b00      	cmp	r3, #0
 80038f0:	bf14      	ite	ne
 80038f2:	2301      	movne	r3, #1
 80038f4:	2300      	moveq	r3, #0
 80038f6:	b2db      	uxtb	r3, r3
 80038f8:	2b00      	cmp	r3, #0
 80038fa:	d001      	beq.n	8003900 <chThdCreateSuspendedI+0x50>
 80038fc:	2301      	movs	r3, #1
 80038fe:	e000      	b.n	8003902 <chThdCreateSuspendedI+0x52>
 8003900:	2300      	movs	r3, #0
 8003902:	2b00      	cmp	r3, #0
 8003904:	d10a      	bne.n	800391c <chThdCreateSuspendedI+0x6c>
 8003906:	9b01      	ldr	r3, [sp, #4]
 8003908:	689a      	ldr	r2, [r3, #8]
 800390a:	9b01      	ldr	r3, [sp, #4]
 800390c:	685b      	ldr	r3, [r3, #4]
 800390e:	429a      	cmp	r2, r3
 8003910:	bf94      	ite	ls
 8003912:	2301      	movls	r3, #1
 8003914:	2300      	movhi	r3, #0
 8003916:	b2db      	uxtb	r3, r3
 8003918:	2b00      	cmp	r3, #0
 800391a:	d001      	beq.n	8003920 <chThdCreateSuspendedI+0x70>
 800391c:	2301      	movs	r3, #1
 800391e:	e000      	b.n	8003922 <chThdCreateSuspendedI+0x72>
 8003920:	2300      	movs	r3, #0
 8003922:	2b00      	cmp	r3, #0
 8003924:	d10c      	bne.n	8003940 <chThdCreateSuspendedI+0x90>
 8003926:	9b01      	ldr	r3, [sp, #4]
 8003928:	689b      	ldr	r3, [r3, #8]
 800392a:	461a      	mov	r2, r3
 800392c:	9b01      	ldr	r3, [sp, #4]
 800392e:	685b      	ldr	r3, [r3, #4]
 8003930:	1ad3      	subs	r3, r2, r3
 8003932:	2bef      	cmp	r3, #239	; 0xef
 8003934:	bf94      	ite	ls
 8003936:	2301      	movls	r3, #1
 8003938:	2300      	movhi	r3, #0
 800393a:	b2db      	uxtb	r3, r3
 800393c:	2b00      	cmp	r3, #0
 800393e:	d002      	beq.n	8003946 <chThdCreateSuspendedI+0x96>
 8003940:	481f      	ldr	r0, [pc, #124]	; (80039c0 <chThdCreateSuspendedI+0x110>)
 8003942:	f7fe fc5d 	bl	8002200 <chSysHalt>
             MEM_IS_ALIGNED(tdp->wend, PORT_STACK_ALIGN) &&
             (tdp->wend > tdp->wbase) &&
             (((size_t)tdp->wend - (size_t)tdp->wbase) >= THD_WORKING_AREA_SIZE(0)));
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));
 8003946:	9b01      	ldr	r3, [sp, #4]
 8003948:	68db      	ldr	r3, [r3, #12]
 800394a:	2bff      	cmp	r3, #255	; 0xff
 800394c:	bf8c      	ite	hi
 800394e:	2301      	movhi	r3, #1
 8003950:	2300      	movls	r3, #0
 8003952:	b2db      	uxtb	r3, r3
 8003954:	2b00      	cmp	r3, #0
 8003956:	d108      	bne.n	800396a <chThdCreateSuspendedI+0xba>
 8003958:	9b01      	ldr	r3, [sp, #4]
 800395a:	691b      	ldr	r3, [r3, #16]
 800395c:	2b00      	cmp	r3, #0
 800395e:	bf0c      	ite	eq
 8003960:	2301      	moveq	r3, #1
 8003962:	2300      	movne	r3, #0
 8003964:	b2db      	uxtb	r3, r3
 8003966:	2b00      	cmp	r3, #0
 8003968:	d002      	beq.n	8003970 <chThdCreateSuspendedI+0xc0>
 800396a:	4815      	ldr	r0, [pc, #84]	; (80039c0 <chThdCreateSuspendedI+0x110>)
 800396c:	f7fe fc48 	bl	8002200 <chSysHalt>

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = threadref(((uint8_t *)tdp->wend -
 8003970:	9b01      	ldr	r3, [sp, #4]
 8003972:	689b      	ldr	r3, [r3, #8]
 8003974:	3b48      	subs	r3, #72	; 0x48
 8003976:	9303      	str	r3, [sp, #12]
                 MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN)));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8003978:	9b01      	ldr	r3, [sp, #4]
 800397a:	685a      	ldr	r2, [r3, #4]
 800397c:	9b03      	ldr	r3, [sp, #12]
 800397e:	621a      	str	r2, [r3, #32]
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8003980:	9b03      	ldr	r3, [sp, #12]
 8003982:	f1a3 0224 	sub.w	r2, r3, #36	; 0x24
 8003986:	9b03      	ldr	r3, [sp, #12]
 8003988:	60da      	str	r2, [r3, #12]
 800398a:	9b01      	ldr	r3, [sp, #4]
 800398c:	691a      	ldr	r2, [r3, #16]
 800398e:	9b03      	ldr	r3, [sp, #12]
 8003990:	68db      	ldr	r3, [r3, #12]
 8003992:	601a      	str	r2, [r3, #0]
 8003994:	9b01      	ldr	r3, [sp, #4]
 8003996:	695a      	ldr	r2, [r3, #20]
 8003998:	9b03      	ldr	r3, [sp, #12]
 800399a:	68db      	ldr	r3, [r3, #12]
 800399c:	605a      	str	r2, [r3, #4]
 800399e:	9b03      	ldr	r3, [sp, #12]
 80039a0:	68db      	ldr	r3, [r3, #12]
 80039a2:	4a08      	ldr	r2, [pc, #32]	; (80039c4 <chThdCreateSuspendedI+0x114>)
 80039a4:	621a      	str	r2, [r3, #32]
  if (tdp->instance != NULL) {
    return __thd_object_init(tdp->instance, tp, tdp->name, tdp->prio);
  }
#endif

  return __thd_object_init(currcore, tp, tdp->name, tdp->prio);
 80039a6:	9b01      	ldr	r3, [sp, #4]
 80039a8:	681a      	ldr	r2, [r3, #0]
 80039aa:	9b01      	ldr	r3, [sp, #4]
 80039ac:	68db      	ldr	r3, [r3, #12]
 80039ae:	9903      	ldr	r1, [sp, #12]
 80039b0:	4805      	ldr	r0, [pc, #20]	; (80039c8 <chThdCreateSuspendedI+0x118>)
 80039b2:	f7ff ff25 	bl	8003800 <__thd_object_init>
 80039b6:	4603      	mov	r3, r0
}
 80039b8:	4618      	mov	r0, r3
 80039ba:	b005      	add	sp, #20
 80039bc:	f85d fb04 	ldr.w	pc, [sp], #4
 80039c0:	080046d8 	.word	0x080046d8
 80039c4:	080002d1 	.word	0x080002d1
 80039c8:	200008a0 	.word	0x200008a0
 80039cc:	00000000 	.word	0x00000000

080039d0 <chThdCreateI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(const thread_descriptor_t *tdp) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	9001      	str	r0, [sp, #4]

  return chSchReadyI(chThdCreateSuspendedI(tdp));
 80039d6:	9801      	ldr	r0, [sp, #4]
 80039d8:	f7ff ff6a 	bl	80038b0 <chThdCreateSuspendedI>
 80039dc:	4603      	mov	r3, r0
 80039de:	4618      	mov	r0, r3
 80039e0:	f7ff fc36 	bl	8003250 <chSchReadyI>
 80039e4:	4603      	mov	r3, r0
}
 80039e6:	4618      	mov	r0, r3
 80039e8:	b003      	add	sp, #12
 80039ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80039ee:	bf00      	nop

080039f0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80039f0:	b500      	push	{lr}
 80039f2:	b083      	sub	sp, #12
 80039f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80039f6:	f7ff fea3 	bl	8003740 <chSysLock>
  chThdExitS(msg);
 80039fa:	9801      	ldr	r0, [sp, #4]
 80039fc:	f000 f808 	bl	8003a10 <chThdExitS>
  /* The thread never returns here.*/
}
 8003a00:	bf00      	nop
 8003a02:	b003      	add	sp, #12
 8003a04:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003a10 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9001      	str	r0, [sp, #4]
  thread_t *currtp = chThdGetSelfX();
 8003a16:	f7ff fed3 	bl	80037c0 <chThdGetSelfX>
 8003a1a:	9003      	str	r0, [sp, #12]

  /* Storing exit message.*/
  currtp->u.exitcode = msg;
 8003a1c:	9b03      	ldr	r3, [sp, #12]
 8003a1e:	9a01      	ldr	r2, [sp, #4]
 8003a20:	629a      	str	r2, [r3, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003a22:	e008      	b.n	8003a36 <chThdExitS+0x26>
    (void) chSchReadyI(threadref(ch_list_unlink(&currtp->waiting)));
 8003a24:	9b03      	ldr	r3, [sp, #12]
 8003a26:	332c      	adds	r3, #44	; 0x2c
 8003a28:	4618      	mov	r0, r3
 8003a2a:	f7ff fe41 	bl	80036b0 <ch_list_unlink>
 8003a2e:	4603      	mov	r3, r0
 8003a30:	4618      	mov	r0, r3
 8003a32:	f7ff fc0d 	bl	8003250 <chSchReadyI>
  while (unlikely(ch_list_notempty(&currtp->waiting))) {
 8003a36:	9b03      	ldr	r3, [sp, #12]
 8003a38:	332c      	adds	r3, #44	; 0x2c
 8003a3a:	4618      	mov	r0, r3
 8003a3c:	f7ff fe28 	bl	8003690 <ch_list_notempty>
 8003a40:	4603      	mov	r3, r0
 8003a42:	2b00      	cmp	r3, #0
 8003a44:	d1ee      	bne.n	8003a24 <chThdExitS+0x14>
  }
#endif

#if CH_CFG_USE_REGISTRY == TRUE
  if (unlikely(currtp->refs == (trefs_t)0)) {
 8003a46:	9b03      	ldr	r3, [sp, #12]
 8003a48:	f893 3026 	ldrb.w	r3, [r3, #38]	; 0x26
 8003a4c:	2b00      	cmp	r3, #0
 8003a4e:	bf0c      	ite	eq
 8003a50:	2301      	moveq	r3, #1
 8003a52:	2300      	movne	r3, #0
 8003a54:	b2db      	uxtb	r3, r3
 8003a56:	2b00      	cmp	r3, #0
 8003a58:	d010      	beq.n	8003a7c <chThdExitS+0x6c>
#if CH_CFG_USE_DYNAMIC == TRUE
    /* Static threads are immediately removed from the registry because there
       is no memory to recover.*/
    if (unlikely(((currtp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC))) {
 8003a5a:	9b03      	ldr	r3, [sp, #12]
 8003a5c:	f893 3025 	ldrb.w	r3, [r3, #37]	; 0x25
 8003a60:	f003 0303 	and.w	r3, r3, #3
 8003a64:	2b00      	cmp	r3, #0
 8003a66:	bf0c      	ite	eq
 8003a68:	2301      	moveq	r3, #1
 8003a6a:	2300      	movne	r3, #0
 8003a6c:	b2db      	uxtb	r3, r3
 8003a6e:	2b00      	cmp	r3, #0
 8003a70:	d004      	beq.n	8003a7c <chThdExitS+0x6c>
      REG_REMOVE(currtp);
 8003a72:	9b03      	ldr	r3, [sp, #12]
 8003a74:	3310      	adds	r3, #16
 8003a76:	4618      	mov	r0, r3
 8003a78:	f7ff fe52 	bl	8003720 <ch_queue_dequeue>
#endif
  }
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8003a7c:	200f      	movs	r0, #15
 8003a7e:	f7ff fc07 	bl	8003290 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
 8003a82:	4803      	ldr	r0, [pc, #12]	; (8003a90 <chThdExitS+0x80>)
 8003a84:	f7fe fbbc 	bl	8002200 <chSysHalt>
}
 8003a88:	bf00      	nop
 8003a8a:	b005      	add	sp, #20
 8003a8c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a90:	080046fc 	.word	0x080046fc
	...

08003aa0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(sysinterval_t time) {
 8003aa0:	b500      	push	{lr}
 8003aa2:	b083      	sub	sp, #12
 8003aa4:	9001      	str	r0, [sp, #4]

  chSysLock();
 8003aa6:	f7ff fe4b 	bl	8003740 <chSysLock>
  chThdSleepS(time);
 8003aaa:	9801      	ldr	r0, [sp, #4]
 8003aac:	f7ff fe90 	bl	80037d0 <chThdSleepS>
  chSysUnlock();
 8003ab0:	f7ff fe56 	bl	8003760 <chSysUnlock>
}
 8003ab4:	bf00      	nop
 8003ab6:	b003      	add	sp, #12
 8003ab8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003abc:	0000      	movs	r0, r0
	...

08003ac0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 8003ac0:	b4f0      	push	{r4, r5, r6, r7}
 8003ac2:	b084      	sub	sp, #16
 8003ac4:	9003      	str	r0, [sp, #12]
 8003ac6:	9102      	str	r1, [sp, #8]
 8003ac8:	9201      	str	r2, [sp, #4]

  tmp->n++;
 8003aca:	9b03      	ldr	r3, [sp, #12]
 8003acc:	68db      	ldr	r3, [r3, #12]
 8003ace:	1c5a      	adds	r2, r3, #1
 8003ad0:	9b03      	ldr	r3, [sp, #12]
 8003ad2:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8003ad4:	9b03      	ldr	r3, [sp, #12]
 8003ad6:	689b      	ldr	r3, [r3, #8]
 8003ad8:	9a02      	ldr	r2, [sp, #8]
 8003ada:	1ad2      	subs	r2, r2, r3
 8003adc:	9b01      	ldr	r3, [sp, #4]
 8003ade:	1ad2      	subs	r2, r2, r3
 8003ae0:	9b03      	ldr	r3, [sp, #12]
 8003ae2:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8003ae4:	9b03      	ldr	r3, [sp, #12]
 8003ae6:	e9d3 2304 	ldrd	r2, r3, [r3, #16]
 8003aea:	9903      	ldr	r1, [sp, #12]
 8003aec:	6889      	ldr	r1, [r1, #8]
 8003aee:	2000      	movs	r0, #0
 8003af0:	460c      	mov	r4, r1
 8003af2:	4605      	mov	r5, r0
 8003af4:	1916      	adds	r6, r2, r4
 8003af6:	eb43 0705 	adc.w	r7, r3, r5
 8003afa:	9b03      	ldr	r3, [sp, #12]
 8003afc:	e9c3 6704 	strd	r6, r7, [r3, #16]
  if (tmp->last > tmp->worst) {
 8003b00:	9b03      	ldr	r3, [sp, #12]
 8003b02:	689a      	ldr	r2, [r3, #8]
 8003b04:	9b03      	ldr	r3, [sp, #12]
 8003b06:	685b      	ldr	r3, [r3, #4]
 8003b08:	429a      	cmp	r2, r3
 8003b0a:	d903      	bls.n	8003b14 <tm_stop+0x54>
    tmp->worst = tmp->last;
 8003b0c:	9b03      	ldr	r3, [sp, #12]
 8003b0e:	689a      	ldr	r2, [r3, #8]
 8003b10:	9b03      	ldr	r3, [sp, #12]
 8003b12:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8003b14:	9b03      	ldr	r3, [sp, #12]
 8003b16:	689a      	ldr	r2, [r3, #8]
 8003b18:	9b03      	ldr	r3, [sp, #12]
 8003b1a:	681b      	ldr	r3, [r3, #0]
 8003b1c:	429a      	cmp	r2, r3
 8003b1e:	d203      	bcs.n	8003b28 <tm_stop+0x68>
    tmp->best = tmp->last;
 8003b20:	9b03      	ldr	r3, [sp, #12]
 8003b22:	689a      	ldr	r2, [r3, #8]
 8003b24:	9b03      	ldr	r3, [sp, #12]
 8003b26:	601a      	str	r2, [r3, #0]
  }
}
 8003b28:	bf00      	nop
 8003b2a:	b004      	add	sp, #16
 8003b2c:	bcf0      	pop	{r4, r5, r6, r7}
 8003b2e:	4770      	bx	lr

08003b30 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 8003b30:	b082      	sub	sp, #8
 8003b32:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8003b3a:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 8003b3c:	9b01      	ldr	r3, [sp, #4]
 8003b3e:	2200      	movs	r2, #0
 8003b40:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 8003b42:	9b01      	ldr	r3, [sp, #4]
 8003b44:	2200      	movs	r2, #0
 8003b46:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 8003b48:	9b01      	ldr	r3, [sp, #4]
 8003b4a:	2200      	movs	r2, #0
 8003b4c:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 8003b4e:	9901      	ldr	r1, [sp, #4]
 8003b50:	f04f 0200 	mov.w	r2, #0
 8003b54:	f04f 0300 	mov.w	r3, #0
 8003b58:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 8003b5c:	bf00      	nop
 8003b5e:	b002      	add	sp, #8
 8003b60:	4770      	bx	lr
 8003b62:	bf00      	nop
	...

08003b70 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 8003b70:	b082      	sub	sp, #8
 8003b72:	9001      	str	r0, [sp, #4]
  return DWT->CYCCNT;
 8003b74:	4b03      	ldr	r3, [pc, #12]	; (8003b84 <chTMStartMeasurementX+0x14>)
 8003b76:	685a      	ldr	r2, [r3, #4]

  tmp->last = chSysGetRealtimeCounterX();
 8003b78:	9b01      	ldr	r3, [sp, #4]
 8003b7a:	609a      	str	r2, [r3, #8]
}
 8003b7c:	bf00      	nop
 8003b7e:	b002      	add	sp, #8
 8003b80:	4770      	bx	lr
 8003b82:	bf00      	nop
 8003b84:	e0001000 	.word	0xe0001000
	...

08003b90 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8003b90:	b500      	push	{lr}
 8003b92:	b083      	sub	sp, #12
 8003b94:	9001      	str	r0, [sp, #4]
 8003b96:	4b06      	ldr	r3, [pc, #24]	; (8003bb0 <chTMStopMeasurementX+0x20>)
 8003b98:	685b      	ldr	r3, [r3, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch_system.tmc.offset);
 8003b9a:	4a06      	ldr	r2, [pc, #24]	; (8003bb4 <chTMStopMeasurementX+0x24>)
 8003b9c:	6892      	ldr	r2, [r2, #8]
 8003b9e:	4619      	mov	r1, r3
 8003ba0:	9801      	ldr	r0, [sp, #4]
 8003ba2:	f7ff ff8d 	bl	8003ac0 <tm_stop>
}
 8003ba6:	bf00      	nop
 8003ba8:	b003      	add	sp, #12
 8003baa:	f85d fb04 	ldr.w	pc, [sp], #4
 8003bae:	bf00      	nop
 8003bb0:	e0001000 	.word	0xe0001000
 8003bb4:	20000890 	.word	0x20000890
	...

08003bc0 <ch_queue_init>:
static inline void ch_queue_init(ch_queue_t *qp) {
 8003bc0:	b082      	sub	sp, #8
 8003bc2:	9001      	str	r0, [sp, #4]
  qp->next = qp;
 8003bc4:	9b01      	ldr	r3, [sp, #4]
 8003bc6:	9a01      	ldr	r2, [sp, #4]
 8003bc8:	601a      	str	r2, [r3, #0]
  qp->prev = qp;
 8003bca:	9b01      	ldr	r3, [sp, #4]
 8003bcc:	9a01      	ldr	r2, [sp, #4]
 8003bce:	605a      	str	r2, [r3, #4]
}
 8003bd0:	bf00      	nop
 8003bd2:	b002      	add	sp, #8
 8003bd4:	4770      	bx	lr
 8003bd6:	bf00      	nop
	...

08003be0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8003be0:	b500      	push	{lr}
 8003be2:	b083      	sub	sp, #12
 8003be4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);
 8003be6:	9b01      	ldr	r3, [sp, #4]
 8003be8:	2b00      	cmp	r3, #0
 8003bea:	bf0c      	ite	eq
 8003bec:	2301      	moveq	r3, #1
 8003bee:	2300      	movne	r3, #0
 8003bf0:	b2db      	uxtb	r3, r3
 8003bf2:	2b00      	cmp	r3, #0
 8003bf4:	d002      	beq.n	8003bfc <chMtxObjectInit+0x1c>
 8003bf6:	4807      	ldr	r0, [pc, #28]	; (8003c14 <chMtxObjectInit+0x34>)
 8003bf8:	f7fe fb02 	bl	8002200 <chSysHalt>

  ch_queue_init(&mp->queue);
 8003bfc:	9b01      	ldr	r3, [sp, #4]
 8003bfe:	4618      	mov	r0, r3
 8003c00:	f7ff ffde 	bl	8003bc0 <ch_queue_init>
  mp->owner = NULL;
 8003c04:	9b01      	ldr	r3, [sp, #4]
 8003c06:	2200      	movs	r2, #0
 8003c08:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->cnt = (cnt_t)0;
#endif
}
 8003c0a:	bf00      	nop
 8003c0c:	b003      	add	sp, #12
 8003c0e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c12:	bf00      	nop
 8003c14:	08004740 	.word	0x08004740
	...

08003c20 <chSysLock>:
static inline void chSysLock(void) {
 8003c20:	b500      	push	{lr}
 8003c22:	b083      	sub	sp, #12
 8003c24:	2330      	movs	r3, #48	; 0x30
 8003c26:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003c28:	9b01      	ldr	r3, [sp, #4]
 8003c2a:	f383 8811 	msr	BASEPRI, r3
}
 8003c2e:	bf00      	nop
}
 8003c30:	bf00      	nop
  __dbg_check_lock();
 8003c32:	f7fe fb35 	bl	80022a0 <__dbg_check_lock>
}
 8003c36:	bf00      	nop
 8003c38:	b003      	add	sp, #12
 8003c3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c3e:	bf00      	nop

08003c40 <chSysUnlock>:
static inline void chSysUnlock(void) {
 8003c40:	b500      	push	{lr}
 8003c42:	b083      	sub	sp, #12
  __dbg_check_unlock();
 8003c44:	f7fe fb54 	bl	80022f0 <__dbg_check_unlock>
  chDbgAssert((currcore->rlist.pqueue.next == &currcore->rlist.pqueue) ||
 8003c48:	4b12      	ldr	r3, [pc, #72]	; (8003c94 <chSysUnlock+0x54>)
 8003c4a:	681b      	ldr	r3, [r3, #0]
 8003c4c:	4a11      	ldr	r2, [pc, #68]	; (8003c94 <chSysUnlock+0x54>)
 8003c4e:	4293      	cmp	r3, r2
 8003c50:	bf14      	ite	ne
 8003c52:	2301      	movne	r3, #1
 8003c54:	2300      	moveq	r3, #0
 8003c56:	b2db      	uxtb	r3, r3
 8003c58:	2b00      	cmp	r3, #0
 8003c5a:	d00f      	beq.n	8003c7c <chSysUnlock+0x3c>
 8003c5c:	4b0d      	ldr	r3, [pc, #52]	; (8003c94 <chSysUnlock+0x54>)
 8003c5e:	68db      	ldr	r3, [r3, #12]
 8003c60:	689a      	ldr	r2, [r3, #8]
 8003c62:	4b0c      	ldr	r3, [pc, #48]	; (8003c94 <chSysUnlock+0x54>)
 8003c64:	681b      	ldr	r3, [r3, #0]
 8003c66:	689b      	ldr	r3, [r3, #8]
 8003c68:	429a      	cmp	r2, r3
 8003c6a:	bf34      	ite	cc
 8003c6c:	2301      	movcc	r3, #1
 8003c6e:	2300      	movcs	r3, #0
 8003c70:	b2db      	uxtb	r3, r3
 8003c72:	2b00      	cmp	r3, #0
 8003c74:	d002      	beq.n	8003c7c <chSysUnlock+0x3c>
 8003c76:	4808      	ldr	r0, [pc, #32]	; (8003c98 <chSysUnlock+0x58>)
 8003c78:	f7fe fac2 	bl	8002200 <chSysHalt>
 8003c7c:	2300      	movs	r3, #0
 8003c7e:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003c80:	9b01      	ldr	r3, [sp, #4]
 8003c82:	f383 8811 	msr	BASEPRI, r3
}
 8003c86:	bf00      	nop
}
 8003c88:	bf00      	nop
}
 8003c8a:	bf00      	nop
 8003c8c:	b003      	add	sp, #12
 8003c8e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c92:	bf00      	nop
 8003c94:	200008a0 	.word	0x200008a0
 8003c98:	08004764 	.word	0x08004764
 8003c9c:	00000000 	.word	0x00000000

08003ca0 <__core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  ch_memcore.basemem = __heap_base__;
 8003ca0:	4b03      	ldr	r3, [pc, #12]	; (8003cb0 <__core_init+0x10>)
 8003ca2:	4a04      	ldr	r2, [pc, #16]	; (8003cb4 <__core_init+0x14>)
 8003ca4:	601a      	str	r2, [r3, #0]
  ch_memcore.topmem  = __heap_end__;
 8003ca6:	4b02      	ldr	r3, [pc, #8]	; (8003cb0 <__core_init+0x10>)
 8003ca8:	4a03      	ldr	r2, [pc, #12]	; (8003cb8 <__core_init+0x18>)
 8003caa:	605a      	str	r2, [r3, #4]
  static uint8_t static_heap[CH_CFG_MEMCORE_SIZE];

  ch_memcore.basemem = &static_heap[0];
  ch_memcore.topmem  = &static_heap[CH_CFG_MEMCORE_SIZE];
#endif
}
 8003cac:	bf00      	nop
 8003cae:	4770      	bx	lr
 8003cb0:	20001268 	.word	0x20001268
 8003cb4:	200012e0 	.word	0x200012e0
 8003cb8:	20020000 	.word	0x20020000
 8003cbc:	00000000 	.word	0x00000000

08003cc0 <chCoreAllocFromTopI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocFromTopI(size_t size, unsigned align, size_t offset) {
 8003cc0:	b500      	push	{lr}
 8003cc2:	b087      	sub	sp, #28
 8003cc4:	9003      	str	r0, [sp, #12]
 8003cc6:	9102      	str	r1, [sp, #8]
 8003cc8:	9201      	str	r2, [sp, #4]
  uint8_t *p, *prev;

  chDbgCheckClassI();
 8003cca:	f7fe fc01 	bl	80024d0 <chDbgCheckClassI>
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));
 8003cce:	9b02      	ldr	r3, [sp, #8]
 8003cd0:	2b00      	cmp	r3, #0
 8003cd2:	bf0c      	ite	eq
 8003cd4:	2301      	moveq	r3, #1
 8003cd6:	2300      	movne	r3, #0
 8003cd8:	b2db      	uxtb	r3, r3
 8003cda:	2b00      	cmp	r3, #0
 8003cdc:	d10a      	bne.n	8003cf4 <chCoreAllocFromTopI+0x34>
 8003cde:	9b02      	ldr	r3, [sp, #8]
 8003ce0:	1e5a      	subs	r2, r3, #1
 8003ce2:	9b02      	ldr	r3, [sp, #8]
 8003ce4:	4013      	ands	r3, r2
 8003ce6:	2b00      	cmp	r3, #0
 8003ce8:	bf14      	ite	ne
 8003cea:	2301      	movne	r3, #1
 8003cec:	2300      	moveq	r3, #0
 8003cee:	b2db      	uxtb	r3, r3
 8003cf0:	2b00      	cmp	r3, #0
 8003cf2:	d002      	beq.n	8003cfa <chCoreAllocFromTopI+0x3a>
 8003cf4:	4812      	ldr	r0, [pc, #72]	; (8003d40 <chCoreAllocFromTopI+0x80>)
 8003cf6:	f7fe fa83 	bl	8002200 <chSysHalt>

  p = (uint8_t *)MEM_ALIGN_PREV(ch_memcore.topmem - size, align);
 8003cfa:	4b12      	ldr	r3, [pc, #72]	; (8003d44 <chCoreAllocFromTopI+0x84>)
 8003cfc:	685a      	ldr	r2, [r3, #4]
 8003cfe:	9b03      	ldr	r3, [sp, #12]
 8003d00:	425b      	negs	r3, r3
 8003d02:	4413      	add	r3, r2
 8003d04:	461a      	mov	r2, r3
 8003d06:	9b02      	ldr	r3, [sp, #8]
 8003d08:	425b      	negs	r3, r3
 8003d0a:	4013      	ands	r3, r2
 8003d0c:	9305      	str	r3, [sp, #20]
  prev = p - offset;
 8003d0e:	9b01      	ldr	r3, [sp, #4]
 8003d10:	425b      	negs	r3, r3
 8003d12:	9a05      	ldr	r2, [sp, #20]
 8003d14:	4413      	add	r3, r2
 8003d16:	9304      	str	r3, [sp, #16]

  /* Considering also the case where there is numeric overflow.*/
  if ((prev < ch_memcore.basemem) || (prev > ch_memcore.topmem)) {
 8003d18:	4b0a      	ldr	r3, [pc, #40]	; (8003d44 <chCoreAllocFromTopI+0x84>)
 8003d1a:	681b      	ldr	r3, [r3, #0]
 8003d1c:	9a04      	ldr	r2, [sp, #16]
 8003d1e:	429a      	cmp	r2, r3
 8003d20:	d304      	bcc.n	8003d2c <chCoreAllocFromTopI+0x6c>
 8003d22:	4b08      	ldr	r3, [pc, #32]	; (8003d44 <chCoreAllocFromTopI+0x84>)
 8003d24:	685b      	ldr	r3, [r3, #4]
 8003d26:	9a04      	ldr	r2, [sp, #16]
 8003d28:	429a      	cmp	r2, r3
 8003d2a:	d901      	bls.n	8003d30 <chCoreAllocFromTopI+0x70>
    return NULL;
 8003d2c:	2300      	movs	r3, #0
 8003d2e:	e003      	b.n	8003d38 <chCoreAllocFromTopI+0x78>
  }

  ch_memcore.topmem = prev;
 8003d30:	4a04      	ldr	r2, [pc, #16]	; (8003d44 <chCoreAllocFromTopI+0x84>)
 8003d32:	9b04      	ldr	r3, [sp, #16]
 8003d34:	6053      	str	r3, [r2, #4]

  return p;
 8003d36:	9b05      	ldr	r3, [sp, #20]
}
 8003d38:	4618      	mov	r0, r3
 8003d3a:	b007      	add	sp, #28
 8003d3c:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d40:	08004750 	.word	0x08004750
 8003d44:	20001268 	.word	0x20001268
	...

08003d50 <chCoreAllocFromTop>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocFromTop(size_t size, unsigned align, size_t offset) {
 8003d50:	b500      	push	{lr}
 8003d52:	b087      	sub	sp, #28
 8003d54:	9003      	str	r0, [sp, #12]
 8003d56:	9102      	str	r1, [sp, #8]
 8003d58:	9201      	str	r2, [sp, #4]
  void *p;

  chSysLock();
 8003d5a:	f7ff ff61 	bl	8003c20 <chSysLock>
  p = chCoreAllocFromTopI(size, align, offset);
 8003d5e:	9a01      	ldr	r2, [sp, #4]
 8003d60:	9902      	ldr	r1, [sp, #8]
 8003d62:	9803      	ldr	r0, [sp, #12]
 8003d64:	f7ff ffac 	bl	8003cc0 <chCoreAllocFromTopI>
 8003d68:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8003d6a:	f7ff ff69 	bl	8003c40 <chSysUnlock>

  return p;
 8003d6e:	9b05      	ldr	r3, [sp, #20]
}
 8003d70:	4618      	mov	r0, r3
 8003d72:	b007      	add	sp, #28
 8003d74:	f85d fb04 	ldr.w	pc, [sp], #4
	...

08003d80 <__heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void __heap_init(void) {
 8003d80:	b508      	push	{r3, lr}

  default_heap.provider = chCoreAllocAlignedWithOffset;
 8003d82:	4b07      	ldr	r3, [pc, #28]	; (8003da0 <__heap_init+0x20>)
 8003d84:	4a07      	ldr	r2, [pc, #28]	; (8003da4 <__heap_init+0x24>)
 8003d86:	601a      	str	r2, [r3, #0]
  H_NEXT(&default_heap.header) = NULL;
 8003d88:	4b05      	ldr	r3, [pc, #20]	; (8003da0 <__heap_init+0x20>)
 8003d8a:	2200      	movs	r2, #0
 8003d8c:	605a      	str	r2, [r3, #4]
  H_PAGES(&default_heap.header) = 0;
 8003d8e:	4b04      	ldr	r3, [pc, #16]	; (8003da0 <__heap_init+0x20>)
 8003d90:	2200      	movs	r2, #0
 8003d92:	609a      	str	r2, [r3, #8]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
 8003d94:	4804      	ldr	r0, [pc, #16]	; (8003da8 <__heap_init+0x28>)
 8003d96:	f7ff ff23 	bl	8003be0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
#endif
}
 8003d9a:	bf00      	nop
 8003d9c:	bd08      	pop	{r3, pc}
 8003d9e:	bf00      	nop
 8003da0:	20001270 	.word	0x20001270
 8003da4:	08003d51 	.word	0x08003d51
 8003da8:	2000127c 	.word	0x2000127c
 8003dac:	00000000 	.word	0x00000000

08003db0 <chPoolObjectInitAligned>:
 *                      automatically
 *
 * @init
 */
void chPoolObjectInitAligned(memory_pool_t *mp, size_t size,
                             unsigned align, memgetfunc_t provider) {
 8003db0:	b500      	push	{lr}
 8003db2:	b085      	sub	sp, #20
 8003db4:	9003      	str	r0, [sp, #12]
 8003db6:	9102      	str	r1, [sp, #8]
 8003db8:	9201      	str	r2, [sp, #4]
 8003dba:	9300      	str	r3, [sp, #0]

  chDbgCheck((mp != NULL) &&
 8003dbc:	9b03      	ldr	r3, [sp, #12]
 8003dbe:	2b00      	cmp	r3, #0
 8003dc0:	bf0c      	ite	eq
 8003dc2:	2301      	moveq	r3, #1
 8003dc4:	2300      	movne	r3, #0
 8003dc6:	b2db      	uxtb	r3, r3
 8003dc8:	2b00      	cmp	r3, #0
 8003dca:	d107      	bne.n	8003ddc <chPoolObjectInitAligned+0x2c>
 8003dcc:	9b02      	ldr	r3, [sp, #8]
 8003dce:	2b03      	cmp	r3, #3
 8003dd0:	bf94      	ite	ls
 8003dd2:	2301      	movls	r3, #1
 8003dd4:	2300      	movhi	r3, #0
 8003dd6:	b2db      	uxtb	r3, r3
 8003dd8:	2b00      	cmp	r3, #0
 8003dda:	d001      	beq.n	8003de0 <chPoolObjectInitAligned+0x30>
 8003ddc:	2301      	movs	r3, #1
 8003dde:	e000      	b.n	8003de2 <chPoolObjectInitAligned+0x32>
 8003de0:	2300      	movs	r3, #0
 8003de2:	2b00      	cmp	r3, #0
 8003de4:	d107      	bne.n	8003df6 <chPoolObjectInitAligned+0x46>
 8003de6:	9b01      	ldr	r3, [sp, #4]
 8003de8:	2b03      	cmp	r3, #3
 8003dea:	bf94      	ite	ls
 8003dec:	2301      	movls	r3, #1
 8003dee:	2300      	movhi	r3, #0
 8003df0:	b2db      	uxtb	r3, r3
 8003df2:	2b00      	cmp	r3, #0
 8003df4:	d001      	beq.n	8003dfa <chPoolObjectInitAligned+0x4a>
 8003df6:	2301      	movs	r3, #1
 8003df8:	e000      	b.n	8003dfc <chPoolObjectInitAligned+0x4c>
 8003dfa:	2300      	movs	r3, #0
 8003dfc:	2b00      	cmp	r3, #0
 8003dfe:	d117      	bne.n	8003e30 <chPoolObjectInitAligned+0x80>
 8003e00:	9b01      	ldr	r3, [sp, #4]
 8003e02:	2b00      	cmp	r3, #0
 8003e04:	bf0c      	ite	eq
 8003e06:	2301      	moveq	r3, #1
 8003e08:	2300      	movne	r3, #0
 8003e0a:	b2db      	uxtb	r3, r3
 8003e0c:	2b00      	cmp	r3, #0
 8003e0e:	d10a      	bne.n	8003e26 <chPoolObjectInitAligned+0x76>
 8003e10:	9b01      	ldr	r3, [sp, #4]
 8003e12:	1e5a      	subs	r2, r3, #1
 8003e14:	9b01      	ldr	r3, [sp, #4]
 8003e16:	4013      	ands	r3, r2
 8003e18:	2b00      	cmp	r3, #0
 8003e1a:	bf14      	ite	ne
 8003e1c:	2301      	movne	r3, #1
 8003e1e:	2300      	moveq	r3, #0
 8003e20:	b2db      	uxtb	r3, r3
 8003e22:	2b00      	cmp	r3, #0
 8003e24:	d001      	beq.n	8003e2a <chPoolObjectInitAligned+0x7a>
 8003e26:	2301      	movs	r3, #1
 8003e28:	e000      	b.n	8003e2c <chPoolObjectInitAligned+0x7c>
 8003e2a:	2300      	movs	r3, #0
 8003e2c:	2b00      	cmp	r3, #0
 8003e2e:	d002      	beq.n	8003e36 <chPoolObjectInitAligned+0x86>
 8003e30:	4809      	ldr	r0, [pc, #36]	; (8003e58 <chPoolObjectInitAligned+0xa8>)
 8003e32:	f7fe f9e5 	bl	8002200 <chSysHalt>
             (size >= sizeof(void *)) &&
             (align >= PORT_NATURAL_ALIGN) &&
             MEM_IS_VALID_ALIGNMENT(align));

  mp->next = NULL;
 8003e36:	9b03      	ldr	r3, [sp, #12]
 8003e38:	2200      	movs	r2, #0
 8003e3a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
 8003e3c:	9b03      	ldr	r3, [sp, #12]
 8003e3e:	9a02      	ldr	r2, [sp, #8]
 8003e40:	605a      	str	r2, [r3, #4]
  mp->align = align;
 8003e42:	9b03      	ldr	r3, [sp, #12]
 8003e44:	9a01      	ldr	r2, [sp, #4]
 8003e46:	609a      	str	r2, [r3, #8]
  mp->provider = provider;
 8003e48:	9b03      	ldr	r3, [sp, #12]
 8003e4a:	9a00      	ldr	r2, [sp, #0]
 8003e4c:	60da      	str	r2, [r3, #12]
}
 8003e4e:	bf00      	nop
 8003e50:	b005      	add	sp, #20
 8003e52:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e56:	bf00      	nop
 8003e58:	08004770 	.word	0x08004770
 8003e5c:	00000000 	.word	0x00000000

08003e60 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
static inline void *chCoreAllocAlignedI(size_t size, unsigned align) {
 8003e60:	b500      	push	{lr}
 8003e62:	b083      	sub	sp, #12
 8003e64:	9001      	str	r0, [sp, #4]
 8003e66:	9100      	str	r1, [sp, #0]

  return chCoreAllocAlignedWithOffsetI(size, align, 0U);
 8003e68:	2200      	movs	r2, #0
 8003e6a:	9900      	ldr	r1, [sp, #0]
 8003e6c:	9801      	ldr	r0, [sp, #4]
 8003e6e:	f7ff ff27 	bl	8003cc0 <chCoreAllocFromTopI>
 8003e72:	4603      	mov	r3, r0
}
 8003e74:	4618      	mov	r0, r3
 8003e76:	b003      	add	sp, #12
 8003e78:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e7c:	0000      	movs	r0, r0
	...

08003e80 <chPoolObjectInit>:
 *
 * @init
 */
static inline void chPoolObjectInit(memory_pool_t *mp,
                                    size_t size,
                                    memgetfunc_t provider) {
 8003e80:	b500      	push	{lr}
 8003e82:	b085      	sub	sp, #20
 8003e84:	9003      	str	r0, [sp, #12]
 8003e86:	9102      	str	r1, [sp, #8]
 8003e88:	9201      	str	r2, [sp, #4]

  chPoolObjectInitAligned(mp, size, PORT_NATURAL_ALIGN, provider);
 8003e8a:	9b01      	ldr	r3, [sp, #4]
 8003e8c:	2204      	movs	r2, #4
 8003e8e:	9902      	ldr	r1, [sp, #8]
 8003e90:	9803      	ldr	r0, [sp, #12]
 8003e92:	f7ff ff8d 	bl	8003db0 <chPoolObjectInitAligned>
}
 8003e96:	bf00      	nop
 8003e98:	b005      	add	sp, #20
 8003e9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e9e:	bf00      	nop

08003ea0 <dyn_list_init>:
    *dp++ = c;
    i--;
  } while ((c != (char)0) && (i > 0U));
}

static inline void dyn_list_init(dyn_list_t *dlp) {
 8003ea0:	b082      	sub	sp, #8
 8003ea2:	9001      	str	r0, [sp, #4]

  dlp->next = (dyn_element_t *)dlp;
 8003ea4:	9b01      	ldr	r3, [sp, #4]
 8003ea6:	9a01      	ldr	r2, [sp, #4]
 8003ea8:	601a      	str	r2, [r3, #0]
}
 8003eaa:	bf00      	nop
 8003eac:	b002      	add	sp, #8
 8003eae:	4770      	bx	lr

08003eb0 <__factory_init>:
/**
 * @brief   Initializes the objects factory.
 *
 * @init
 */
void __factory_init(void) {
 8003eb0:	b508      	push	{r3, lr}

#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&ch_factory.mtx);
 8003eb2:	4810      	ldr	r0, [pc, #64]	; (8003ef4 <__factory_init+0x44>)
 8003eb4:	f7ff fe94 	bl	8003be0 <chMtxObjectInit>
#else
  chSemObjectInit(&ch_factory.sem, (cnt_t)1);
#endif

#if CH_CFG_FACTORY_OBJECTS_REGISTRY == TRUE
  dyn_list_init(&ch_factory.obj_list);
 8003eb8:	480f      	ldr	r0, [pc, #60]	; (8003ef8 <__factory_init+0x48>)
 8003eba:	f7ff fff1 	bl	8003ea0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.obj_pool,
 8003ebe:	4a0f      	ldr	r2, [pc, #60]	; (8003efc <__factory_init+0x4c>)
 8003ec0:	2114      	movs	r1, #20
 8003ec2:	480f      	ldr	r0, [pc, #60]	; (8003f00 <__factory_init+0x50>)
 8003ec4:	f7ff ffdc 	bl	8003e80 <chPoolObjectInit>
                   sizeof (registered_object_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_GENERIC_BUFFERS == TRUE
  dyn_list_init(&ch_factory.buf_list);
 8003ec8:	480e      	ldr	r0, [pc, #56]	; (8003f04 <__factory_init+0x54>)
 8003eca:	f7ff ffe9 	bl	8003ea0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_SEMAPHORES == TRUE
  dyn_list_init(&ch_factory.sem_list);
 8003ece:	480e      	ldr	r0, [pc, #56]	; (8003f08 <__factory_init+0x58>)
 8003ed0:	f7ff ffe6 	bl	8003ea0 <dyn_list_init>
  chPoolObjectInit(&ch_factory.sem_pool,
 8003ed4:	4a09      	ldr	r2, [pc, #36]	; (8003efc <__factory_init+0x4c>)
 8003ed6:	211c      	movs	r1, #28
 8003ed8:	480c      	ldr	r0, [pc, #48]	; (8003f0c <__factory_init+0x5c>)
 8003eda:	f7ff ffd1 	bl	8003e80 <chPoolObjectInit>
                   sizeof (dyn_semaphore_t),
                   chCoreAllocAlignedI);
#endif
#if CH_CFG_FACTORY_MAILBOXES == TRUE
  dyn_list_init(&ch_factory.mbx_list);
 8003ede:	480c      	ldr	r0, [pc, #48]	; (8003f10 <__factory_init+0x60>)
 8003ee0:	f7ff ffde 	bl	8003ea0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_OBJ_FIFOS == TRUE
  dyn_list_init(&ch_factory.fifo_list);
 8003ee4:	480b      	ldr	r0, [pc, #44]	; (8003f14 <__factory_init+0x64>)
 8003ee6:	f7ff ffdb 	bl	8003ea0 <dyn_list_init>
#endif
#if CH_CFG_FACTORY_PIPES == TRUE
  dyn_list_init(&ch_factory.pipe_list);
 8003eea:	480b      	ldr	r0, [pc, #44]	; (8003f18 <__factory_init+0x68>)
 8003eec:	f7ff ffd8 	bl	8003ea0 <dyn_list_init>
#endif
}
 8003ef0:	bf00      	nop
 8003ef2:	bd08      	pop	{r3, pc}
 8003ef4:	2000128c 	.word	0x2000128c
 8003ef8:	2000129c 	.word	0x2000129c
 8003efc:	08003e61 	.word	0x08003e61
 8003f00:	200012a0 	.word	0x200012a0
 8003f04:	200012b0 	.word	0x200012b0
 8003f08:	200012b4 	.word	0x200012b4
 8003f0c:	200012b8 	.word	0x200012b8
 8003f10:	200012c8 	.word	0x200012c8
 8003f14:	200012cc 	.word	0x200012cc
 8003f18:	200012d0 	.word	0x200012d0
 8003f1c:	00000000 	.word	0x00000000

08003f20 <__NVIC_SetPriorityGrouping>:
           In case of a conflict between priority grouping and available
           priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.
  \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 8003f20:	b084      	sub	sp, #16
 8003f22:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 8003f24:	9b01      	ldr	r3, [sp, #4]
 8003f26:	f003 0307 	and.w	r3, r3, #7
 8003f2a:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8003f2c:	4b0b      	ldr	r3, [pc, #44]	; (8003f5c <__NVIC_SetPriorityGrouping+0x3c>)
 8003f2e:	68db      	ldr	r3, [r3, #12]
 8003f30:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8003f32:	9a02      	ldr	r2, [sp, #8]
 8003f34:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 8003f38:	4013      	ands	r3, r2
 8003f3a:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8003f3c:	9b03      	ldr	r3, [sp, #12]
 8003f3e:	021a      	lsls	r2, r3, #8
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 8003f40:	9b02      	ldr	r3, [sp, #8]
 8003f42:	4313      	orrs	r3, r2
  reg_value  =  (reg_value                                   |
 8003f44:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 8003f48:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 8003f4c:	9302      	str	r3, [sp, #8]
  SCB->AIRCR =  reg_value;
 8003f4e:	4a03      	ldr	r2, [pc, #12]	; (8003f5c <__NVIC_SetPriorityGrouping+0x3c>)
 8003f50:	9b02      	ldr	r3, [sp, #8]
 8003f52:	60d3      	str	r3, [r2, #12]
}
 8003f54:	bf00      	nop
 8003f56:	b004      	add	sp, #16
 8003f58:	4770      	bx	lr
 8003f5a:	bf00      	nop
 8003f5c:	e000ed00 	.word	0xe000ed00

08003f60 <__NVIC_SetPriority>:
  \param [in]      IRQn  Interrupt number.
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8003f60:	b082      	sub	sp, #8
 8003f62:	4603      	mov	r3, r0
 8003f64:	9100      	str	r1, [sp, #0]
 8003f66:	f88d 3007 	strb.w	r3, [sp, #7]
  if ((int32_t)(IRQn) >= 0)
 8003f6a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8003f6e:	2b00      	cmp	r3, #0
 8003f70:	db0a      	blt.n	8003f88 <__NVIC_SetPriority+0x28>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003f72:	9b00      	ldr	r3, [sp, #0]
 8003f74:	b2da      	uxtb	r2, r3
 8003f76:	490c      	ldr	r1, [pc, #48]	; (8003fa8 <__NVIC_SetPriority+0x48>)
 8003f78:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8003f7c:	0112      	lsls	r2, r2, #4
 8003f7e:	b2d2      	uxtb	r2, r2
 8003f80:	440b      	add	r3, r1
 8003f82:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
  }
}
 8003f86:	e00b      	b.n	8003fa0 <__NVIC_SetPriority+0x40>
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8003f88:	9b00      	ldr	r3, [sp, #0]
 8003f8a:	b2da      	uxtb	r2, r3
 8003f8c:	4907      	ldr	r1, [pc, #28]	; (8003fac <__NVIC_SetPriority+0x4c>)
 8003f8e:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003f92:	f003 030f 	and.w	r3, r3, #15
 8003f96:	3b04      	subs	r3, #4
 8003f98:	0112      	lsls	r2, r2, #4
 8003f9a:	b2d2      	uxtb	r2, r2
 8003f9c:	440b      	add	r3, r1
 8003f9e:	761a      	strb	r2, [r3, #24]
}
 8003fa0:	bf00      	nop
 8003fa2:	b002      	add	sp, #8
 8003fa4:	4770      	bx	lr
 8003fa6:	bf00      	nop
 8003fa8:	e000e100 	.word	0xe000e100
 8003fac:	e000ed00 	.word	0xe000ed00

08003fb0 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch and, optionally, for system calls.
 * @note    The SVC vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003fb0:	b084      	sub	sp, #16
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8003fb2:	f3ef 8309 	mrs	r3, PSP
 8003fb6:	9300      	str	r3, [sp, #0]
  return(result);
 8003fb8:	9b00      	ldr	r3, [sp, #0]
/*lint -restore*/
  uint32_t psp = __get_PSP();
 8003fba:	9303      	str	r3, [sp, #12]
    /* From privileged mode, it is used for context discarding in the
       preemption code.*/

    /* Unstacking procedure, discarding the current exception context and
       positioning the stack to point to the real one.*/
    psp += sizeof (struct port_extctx);
 8003fbc:	9b03      	ldr	r3, [sp, #12]
 8003fbe:	3320      	adds	r3, #32
 8003fc0:	9303      	str	r3, [sp, #12]
 8003fc2:	9b03      	ldr	r3, [sp, #12]
 8003fc4:	9301      	str	r3, [sp, #4]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8003fc6:	9b01      	ldr	r3, [sp, #4]
 8003fc8:	f383 8809 	msr	PSP, r3
}
 8003fcc:	bf00      	nop
 8003fce:	2300      	movs	r3, #0
 8003fd0:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003fd2:	9b02      	ldr	r3, [sp, #8]
 8003fd4:	f383 8811 	msr	BASEPRI, r3
}
 8003fd8:	bf00      	nop
 8003fda:	bf00      	nop
}
 8003fdc:	bf00      	nop
#endif

    /* Restoring the normal interrupts status.*/
    port_unlock_from_isr();
  }
}
 8003fde:	bf00      	nop
 8003fe0:	b004      	add	sp, #16
 8003fe2:	4770      	bx	lr
	...

08003ff0 <port_init>:
 *
 * @param[in, out] oip  pointer to the @p os_instance_t structure
 *
 * @notapi
 */
void port_init(os_instance_t *oip) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b085      	sub	sp, #20
 8003ff4:	9001      	str	r0, [sp, #4]
 8003ff6:	2330      	movs	r3, #48	; 0x30
 8003ff8:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8003ffa:	9b03      	ldr	r3, [sp, #12]
 8003ffc:	f383 8811 	msr	BASEPRI, r3
}
 8004000:	bf00      	nop
  __ASM volatile ("cpsie i" : : : "memory");
 8004002:	b662      	cpsie	i
}
 8004004:	bf00      	nop
}
 8004006:	bf00      	nop

  /* Starting in a known IRQ configuration.*/
  port_suspend();

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8004008:	2003      	movs	r0, #3
 800400a:	f7ff ff89 	bl	8003f20 <__NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800400e:	4b0d      	ldr	r3, [pc, #52]	; (8004044 <port_init+0x54>)
 8004010:	68db      	ldr	r3, [r3, #12]
 8004012:	4a0c      	ldr	r2, [pc, #48]	; (8004044 <port_init+0x54>)
 8004014:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8004018:	60d3      	str	r3, [r2, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800401a:	4b0b      	ldr	r3, [pc, #44]	; (8004048 <port_init+0x58>)
 800401c:	681b      	ldr	r3, [r3, #0]
 800401e:	4a0a      	ldr	r2, [pc, #40]	; (8004048 <port_init+0x58>)
 8004020:	f043 0301 	orr.w	r3, r3, #1
 8004024:	6013      	str	r3, [r2, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8004026:	2102      	movs	r1, #2
 8004028:	f06f 0004 	mvn.w	r0, #4
 800402c:	f7ff ff98 	bl	8003f60 <__NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8004030:	2103      	movs	r1, #3
 8004032:	f06f 0001 	mvn.w	r0, #1
 8004036:	f7ff ff93 	bl	8003f60 <__NVIC_SetPriority>

#if (PORT_ENABLE_GUARD_PAGES == TRUE) || (PORT_USE_SYSCALL == TRUE)
  /* MPU is enabled.*/
  mpuEnable(MPU_CTRL_PRIVDEFENA);
#endif
}
 800403a:	bf00      	nop
 800403c:	b005      	add	sp, #20
 800403e:	f85d fb04 	ldr.w	pc, [sp], #4
 8004042:	bf00      	nop
 8004044:	e000edf0 	.word	0xe000edf0
 8004048:	e0001000 	.word	0xe0001000
 800404c:	00000000 	.word	0x00000000

08004050 <__port_irq_epilogue>:
#endif

/**
 * @brief   Exception exit redirection to @p __port_switch_from_isr().
 */
void __port_irq_epilogue(void) {
 8004050:	b500      	push	{lr}
 8004052:	b087      	sub	sp, #28
 8004054:	2330      	movs	r3, #48	; 0x30
 8004056:	9303      	str	r3, [sp, #12]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 8004058:	9b03      	ldr	r3, [sp, #12]
 800405a:	f383 8811 	msr	BASEPRI, r3
}
 800405e:	bf00      	nop
}
 8004060:	bf00      	nop
}
 8004062:	bf00      	nop

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8004064:	4b18      	ldr	r3, [pc, #96]	; (80040c8 <__port_irq_epilogue+0x78>)
 8004066:	685b      	ldr	r3, [r3, #4]
 8004068:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800406c:	2b00      	cmp	r3, #0
 800406e:	d020      	beq.n	80040b2 <__port_irq_epilogue+0x62>
  __ASM volatile ("MRS %0, psp"  : "=r" (result) );
 8004070:	f3ef 8309 	mrs	r3, PSP
 8004074:	9301      	str	r3, [sp, #4]
  return(result);
 8004076:	9b01      	ldr	r3, [sp, #4]
        lctxp->control = control;
        lctxp->ectxp   = (struct port_extctx *)psp;
      }
    }
#else
    s_psp = __get_PSP();
 8004078:	9305      	str	r3, [sp, #20]
#endif

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    s_psp -= sizeof (struct port_extctx);
 800407a:	9b05      	ldr	r3, [sp, #20]
 800407c:	3b20      	subs	r3, #32
 800407e:	9305      	str	r3, [sp, #20]

    /* The port_extctx structure is pointed by the S-PSP register.*/
    ectxp = (struct port_extctx *)s_psp;
 8004080:	9b05      	ldr	r3, [sp, #20]
 8004082:	9304      	str	r3, [sp, #16]

    /* Setting up a fake XPSR register value.*/
    ectxp->xpsr = 0x01000000U;
 8004084:	9b04      	ldr	r3, [sp, #16]
 8004086:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800408a:	61da      	str	r2, [r3, #28]
 800408c:	9b05      	ldr	r3, [sp, #20]
 800408e:	9302      	str	r3, [sp, #8]
  __ASM volatile ("MSR psp, %0" : : "r" (topOfProcStack) : );
 8004090:	9b02      	ldr	r3, [sp, #8]
 8004092:	f383 8809 	msr	PSP, r3
}
 8004096:	bf00      	nop
    /* Writing back the modified S-PSP value.*/
    __set_PSP(s_psp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8004098:	f7ff f992 	bl	80033c0 <chSchIsPreemptionRequired>
 800409c:	4603      	mov	r3, r0
 800409e:	2b00      	cmp	r3, #0
 80040a0:	d003      	beq.n	80040aa <__port_irq_epilogue+0x5a>
      /* Preemption is required we need to enforce a context switch.*/
      ectxp->pc = (uint32_t)__port_switch_from_isr;
 80040a2:	4a0a      	ldr	r2, [pc, #40]	; (80040cc <__port_irq_epilogue+0x7c>)
 80040a4:	9b04      	ldr	r3, [sp, #16]
 80040a6:	619a      	str	r2, [r3, #24]
      ectxp->pc = (uint32_t)__port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 80040a8:	e00b      	b.n	80040c2 <__port_irq_epilogue+0x72>
      ectxp->pc = (uint32_t)__port_exit_from_isr;
 80040aa:	4a09      	ldr	r2, [pc, #36]	; (80040d0 <__port_irq_epilogue+0x80>)
 80040ac:	9b04      	ldr	r3, [sp, #16]
 80040ae:	619a      	str	r2, [r3, #24]
    return;
 80040b0:	e007      	b.n	80040c2 <__port_irq_epilogue+0x72>
 80040b2:	2300      	movs	r3, #0
 80040b4:	9300      	str	r3, [sp, #0]
  __ASM volatile ("MSR basepri, %0" : : "r" (basePri) : "memory");
 80040b6:	9b00      	ldr	r3, [sp, #0]
 80040b8:	f383 8811 	msr	BASEPRI, r3
}
 80040bc:	bf00      	nop
}
 80040be:	bf00      	nop
}
 80040c0:	bf00      	nop
  }
  port_unlock_from_isr();
}
 80040c2:	b007      	add	sp, #28
 80040c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80040c8:	e000ed00 	.word	0xe000ed00
 80040cc:	080002e7 	.word	0x080002e7
 80040d0:	080002f2 	.word	0x080002f2
	...

080040e0 <pwmpcb>:
*/

#include "ch.h"
#include "hal.h"

static void pwmpcb(PWMDriver *pwmp) {
 80040e0:	b082      	sub	sp, #8
 80040e2:	9001      	str	r0, [sp, #4]

  (void)pwmp;
  palClearPad(GPIOD, GPIOD_LED5);
 80040e4:	4b03      	ldr	r3, [pc, #12]	; (80040f4 <pwmpcb+0x14>)
 80040e6:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 80040ea:	835a      	strh	r2, [r3, #26]
}
 80040ec:	bf00      	nop
 80040ee:	b002      	add	sp, #8
 80040f0:	4770      	bx	lr
 80040f2:	bf00      	nop
 80040f4:	40020c00 	.word	0x40020c00
	...

08004100 <pwmc1cb>:

static void pwmc1cb(PWMDriver *pwmp) {
 8004100:	b082      	sub	sp, #8
 8004102:	9001      	str	r0, [sp, #4]

  (void)pwmp;
  palSetPad(GPIOD, GPIOD_LED5);
 8004104:	4b03      	ldr	r3, [pc, #12]	; (8004114 <pwmc1cb+0x14>)
 8004106:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 800410a:	831a      	strh	r2, [r3, #24]
}
 800410c:	bf00      	nop
 800410e:	b002      	add	sp, #8
 8004110:	4770      	bx	lr
 8004112:	bf00      	nop
 8004114:	40020c00 	.word	0x40020c00
	...

08004120 <icuwidthcb>:
  0
};

icucnt_t last_width, last_period;

static void icuwidthcb(ICUDriver *icup) {
 8004120:	b082      	sub	sp, #8
 8004122:	9001      	str	r0, [sp, #4]

  palSetPad(GPIOD, GPIOD_LED4);
 8004124:	4b06      	ldr	r3, [pc, #24]	; (8004140 <icuwidthcb+0x20>)
 8004126:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800412a:	831a      	strh	r2, [r3, #24]
  last_width = icuGetWidthX(icup);
 800412c:	9b01      	ldr	r3, [sp, #4]
 800412e:	691b      	ldr	r3, [r3, #16]
 8004130:	681b      	ldr	r3, [r3, #0]
 8004132:	3301      	adds	r3, #1
 8004134:	4a03      	ldr	r2, [pc, #12]	; (8004144 <icuwidthcb+0x24>)
 8004136:	6013      	str	r3, [r2, #0]
}
 8004138:	bf00      	nop
 800413a:	b002      	add	sp, #8
 800413c:	4770      	bx	lr
 800413e:	bf00      	nop
 8004140:	40020c00 	.word	0x40020c00
 8004144:	200012d4 	.word	0x200012d4
	...

08004150 <icuperiodcb>:

static void icuperiodcb(ICUDriver *icup) {
 8004150:	b082      	sub	sp, #8
 8004152:	9001      	str	r0, [sp, #4]

  palClearPad(GPIOD, GPIOD_LED4);
 8004154:	4b06      	ldr	r3, [pc, #24]	; (8004170 <icuperiodcb+0x20>)
 8004156:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 800415a:	835a      	strh	r2, [r3, #26]
  last_period = icuGetPeriodX(icup);
 800415c:	9b01      	ldr	r3, [sp, #4]
 800415e:	695b      	ldr	r3, [r3, #20]
 8004160:	681b      	ldr	r3, [r3, #0]
 8004162:	3301      	adds	r3, #1
 8004164:	4a03      	ldr	r2, [pc, #12]	; (8004174 <icuperiodcb+0x24>)
 8004166:	6013      	str	r3, [r2, #0]
}
 8004168:	bf00      	nop
 800416a:	b002      	add	sp, #8
 800416c:	4770      	bx	lr
 800416e:	bf00      	nop
 8004170:	40020c00 	.word	0x40020c00
 8004174:	200012d8 	.word	0x200012d8
	...

08004180 <main>:
};

/*
 * Application entry point.
 */
int main(void) {
 8004180:	b508      	push	{r3, lr}
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  halInit();
 8004182:	f7fc f915 	bl	80003b0 <halInit>
  chSysInit();
 8004186:	f7fe f80b 	bl	80021a0 <chSysInit>
   * Initializes the PWM driver 2 and ICU driver 3.
   * GPIOA8 is the PWM output.
   * GPIOC6 is the ICU input.
   * The two pins have to be externally connected together.
   */
  pwmStart(&PWMD3, &pwmcfg);
 800418a:	4940      	ldr	r1, [pc, #256]	; (800428c <main+0x10c>)
 800418c:	4840      	ldr	r0, [pc, #256]	; (8004290 <main+0x110>)
 800418e:	f7fc fbc7 	bl	8000920 <pwmStart>
  pwmEnablePeriodicNotification(&PWMD3);
 8004192:	483f      	ldr	r0, [pc, #252]	; (8004290 <main+0x110>)
 8004194:	f7fc fd14 	bl	8000bc0 <pwmEnablePeriodicNotification>
  palSetPadMode(GPIOA, 8, PAL_MODE_ALTERNATE(1));
 8004198:	2282      	movs	r2, #130	; 0x82
 800419a:	f44f 7180 	mov.w	r1, #256	; 0x100
 800419e:	483d      	ldr	r0, [pc, #244]	; (8004294 <main+0x114>)
 80041a0:	f7fd f8de 	bl	8001360 <_pal_lld_setgroupmode>
  icuStart(&ICUD1, &icucfg);
 80041a4:	493c      	ldr	r1, [pc, #240]	; (8004298 <main+0x118>)
 80041a6:	483d      	ldr	r0, [pc, #244]	; (800429c <main+0x11c>)
 80041a8:	f7fc fa1a 	bl	80005e0 <icuStart>
  palSetPadMode(GPIOC, 6, PAL_MODE_ALTERNATE(2));
 80041ac:	f44f 7281 	mov.w	r2, #258	; 0x102
 80041b0:	2140      	movs	r1, #64	; 0x40
 80041b2:	483b      	ldr	r0, [pc, #236]	; (80042a0 <main+0x120>)
 80041b4:	f7fd f8d4 	bl	8001360 <_pal_lld_setgroupmode>
  icuStartCapture(&ICUD1);
 80041b8:	4838      	ldr	r0, [pc, #224]	; (800429c <main+0x11c>)
 80041ba:	f7fc fa99 	bl	80006f0 <icuStartCapture>
  icuEnableNotifications(&ICUD1);
 80041be:	4837      	ldr	r0, [pc, #220]	; (800429c <main+0x11c>)
 80041c0:	f7fc fb0e 	bl	80007e0 <icuEnableNotifications>
  chThdSleepMilliseconds(2000);
 80041c4:	f644 6020 	movw	r0, #20000	; 0x4e20
 80041c8:	f7ff fc6a 	bl	8003aa0 <chThdSleep>

  /*
   * Starts the PWM channel 0 using 75% duty cycle.
   */
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, 7500));
 80041cc:	4b30      	ldr	r3, [pc, #192]	; (8004290 <main+0x110>)
 80041ce:	689b      	ldr	r3, [r3, #8]
 80041d0:	f641 524c 	movw	r2, #7500	; 0x1d4c
 80041d4:	fb02 f303 	mul.w	r3, r2, r3
 80041d8:	4a32      	ldr	r2, [pc, #200]	; (80042a4 <main+0x124>)
 80041da:	fba2 2303 	umull	r2, r3, r2, r3
 80041de:	0b5b      	lsrs	r3, r3, #13
 80041e0:	461a      	mov	r2, r3
 80041e2:	2100      	movs	r1, #0
 80041e4:	482a      	ldr	r0, [pc, #168]	; (8004290 <main+0x110>)
 80041e6:	f7fc fc5b 	bl	8000aa0 <pwmEnableChannel>
  pwmEnableChannelNotification(&PWMD3, 0);
 80041ea:	2100      	movs	r1, #0
 80041ec:	4828      	ldr	r0, [pc, #160]	; (8004290 <main+0x110>)
 80041ee:	f7fc fd1f 	bl	8000c30 <pwmEnableChannelNotification>
  chThdSleepMilliseconds(5000);
 80041f2:	f24c 3050 	movw	r0, #50000	; 0xc350
 80041f6:	f7ff fc53 	bl	8003aa0 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 50% duty cycle.
   */
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, 5000));
 80041fa:	4b25      	ldr	r3, [pc, #148]	; (8004290 <main+0x110>)
 80041fc:	689b      	ldr	r3, [r3, #8]
 80041fe:	f241 3288 	movw	r2, #5000	; 0x1388
 8004202:	fb02 f303 	mul.w	r3, r2, r3
 8004206:	4a27      	ldr	r2, [pc, #156]	; (80042a4 <main+0x124>)
 8004208:	fba2 2303 	umull	r2, r3, r2, r3
 800420c:	0b5b      	lsrs	r3, r3, #13
 800420e:	461a      	mov	r2, r3
 8004210:	2100      	movs	r1, #0
 8004212:	481f      	ldr	r0, [pc, #124]	; (8004290 <main+0x110>)
 8004214:	f7fc fc44 	bl	8000aa0 <pwmEnableChannel>
  chThdSleepMilliseconds(5000);
 8004218:	f24c 3050 	movw	r0, #50000	; 0xc350
 800421c:	f7ff fc40 	bl	8003aa0 <chThdSleep>

  /*
   * Changes the PWM channel 0 to 25% duty cycle.
   */
  pwmEnableChannel(&PWMD3, 0, PWM_PERCENTAGE_TO_WIDTH(&PWMD3, 2500));
 8004220:	4b1b      	ldr	r3, [pc, #108]	; (8004290 <main+0x110>)
 8004222:	689b      	ldr	r3, [r3, #8]
 8004224:	f640 12c4 	movw	r2, #2500	; 0x9c4
 8004228:	fb02 f303 	mul.w	r3, r2, r3
 800422c:	4a1d      	ldr	r2, [pc, #116]	; (80042a4 <main+0x124>)
 800422e:	fba2 2303 	umull	r2, r3, r2, r3
 8004232:	0b5b      	lsrs	r3, r3, #13
 8004234:	461a      	mov	r2, r3
 8004236:	2100      	movs	r1, #0
 8004238:	4815      	ldr	r0, [pc, #84]	; (8004290 <main+0x110>)
 800423a:	f7fc fc31 	bl	8000aa0 <pwmEnableChannel>
  chThdSleepMilliseconds(5000);
 800423e:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004242:	f7ff fc2d 	bl	8003aa0 <chThdSleep>

  /*
   * Changes PWM period to half second the duty cycle becomes 50%
   * implicitly.
   */
  pwmChangePeriod(&PWMD3, 5000);
 8004246:	f241 3188 	movw	r1, #5000	; 0x1388
 800424a:	4811      	ldr	r0, [pc, #68]	; (8004290 <main+0x110>)
 800424c:	f7fc fbf8 	bl	8000a40 <pwmChangePeriod>
  chThdSleepMilliseconds(5000);
 8004250:	f24c 3050 	movw	r0, #50000	; 0xc350
 8004254:	f7ff fc24 	bl	8003aa0 <chThdSleep>

  /*
   * Disables channel 0 and stops the drivers.
   */
  pwmDisableChannel(&PWMD3, 0);
 8004258:	2100      	movs	r1, #0
 800425a:	480d      	ldr	r0, [pc, #52]	; (8004290 <main+0x110>)
 800425c:	f7fc fc68 	bl	8000b30 <pwmDisableChannel>
  pwmStop(&PWMD3);
 8004260:	480b      	ldr	r0, [pc, #44]	; (8004290 <main+0x110>)
 8004262:	f7fc fbad 	bl	80009c0 <pwmStop>
  icuStopCapture(&ICUD1);
 8004266:	480d      	ldr	r0, [pc, #52]	; (800429c <main+0x11c>)
 8004268:	f7fc fa72 	bl	8000750 <icuStopCapture>
  icuStop(&ICUD1);
 800426c:	480b      	ldr	r0, [pc, #44]	; (800429c <main+0x11c>)
 800426e:	f7fc fa07 	bl	8000680 <icuStop>
  palClearPad(GPIOD, GPIOD_LED4);
 8004272:	4b0d      	ldr	r3, [pc, #52]	; (80042a8 <main+0x128>)
 8004274:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8004278:	835a      	strh	r2, [r3, #26]
  palClearPad(GPIOD, GPIOD_LED5);
 800427a:	4b0b      	ldr	r3, [pc, #44]	; (80042a8 <main+0x128>)
 800427c:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8004280:	835a      	strh	r2, [r3, #26]

  /*
   * Normal main() thread activity, in this demo it does nothing.
   */
  while (true) {
    chThdSleepMilliseconds(500);
 8004282:	f241 3088 	movw	r0, #5000	; 0x1388
 8004286:	f7ff fc0b 	bl	8003aa0 <chThdSleep>
 800428a:	e7fa      	b.n	8004282 <main+0x102>
 800428c:	20000800 	.word	0x20000800
 8004290:	20000870 	.word	0x20000870
 8004294:	40020000 	.word	0x40020000
 8004298:	20000838 	.word	0x20000838
 800429c:	20000858 	.word	0x20000858
 80042a0:	40020800 	.word	0x40020800
 80042a4:	d1b71759 	.word	0xd1b71759
 80042a8:	40020c00 	.word	0x40020c00
